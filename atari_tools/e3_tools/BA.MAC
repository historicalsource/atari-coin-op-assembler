	.TITLE RT-11 BATCH HANDLER V01-03

; RT-11 BATCH RESIDENT HANDLER
;
; JANUARY 75
; JD/DV
;
; COPYRIGHT (C) 1975
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS
; SOFTWARE, OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED
; OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON EXCEPT
; FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE
; LICENSE TERMS. TITLE TO AND OWNERSHIP OF THE SOFTWARE
; SHALL AT ALL TIMES REMAIN IN DIGITAL.

; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
; DIGITAL ASSUMES NO RESPONSIBILITY FOR ANY ERRORS THAT
; MAY APPEAR IN THIS SOFTWARE.


; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE
; OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DIGITAL.
;
	.SBTTL	CONTROL CHARACTER DEFINITIONS

; FILE GENERATED BY THE BATCH COMPILER (OR TECO IF YOU DESIRE)
; BATCH HAS SEVERAL CONTROLLING COMMANDS, THESE COMMANDS ARE NOT RELATED
; TO ANYTHING IN THE DEC BATCH STANDARD, ANY RESEMBLANCE IS PURELY
; COINCIDENTAL. THE BATCH COMPILER WILL TRANSLATE THE DEC BATCH STANDARD
; (LEVEL1) INTO RT-11 BATCH RUNTIME HANDLER FORMAT.
; ALL DIRECTIVES IN THE SPECIAL INPUT FORMAT ARE PRECEEDED BY A BACKSLASH.
; IF A BACKSLASH MUST BE PASSED TWO ADJACENT BACKSLASHES WILL PASS ONE.

; SINGLE CHARACTER DIRECTIVES:
; "\@" ROUTE THE FOLLOWING CHARACTERS TO THE CTY:
; "\A" CHANGE THE INPUT SOURCE TO THE CTY:
; "\B" CHANGE THE INPUT SOURCE TO THE BATCH STREAM
; "\C" ROUTE THE FOLLOWING CHARACTERS TO THE LOG
; "\D" THE FOLLOWING CHARACTERS ARE USER DATA
; "\E" THE FOLLOWING CHARACTERS ARE TO BE EXECUTED BY THE KMON.
; "\FN" N=0, FORCE THE JOB TO ABORT
;       N=1, OUTPUT CURRENT LOG BUFFER AND EXIT
; "\G" GET FROM CTY EXCLUDING C.R.
; "\HN"	HELP, N=0, LOG ONLY .TTYOUT, .PRINT
;	N=1, LOG .TTYOUT, .PRINT, .TTYIN
;	N=2, NO LOGGING OF .TTYOUT, .TTYIN, .PRINT
;	N=3, LOG .TTYIN
;	IN ALL CASES ABOVE  ALL MESSAGES (\C) ARE NOT AFFECTED
; "\IVALEG"	IF DIRECTIVE
;	V=A-Z, VARIABLE FOR COMPARISON
;	A=0-377, ARGUMENT FOR COMPARISON
;	L,E,G=STRINGS OF SIX CHARACTERS PLUS A "0" OR "1" EACH
;	TRANSFER WILL GO TO LABEL L IF THE EXPRESSION (R-V) IS <0
;	IF THE CHARACTER FOLLOWING L="0" THEN THIS INDICATES
;	THAT THE LABEL IS A BACKWARD REFERENCE. IF THE CHARACTER FOLLOWING
;	L="1" THEN THIS INDICATES THAT THE LABEL IS A FOREWARD REFERENCE.
;	E,G ARE LABELS TO GOTO FOR THE EXPRESSION (R-V) =,>0. THEY ARE ALSO
;	FOLLOWED BY A "0" OR "1"
; "\JL" UNCONDITIONAL JUMP TO LABEL L
; "\KVF(D)" 'KONSTANT' V = VARIABLE (A-Z), F = FUNCTION
;	F = 0, INCRIMENT VARIABLE V
;	F = 1, MOVE DATA BYTE D INTO VARIABLE V
;	F = 2, RETURN VALUE OF VARIABLE V TO .TTYIN CALL
; "\L" LABEL, NEXT SIX BYTES ARE A LABEL ANY MORE CHARACTERS ARE IGNORED.


; IF FB IS RUNNING .TTYIN,.TTYOUT,.PRINT AND .EXIT EMT'S
; WILL POINT TO FB$TIN,FB$TOT,FB$PRN AND FB$EXT. ON THE OTHER HAND
; IF YOU ARE RUNNING BACKGROUND ONLY THEY POINT TO B$TIN,B$TOT,
; B$PRN AND B$EXT. O$TIN,O$TOT,O$PRN AND O$EXT HAVE THE REAL
; POINTERS TO THE MONITOR EMT'S
.SBTTL	DEFINITIONS
	R0=%0
	R1=%1
	R2=%2
	R3=%3
	R4=%4
	R5=%5
	SP=%6
	PC=%7
	JSW=	44	;JOB STATUS WORD
	ERRWRD=	52	;RT-11 ERROR WORD LOCATION
	MONCOM=	356	;MONITOR COMMUNICATION BYTE
	SYSPTR= 54	;POINTER TO SYSTEM
	CONTXT= 320	;POINTER IN FBMON TO JSTATE
	COMREG=	7	;COMMUNICATION REGISTER
	EMT16=	316	;DISPLACEMENT OFF OF 54 TO DISPLACEMENT OFF OF
			;54 TO THE EMT 16 TABLE.
	CONFIG=	300	;DISPLACEMENT OFF OF 54 TO WORD WITH MONITOR TYPE
	FBMON$=	1	;BIT IN CONFIG THAT INDICATES F/B OR BG ONLY.
	JOBNUM=	24	;IF F/B IS RUNNING THIS IS THE DISPLACEMENT
			;OFF OF R5 (IMPURE AREA) OF THE LOCATION WITH
			;THE JOB NUMBER.

	INBSIZ=	400	;INPUT BUFFER SIZE
	OUBSIZ=	400	;OUTPUT BUFFER SIZE
	BATSTK=	0	;SIZE OF BATCH STACK. IF ZERO USE USERS STACK.
	LABSIZ=	6	;NUMBER OF CHARACTERS PER LABEL
	TCBIT$=	100
.SBTTL	MACRO DEFINITIONS
.MACRO	ADDR ADDRESS,REG
	MOV	PC,REG
	ADD	#ADDRESS-.,REG
	.ENDM

.MACRO	LINK1 N,OLD		;LINK HANDLER TO MONITOR
	MOV	N*2(R1),R2
	ADD	R1,R2
	ADDR	OLD,R3
	SUB	R3,R2
	MOV	R2,OLD
	.ENDM

.MACRO	LINK2 N,LABLE		;LINK MONITOR TO HANDLER
	ADDR	LABLE,R3
	SUB	R1,R3
	MOV	R3,N*2(R1)
	.ENDM

	.IF NE BATSTK
.MACRO	SAVSTK
	MOV	SP,SPSAVE
	ADDR	SPSAVE,R4
	MOV	R4,SP		;DON'T "ADDR SPSAVE,SP"*********
	.ENDM

.MACRO	RESSTK
	MOV	SPSAVE,SP
	.ENDM
	.ENDC

.MACRO	SAVE,A0,A1,A2,A3,A4,A5
	.IRP	X,<A0,A1,A2,A3,A4,A5>
	.IIF NB <X>,MOV X,-(SP)
	.ENDR
	.ENDM

.MACRO	RESTOR,A0,A1,A2,A3,A4,A5
	.IRP X,<A5,A4,A3,A2,A1,A0>
	.IIF NB <X>,MOV (SP)+,X
	.ENDR
	.ENDM
.CSECT BATHND
	HSIZE=	BATEND-.
	DVSIZ=	0
	PNAME=	'B-100*50+'A-100*50+0	;.RAD50 /BA /
	STAT=	4

LOADPT:
	.WORD	0		;NO INTERRUPT VECTOR
	.WORD	BAINTR-.+2	;ABORT ENTRY POINT
	.WORD	0		;NO PRIORITY
BALQE:	.WORD	0		;NO QUEUE
BACQE:	.WORD	0		;NO QUEUE

BA:	BR	BA0
;***** BATSW1 MUST BE HERE
BATSW1:	.WORD	0		;BATCH HANDLER SWITCH 1
		SOURCE=	     4	;IF 1 GET A CHARACTER THROUGH
				;THE BATCH HANDLER. IF 0 LET
				;THE EMT GO TO THE MONITER
		BSOURC=	 40000	;IF 1 INPUT COMES FROM THE
				;BATCH STREAM. IF 0 INPUT COMES
				;FROM THE CTY:.
		NOTTY=	   400	;DON'T ALLOW TELETYPE OUTPUT IN LOG
;******* NOTTY MUST BE 400 *******
		DESTON=      2	;IF 1 OUTPUT TO BATCH
				;IF 0 OUTPUT TO RMON.
		BDESTN=	   100	;IF 1 BATCH LOG IS OUTPUT
				;IF 0 CTY: IS OUTPUT.
		DATA=	    40	;IF 1 CHARACTERS FOLLOWING ARE
				;USER DATA. IF 0 KMON.
		ACTIVE=	    20	;CTY IS ACTIVE.
		COMWAT=	    10	;A COMMAND IS WAITING
		BEXIT=	100000	;AN EXIT WAS SEEN WHILE DATA MODE SET
		BGET=	   200	;"\G" MODE
		HELP=	     1	;HELP MODE
;******* HELP MUST BE 1 *******

BA0:	MOV	BACQE,R0
BRINIT:	BR	INIT
INIT:	BR	INIT1		;*** CHANGES TO POINTER TO BATSW1 AFTER INIT
INIT2:	ADDR	CHAIN,R1	;RETURN ARGUMENT POINTERS TO BATCH
	MOV	4(R0),R2	;BUFFER TO PASS ARGS
1$:	MOV	(R1)+,(R2)+
	BPL	1$
BATDON:	ADDR	BACQE,R4	;SET UP RETURN
	MOV	@#SYSPTR,R5
	JMP	@QCOMPL(R5)	;AND EXIT
	QCOMPL=270
	.IF NE	BATSTK
	.BLKW	BATSTK		;STACK SPACE
SPSAVE:	.WORD	0		;OLD STACK POINTER
	.ENDC
INPBUF:				;INPUT BUFFER
INIT1:	MOV	R0,-(SP)	;INITIALIZE **** ONCE ONLY CODE ****
	ADDR	BATSW1,R0
	MOV	R0,INIT		;POINTER TO BATSW1 IN A CONVIENENT PLACE
	INC	BRINIT		;SO WE DON'T GET CALLED AGAIN
	ADDR	INPBUF,R0
	MOV	R0,INBUFF	;POINTER TO INPUT BUFFER
	ADD	#OUTBUF-INPBUF,R0
	MOV	R0,OBUFF	;POINTER TO OUTPUT BUFFER
	MOV	@#SYSPTR,R0
	MOV	EMT16(R0),R1	;POINT TO POINTER TO EMT 16 TABLE
	ADD	R0,R1		;POINTER TO EMT 16 TABLE IN R1
	LINK1	0,O$TIN		;LINK HANDLER TO MONITOR (.TTYIN)
	LINK1	1,O$TOT		;(.TTYOUT)
	LINK1	10,O$EXT	;(.EXIT)
	LINK1	11,O$PRN	;(.PRINT)
	ADDR	FB$EXT,R3	;SET UP FOR SJ MONITOR
	MOV	R3,JSTATE	;ADDR WOULD CAUSE Z ERROR
	BIT	#FBMON$,CONFIG(R0) ;WHAT TYPE OF MONITOR IS IT
	BNE	FGBGMN		;ITS FGBG
	LINK2	0,B$TIN		;NOW LINK RMON TO BATHND (.TTYIN)
	LINK2	1,B$TOT		;(.TTYOUT)
	LINK2	10,B$EXT	;(.EXIT)
	LINK2	11,B$PRN	;(.PRINT)
	MOV	(SP)+,R0
	JMP	INIT2

FGBGMN:	MOV	@#SYSPTR,R0
	MOV	CONTXT(R0),JSTATE ;SET UP STATE TO POINT TO WORD
				;WITH ADDRESS CHECKING BITS
	LINK2	0,FB$TIN	;FGBG MON
	LINK2	1,FB$TOT
	LINK2	10,FB$EXT
	LINK2	11,FB$PRN
	MOV	(SP)+,R0
	JMP	INIT2

	OUTBUF=	INBSIZ*2+INPBUF
	.=INPBUF+INBSIZ+INBSIZ+OUBSIZ+OUBSIZ
.SBTTL	BTTI
BTTI:	JSR	PC,GETCHR	;GET A CHARACTER
BTTIS:	CMP	#'\,R0		;IS IT A BACKSLASH?
	BEQ	2$		;YES, BACKSLASHES GET SPECIAL TREATMENT
1$:	TST	(R4)		;CHECK FOR "EXIT" MODE
	BMI	3$
	RTS	PC

3$:	TST	(SP)+
	JMP	BAT03B

2$:	JSR	PC,GETCHR	;CHECK THE CHAR AFTER THE "\"
	CMP	#'\,R0
	BEQ	1$		;FOR TWO BACKSLASHS YOU GET ONE.
	CMP	#177,R0		;RUBOUT?  *** ADDED 9/29/78 D.SHEPPERD,ATARI INC
	BEQ	1$		;YES. IGNORE PREVIOUS \ ****
	INC	R0
	;***** KEEP BIC AND ASL TOGETHER ****
	BIC	(PC),R0
	ASL	R0		;*2+2
	;**********
	TST	(SP)+		;WIPE OUT THE JSR
	CMP	#TABSIZ,R0	;IS IT IN RANGE?
	BLT	ABORT		;NO, SOMETHING IS WRONG VERY WRONG
	ADD	PC,R0		;POINT INTO TABLE
	ADD	(R0),PC		;DO JUMP TO ADDRESS OF FUNCTION
BATTBL:	.WORD BAT00-BATTBL	;"\@"
	.WORD BAT01-BATTBL	;"\A"
	.WORD BAT02-BATTBL	;"\B"
	.WORD BAT03-BATTBL	;"\C"
	.WORD BAT04-BATTBL	;"\D"
	.WORD BAT05-BATTBL	;"\E"
	.WORD BAT06-BATTBL	;"\F"
	.WORD BAT07-BATTBL	;"\G"
	.WORD BAT08-BATTBL	;"\H"
	.WORD BAT09-BATTBL	;"\I"
	.WORD BAT10-BATTBL	;"\J"
	.WORD BAT11-BATTBL	;"\K"
	.WORD BAT12-BATTBL	;"\L"
	TABSIZ=.-BATTBL
.SBTTL	I,J,K, AND L DIRECTIVES


; GETREG POINTS R2 TO THE BATCH INTERNAL VARIABLE
; WHICH IS BEING REFERENCED BY A \K OR \I DIRECTIVE. THE 26 BATCH
; VARIABLES ARE RESIDENT IN THE HANDLER AT BATREG AND ARE REFERENCED
; BY THE LETTERS A - Z. NOTE THAT A PSEUDO-VARIABLE IS AVAILABLE
; THAT IS LOCATED AT THE FIXED OFFSET MONCOM INTO THE RT-11 RESIDENT.
; THIS VARIABLE CAN BE REFERENCED BY USING AN @ AS THE VARIABLE
; NAME. THE @ VARIABLE WILL BE SET BY FUTURE VERSIONS OF THE RT-11 CUSPS
; TO INDICATE WHETHER AN ERROR OCCURRED DURING EXECUTION. THIS WILL
; PERMIT PARTS OF A BATCH STREAM TO BE BY-PASSED IF ERRORS OCCURRED.

GETREG:	JSR	PC,GETBAT	;REGISTER NUMBER
	MOV	@#SYSPTR,R2	;INITIALIZE TO MONCOM
	ADD	#MONCOM,R2
	BIC	#177740,R0	;SELF PRESERVATION
	BEQ	JGTBAT		;SAVE CODE AND FETCH NEXT CHAR

1$:	ADDR	BATREG-1,R2
	ADD	R0,R2		;R2 POINTES TO BYTE REGISTER
2$:	BR	JGTBAT		;SAVE SOME CODE AND FETCH THE NEXT CHAR

; \I PROCESSING  --  IF STATEMENT
BAT09:	JSR	PC,GETREG	;GET REGISTER AND VALUE
	CMPB	(R2),R0		;COMPARE REG WITH VALUE
	BLT	BAT10		;REG<VALUE
	JSR	PC,GETLB2

; \J PROCESSING  --  UNCONDITIONAL JUMP
BAT10:	JSR	PC,GETLAB
	ROR	R0		;CHECK FOR FOREWARD/BACKWARD REFERENCE
	BCS	1$		;FOREWARD, DON'T REWIND
	CLR	INBLOK		;BACKWARD, START AT CHARACTER 0
	CLR	BATICT
1$:	ADDR	LABEL+LABSIZ+2,R1 ;LABEL MATCHER
	MOV	#LABSIZ+2,R2
2$:	JSR	PC,GETBAT
	CMP	#'$,R0		;A LABEL OF SIX '$' WILL ALSO MATCH
	BEQ	3$
	CMPB	-(R1),R0
	BNE	1$
3$:	DEC	R2
	BGT	2$
BAT12:	JSR	PC,BTTI		;"\L"
	BR	BAT12		;EAT THE REST OF THE LABEL
GETLB2:	BEQ	GETLAB		;REG = VALUE
	MOV	PC,-(SP)
GETLAB:	ADDR	LABEL+LABSIZ,R1
	MOV	#LABSIZ,R3
1$:	JSR	PC,GETBAT
	MOVB	R0,-(R1)
	DEC	R3
	BGT	1$
JGTBAT:	JMP	GETBAT			;GET THE NEXT CHARACTER AND RETURN

;"\K" PROCESS FOLLOWED BY TWO OR THREE BYTES
BAT11:	JSR	PC,GETREG	;SET UP BATCH REGISTER POINTER
	ROR	R0		;FUNCTION EVEN OR ODD?
	BCC	1$		;FUNCTION EVEN HAS NO DATA BYTE
	JSR	PC,GETBAT	;GET DATA BYTE
	MOVB	R0,(R2)		;STORE
	BR	BAT12
1$:	ROR	R0		;IS IT INCREMENT OR FETCH
	BCS	2$		;FETCH
	INCB	(R2)		;INCREMENT
	BR	BAT12
2$:	TST	(R4)		;IF IN BEXIT MODE
	BMI	BAT12		;RETURN IMMEDIATELY
	CLR	R0
	BISB	(R2),R0		;PUT THE REGISTER IN R0
	BR	B$TIN3		;AND RETURN IT TO THE PROGRAM

BAT08:	BIC	#HELP+NOTTY,(R4)	;CLEAR HELP MODE AND NOTTY BITS
	JSR	PC,BTTI		;GET HELP FUNCTION
	ROR	R0		;IS BIT 0 ON?
	ADC	(R4)		;SET HELP MODE MAYBE
	ROR	R0
	ADCB	1(R4)		;AND A POSSIBL NOTTY BIT
	BR	BAT12

ABORT:	JSR	R1,BAT06B
	.ASCII	"BC"		;BAD CODE

BATFF:	CLR	R0
	JSR	PC,PUTBAT
BAT06:	CMP	BATOCT,#OUBSIZ*2	;"\F"
	BNE	BATFF
	JSR	PC,BTTI		;IF ANY MORE CHARACTERS FORCE EOJ
	JSR	R1,BAT06B
	.ASCII	"FE"		;FORCE END OF JOB

BAT06B:	CLR	(R4)
	JSR	PC,PUTCT2
	BR	J$EXT
BAT05:	BIC	#DATA+BGET,(R4)	;"\E", THE FOLLOWING IS FOR KMON
;	TST	(R4)		;BEXIT? (NOTE BIC RETURNS CONDITIONS ON THE RESULT OF (R4) )
	BMI	J$EXT		;YES GO DO EXIT
;	BPL	BAT05B		;NO
BR$EX0:	MOV	(SP)+,R0	;RESTORE R0
BR$EX1:	BIC	#BEXIT,(R4)
	BR	J$EXT

;BAT05B:	BIT	#ACTIVE,(R4)	;SECOND TIME THROUGH?
;	BNE	BR$EX1		;YES, COMPLETE THE EXIT
;	JSR	PC,GETCTY	;FIRST CHECK TO SEE IF ANYTHING TYPED
;	BCS	J$EXT		;NO, GO DO THE EXIT
;	BIC	#BSOURC+BDESTN,(R4) ;OPPERATOR MUST TYPE PROPER COMMAND
;	BIS	#ACTIVE,(R4)	;CTY: ACTIVE BIT
;	JSR	PC,BTTIS	;PASS UP THE GETCHR
BAT00:	BIC	#BGET,(R4)
1$:	JSR	PC,BTTI		;ROUT ALL OUTPUT CHARACTERS TO THE CTY:.
	JSR	PC,PUTCTY	;OUTPUT TO THE CTY:
	BR	1$

BAT07:	BIS	#BGET,(R4)	;"\G" GET FROM CTY: EXCLUDING C.R.
	BMI	BAT00		;SKIP IF BEXIT MODE
BAT01:	TST	(R4)		;IF IN BEXIT MODE
	BMI	BAT00		;IGNORE THE \A
	BIC	#BSOURC+BDESTN,(R4)	;GET INPUT FROM CTY:.
	BR	B$TIN2
B$TIN:	MOV	INIT,R4		;R4 POINTS TO BATSW1
B$TIN1:	BIT	#SOURCE,(R4)
	BEQ	J$TIN		;PASS THIS ON TO THE RMON EMT
	.IF NE BATSTK
	SAVSTK			;SAVE THE STACK POINTER
	.ENDC
B$TIN2:	JSR	PC,BTTI		;GET A CHARACTER
	CMP	#15,R0		;C.R.?
	BNE	B$TIN3		;NO
	TSTB	(R4)		;"\G" MODE?
	BMI	BAT02		;YES, FORCE A "\B"
B$TIN3:	BIT	#HELP,(R4)	;HELP MODE?
	BEQ	BATRT0		;NO, DON'T ECHO INPUT
	BIT	#10000,@#JSW	;SPECIAL MODE?
	BNE	BATRT0		;YES, LET PROGRAM ECHO
	JSR	PC,PUTCHR	;NO, PUT IT INTO THE LOG
BATRT0:
	.IF EQ BATSTK
	MOV	R0,(SP)
	.IFF
	MOV	R0,@SPSAVE
	.ENDC
BATRTI:
	.IF NE BATSTK
	RESSTK			;RESTORE THE STACK POINTER
	.ENDC
	RESTOR	R1,R2,R3,R4,R5,R0
	RTI			;AND BACK TO THE USER
FB$EXT:	TST	JOBNUM(R5)
	BEQ	B$EXT
J$EXT:	ADD	(PC),PC
O$EXT:	.-.

B$TOT:	MOV	INIT,R4		;R4 POINTS TO BATSW1
	BIT	#DESTON,(R4)
	BEQ	J$TOT
	.IF NE BATSTK
	SAVSTK			;SWITCH STACKS TO BATCH'S STACK
	.ENDC
B$TOT2:	BIT	#NOTTY,(R4)
	BNE	BATRTI		;DON'T LET ANY CHARACTERS GET TO THE LOG
	JSR	PC,PUTBAT
	BR	BATRTI

BAT02:	TST	(R4)		;IF IN BEXIT MODE
	BMI	BAT03A		;SKIP THE \B
	JSR	PC,GETCTY	;LETS PURGE THE INPUT BUFFER
;	BCC	BAT02
	BCS	1$		;#### D.S. 4/79
	CMPB	#12,R0		;#### FLUSH OUT TO NEXT LINE FEED
	BNE	BAT02
1$:	BIS	#BSOURC+BDESTN,(R4) ;"\B", CHANGE INPUT TO BATCH
	BIC	#ACTIVE+BGET,(R4)
	BR	B$TIN2

B$EXT:	MOV	INIT,R4		;R4 POINTS TO BATSW1
;	BIT	#ACTIVE,(R4)
;	BEQ	1$		;?EXIT DRUING .TTYIN?
;	BIS	#SOURCE+DESTON,(R4) ;YES, RESET FLAGS
1$:	BIT	#DATA,(R4)	;CLEAR ANY DATA THAT REMAINS
	BEQ	J$EXT		;DO .EXIT
	.IF NE BATSTK
	SAVSTK
	.ENDC
	MOV	R0,-(SP)
	BIS	#BEXIT,(R4)	;SET EXIT ON DATA MODE SWITCH
BAT03:	BIS	#BDESTN,(R4)	;"\C",ROUTE FOLLOWING CHARACTERS TO LOG
BAT03A:	JSR	PC,BTTI
BAT03B:	JSR	PC,PUTCHR
	BR	BAT03A		;THIS WILL ECHO THE CHARACTERS ON THE LOG

BAT04:	BIS	#DATA,(R4)	;"\D", THE FOLLOWING IS USER DATA
	BR	B$TIN2

FB$TIN:	TST	JOBNUM(R5)	;SEE IF FOREGROUND JOB CALLED US
	BEQ	B$TIN		;NO, LET BATCH TAKE IT
J$TIN:	ADD	(PC),PC		;YES, JUMP TO RMON EMT
O$TIN:	.-.

FB$TOT:	TST	JOBNUM(R5)
	BEQ	B$TOT
J$TOT:	ADD	(PC),PC
O$TOT:	.-.
FB$PRN:	TST	JOBNUM(R5)
	BEQ	B$PRN
J$PRN:	ADD	(PC),PC
O$PRN:	.-.

GETCTY:	SAVE	(R4)		;SAVE BATSW1
	CLR	(R4)		;GO INTO INTERACTIVE MODE
	MOV	#JSW,R1
	SAVE	(R1)
	BIS	#TCBIT$,(R1)	;MAKE SURE WE DON'T GO TO SLEEP
	EMT	16*20		;.TTYIN WILL GOTO RMON
	RESTOR	(R1)		;RESTOR JSW
RESSW1:	RESTOR	(R4)		;RESTOR BATSW1
BAINTR:	RTS	PC		;RETURN CARRY TO CALLER

PUTCT2:	MOV	PC,-(SP)	;DO THIS TWICE
	MOVB	(R1)+,R0
PUTCTY:	TST	R0
	BEQ	PUTDON
	SAVE	(R4)
	CLR	(R4)
1$:	EMT	16*20+1		;.TTYOUT WILL GO TO RMON
	BCS	1$
	BR	RESSW1		;NOW RESTORE THE SWITCH

B$PRCR:	ADDR	CRLF,R0
B$PRN:	MOV	INIT,R4		;R4 POINTS TO BATSW1
	BIT	#DESTON,(R4)
	BEQ	J$PRN
	.IF NE BATSTK
	SAVSTK			;SWITCH STACKS
	.ENDC
	MOV	R0,R1
1$:	MOVB	(R1)+,R0
	BEQ	B$PRCR		;DONE, ECHO CRLF
	CMPB	#200,R0		;SPECIAL EOL?
	BEQ	BATRTI
	JSR	PC,PUTBAT
	BR	1$

GETCHR:	BIT	#BSOURC,(R4)
	BNE	GETBAT		;GET A CHARACTER FROM THE BATCH STREAM
1$:	JSR	PC,GETCTY	;GET A CHARACTER FROM THE CTY:
	BCS	1$
	RTS	PC
READBA:	JSR	R5,RWBAT
	.WORD	INDATA-.-2
BATIPT:	.-.			;CHARACTER POINTER
BATICT:	.-.			;CHARACTER COUNTER
GETBAT:	DEC	BATICT		;ANY MORE CHARACTERS IN THE BUFFER
	BMI	READBA		;NO, GO GET ANOTHER BUFFER
	MOVB	@BATIPT,R0
	INC	BATIPT
	RTS	PC

PUTBAT:	BIT	#BDESTN,(R4)
	BNE	PUTCHR
	JSR	PC,PUTCTY
PUTCHR:	MOVB	R0,@BATOPT
	INC	BATOPT
	DEC	BATOCT
	BNE	PUTDON
	JSR	R5,RWBAT
	.WORD	ODATA-.-2
BATOPT:	.WORD	.-.
BATOCT:	.WORD	OUBSIZ*2
PUTDON:	RTS	PC

;********KEEP INDATA THRU OUTSAV TOGETHER IN THIS ORDER********
INDATA:	.WORD	10*400+0
INBLOK:	.-.
INBUFF:	.-.
INWC:	.WORD	INBSIZ
	.WORD	0		;READW
.IIF NE INDATA-.+12,.ERROR	;CHANGE THE SAVE STATUS IN BATCH
INSAV:	.BLKW	5		;5 WORD BLOCK FOR SAVE STATUS

ODATA:	.WORD	11*400+0
OBLOK:	.-.
OBUFF:	.-.
OWC:	.WORD	OUBSIZ
	.WORD	0		;WRITEW
.IIF NE ODATA-.+12,:^*^:	;CHANGE THE SAVE STATUS IN BATCH
OUTSAV:	.BLKW	5		;SAVE STATUS BUFFER
;**************************************************************

BLKW2:	.BLKW	2		;**** MUST PRECEED OLDSTA ****
OLDSTA:	.BLKW	5		;FOR SAVEING OLD CHANNEL STATUS
CHAIN:	BATSW1-BALQE		;ARGUMENTS TO PASS TO BATCH
	INDATA-BALQE
	ODATA-BALQE
	OUTBUF-BALQE
	BATOPT-BALQE
	BATOCT-BALQE
	BATICT-BALQE
	O$EXT-BALQE
	O$TIN-BALQE
	O$TOT-BALQE
	O$PRN-BALQE
	BATREG-BALQE+100000
;****NOTE THIS LIST IS TERMINATED BY A NEGATIVE NUMBER

RWBAT:	BISB	#2,@JSTATE	;IF FBMON THIS WILL INHIBIT ADDRESS CHECKING
	SAVE	R0,R4,R3
	MOV	(R5)+,R4	;GET OFFSET TO R/W PARAMITER BLOCK
	ADD	R5,R4		;MAKE IT ABSOLUTE
	MOVB	#17,(R4)
RWBAT1:	DECB	(R4)
	BPL	RWBAT2
	RESTOR	R4,R3
	JSR	R1,BAT06B
	.ASCII	"LU"

RWBAT2:	ADDR	BLKW2+2,R3	;TEMPORARY POINTER
	CLR	OLDSTA		;FLAG FOR SAVE STATUS BELOW
	CLR	R0
	BISB	(R4),R0		;PICK UP CHANNEL NUMBER
	EMT	374		; .WAIT ON CHANNEL
	BCC	2$		;OK TO SAVE STATUS
	TSTB	@#ERRWRD
	BEQ	3$		;CHANNEL NOT OPEN. DON'T SAVE STATUS
	BR	RWBAT1		;TRY ANOTHER CHANNEL

2$:	ADDR	OLDSTA,R0	 ;POINTER TO OLDSTA
	MOV	R0,(R3)		;BLKW2+2 GETS OLDSTA
	MOV	#5*400,-(R3)	;SAVE STATUS FUNCTION NUMBER
	MOV	R3,R0		;POINT R0 AT BLKW2
	MOVB	(R4),(R3)	;AND THE CHANNEL NUMBER
	TST	(R3)+		;MAKE SURE THAT R3 POINTS TO BLKW2+2
	EMT	375		; SAVE STATUS
	BCS	RWBAT1
3$:	MOV	R4,(R3)		;SET UP THE REOPEN
	ADD	#12,(R3)	;POINT TO 5 WORD BLOCK
	MOV	#6*400,-(R3)	;REOPEN FUNCTION
	MOVB	(R4),(R3)	;+ CHANNEL NUMBER
	MOV	R3,R0
	EMT	375		;REOPEN
	BCS	RWBAT1		;ERROR IN OPENING
	MOV	R4,R0
	EMT	375		;DO THE READ OR WRITE
	BCC	4$		;OK
	RESTOR	R4,R3
	JSR	R1,BAT06B
	.ASCII	"IO"
4$:	MOV	R3,R0
	MOVB	#7,1(R0)	;.CLOSE
	EMT	375		;THIS HAS TO BE GOOD
	TST	OLDSTA
	BEQ	5$		;DON'T REOPEN
	MOV	R3,R0
	MOVB	#6,1(R0)
	MOV	R0,2(R0)
	ADD	#4,2(R0)	;POINT TO OLDSTA
	EMT	375		;MUST SUCCEED
5$:	TST	(R4)+		;POINT TO BLOCK NUMBER
	INC	(R4)+		;BUMP THE BLOCK NUMBER,AND POINT TO BUFFER
	MOV	(R4)+,(R5)+
	MOV	(R4),(R5)	;MOVE IN WC
	ASL	(R5)+		;CHANGE TO BYTE COUNT
	RESTOR	R0,R4,R3
	BIC	#2,@(PC)+
JSTATE:	.-.			;POINTS TO STATUS BIT IN FBMON OR FB$EXT IN BATHND
	RTS	R5

BATREG:	.BLKB	32		;26 BYTE REGISTERS
	.BYTE	'0,'0,'0	;THREE '0'S FOR LISTING TEMPORARY'S
	.BYTE 0,0

CRLF:	.BYTE	15
	.BYTE	12
	.BYTE	200
LABEL:	.BLKB	LABSIZ
	.ASCII "L\"
	.EVEN

PATCH:	.REPT	4100-<.-LOADPT>-2/2
	.WORD	0
	.ENDR

$INTEN:	.WORD	0		;.FETCH PUTS IN PTR TO MONITOR

BATSIZ	= . - LOADPT		;SIZE OF HANDLER FOR LOAD

. = LOADPT + 5000 

BATEND=.
; BATCH STACK GOES HERE
	.WORD	-1
	.REPT	376
	.WORD	0
	.ENDR
	.END
                                                                                                                                                                           