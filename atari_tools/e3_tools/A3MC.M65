;6-JAN-78
;9:00:00
	.TITLE A3MC.MAC TAPE CONTROLLER
	.NLIST BYT
	.LIST MEB
	.ENABL AMA
	.MACLIB	DMSSML
			;MY (D.M.S.) SYSTEM MACROS FOR THE 6502 ARE FOUND
			;IN THE FILE 'DMSSML.M65'
	.ASECT
	.RADIX 16
;
;NOTE: LOC 00:7F IS 128 BYTE BUFFER AREA
	.=80
CHKSUM:	.BLKB 1		;CHECKSUM
INDEX:	.BLKB 1
STAT:	.BLKB 1
R0:	.BLKB 1
R1:	.BLKB 1
R2:	.BLKB 1
R3:	.BLKB 1
R4:	.BLKB 1
R5:	.BLKB 1
R6:	.BLKB 1
R7:	.BLKB 1
	.=7C00
F.ERR	=1		;ANY I/O ERROR
F.EOF	=2		;EOF FLAG
F.TAG	=4		;DATA READY FLAG
T.WRT	=8		;TAPE DRIVE R/W CONTROL
T.RWND	=10		;TAPE F/R CONTROL
F.RWRQ	=0800		;READ/WRITE REQUEST FLAG (D7)
F.HRUN	=0801		;RUN/STOP REQUEST FLAG (D7)
F.HREW	=0802		;REWIND REQUEST FLAG (D7)
F.HSTB	=0803		;DATA READY/ACK FLAG (D7)
T.RDY	=0804		;TAPE READY STATUS (D7)
T.WBE	=0805		;TAPE WRITE BUFFER EMPTY (D7)
T.IRG	=0806		;TAPE INTER-RECORD GAP (D7)
T.ICC	=0807		;TAPE INCOMPLETE CHARACTER (D7)
T.RBF	=1000		;TAPE READ BUFFER FULL (D7)
T.BOT	=1001		;BEGINNING OF TAPE (D7)
O.DIO	=1002		;OPTION-DIO CONNECTION
O.NOER	=1003		;OPTION NO ERROR CHK
O.DVLP  =1004		;DEVELOPMENT SYS CONNECT
O.ERSE	=1007		;ERASE WHOLE TAPE
INTFI	=1800		;INTERFACE INPUT
CNTRLS	=2000		;TAPE CONTROLS AND INTERFACE OUTBOUND TAGS
INTFO	=2800		;INTERFACE OUTPUT
T.RUN	=3000		;TAPE START COMMAND (ANY I/O REFERENCE)
T.LDWB	=3800		;TRANSFER BYTE TO TAPE DRIVE (WRITE ONLY)
T.STOP	=4000		;TAPE STOP COMMAND (ANY I/O REFERENCE)
T.RDTA	=4800		;READ BYTE FROM TAPE DRIVE (READ ONLY)
T.RST	=5000		;TAPE DRIVE RESET (ANY I/O REFERENCE)
	.PAGE
	.SBTTL MACRO STUFF
	.MCALL .ALL
	.ALL
	.MACRO MVI OP1,OP2
	LDA I,OP2&255.
	STA OP1
	LDA I,OP2&-256./256.
	STA OP1+1
	.ENDM

	GENJSR RDBYT
	GENJSR WRTBYT
	GENJSR REWIND
	GENJSR RDBLK
	GENJSR WRTBLK
	GENJSR STOP
	GENJSR CLRBUF

	.MACRO WAIT DLY
	LDX I,DLY
	JSR TIME
	.ENDM
;DBUG	=0
	.PAGE
	.SBTTL ENTRY

ENTRY:	SEI
	CLD
	LDS <I,0FF>
	CLRBUF		;GO CLR BUFFER

BEGIN:	REWIND
	BIT A,O.ERSE	;ERASE REQUEST?
	BMI 1$		;NO
	LDA I,T.WRT	;WRITE
	STA A,CNTRLS
	STA A,T.RUN	;GO
2$:	BIT A,T.RDY	;WAIT FOR RDY TO DROP
	BPL 2$
	STOP
	CLR <<A,CNTRLS>>
7$:	JMP DVLP	;GO SEE IF DEVELOPMENT SYS
1$:	BIT A,O.DIO	;DATA I/O CONNECT?
	BMI 7$  	;NO
3$:	BIT A,F.RWRQ	;WAIT FOR START BUTTON
	BMI 3$
	WAIT 50.	;WAIT 50 MS
	BIT A,F.RWRQ	;STILL BOUNCING
	BMI 3$
	MOVB R0,<A,INTFI>	;GET CONFIG SWITCH (D7,D6)
	MOVB <A,CNTRLS>,<I,2>	;GET SIZE (D6,D5,D4) AND SECTOR (D3,D2,D1,D0)
	MOVB R1,<A,INTFI>
10$:	BIT A,F.RWRQ
	BPL 10$
	WAIT 100.
	LDA R1
	LSRS 4
	AND I,7
	TAX
	CLR R3
	MOVB R2,<I,10>	;MINIMUM SIZE =32
4$:	ASL R2		;COMPUTE THE SIZE
	ROL R3
	DEX
	BPL 4$
	CLR <R6,R7>	;COMPUTE STARTING POSITION
	LDA R1
	AND I,0F
	TAX		;SECTOR#
6$:	DEX
	BMI 5$
	ADDM R6,R2	;MULTIPLY SECTOR # TIMES SIZE
	BCC 6$
5$:	RDBLK		;PROCEED
	SUBMI R6,128.
	BCS 5$
	LDA R6
	AND I,7F
	TAX		;INITIAL INDEX
9$:	BIT A,F.HRUN	;DONE?
	BPL JE		;YEP
	BIT A,F.HSTB	;OK TO SEND?
	BMI 9$		;NO. WAIT
	LDA ZX,0	;GET DATA
	BIT R0		;CONFIG?
	BMI 11$		;X8 OR X4 LSB
	LSRS 4		;X4 MSB
11$:	BVS 12$		;X8 OR X4 MSB
	AND I,0F	;X4 LSB
12$:	STA A,INTFO	;SEND DATA
	LDY I,20.	;WAIT 100 MICROSECS
	DEY
	BPL .-1
	MOVB <A,CNTRLS>,<I,F.TAG>	;STROBE IT
	LDY I,20.	;WAIT 100 MICRO SECS.
	DEY
	BPL .-1
	CLR <<A,CNTRLS>>
	INX
	BPL 9$
	RDBLK
	LDX I,0
	BEQ 9$		;LOOP
JE:	JMP ENTRY	;RESET
DVLP:	BIT A,O.DVLP	;DEVELOPMENT SYSTEM?
	BMI MAIN	;NO
	CLR <R6,R7,<A,INTFO>,<A,CNTRLS>>
	CLI
1$:	NOP		;SHIFT TO INTERRUPT MODE
	NOP
	NOP
	JMP 1$
DVLIRQ:	BIT R6		;INTERRUPT ENTRY
	BMI 1$		;ALREADY GIVEN LEADER
	INC R7
	LDA R7
	CMP I,4		;3 BYTES OF LEADER
	BPL 2$
3$:	BIT A,F.HSTB	;FLAG DROPPED YET?
	BPL 3$		;NO
	RTI		;YEP, EXIT
2$:	DEC R6		;FLAG LEADER DONE
4$:	MOVB <A,CNTRLS>,<I,F.TAG>	;DROP SPROCKET
	STA STAT	;SAVE STATUS FOR RE-TRY ROUTINE
	RDBLK		;GO FILL BUFFER
	LDX I,0FF
1$:	INX
	BMI 4$		;BUFFER EMPTY
	MOVB <A,INTFO>,<ZX,0>	;SEND DATA
	CLR <<A,CNTRLS>>	;RAISE SPROCKET
	JMP 3$		;EXIT
	.PAGE
	.SBTTL MAIN LOOP
MAIN:	BIT A,F.HREW	;REWIND REQUEST
	BMI 1$		;NO
	WAIT 10.	;YES. WAIT 10 MS
	BIT A,F.HREW	;TEST AGAIN
	BMI MAIN	;NO. KEEP LOOKING.
	LDA I,F.TAG
	STA A,CNTRLS	;SIGNAL REWIND ACKNOWLEDGE
2$:	BIT A,F.HREW	;WAIT FOR REW REQUEST TO DROP
	BPL 2$
	CLR <<A,CNTRLS>>  ;DROP ALL TAGS
	BEQ JE  	;RESET
1$:	LDA I,F.ERR
	BIT STAT	;ANY ERRORS?
	BNE MAIN	;YEP. WON'T GO
	BIT A,F.HRUN	;RUN REQUEST?
	BMI MAIN	;NO
	WAIT 1  	;MAYBE
	BIT A,F.HRUN
	BMI MAIN	;NOPE. KEEP LOOKING
	BIT A,T.RDY	;IS THE DRIVE READY?
	BPL 3$		;YES. OK TO PROCEED
	MOVB STAT,<I,F.ERR>	;NO. SIGNAL ERROR
	STA A,CNTRLS	;SEND IT TO OUTSIDE WORLD
	BNE MAIN	;WAIT ONLY FOR REW COMMAND
3$:	BIT A,F.RWRQ	;READ?
	BMI READ	;YEP
	WAIT 1  	;WAIT 1MS
	BIT A,F.RWRQ	;READ?
	BMI MAIN	;SOMETHING IS FLAKEY. TRY AGAIN
	.PAGE
	.SBTTL WRITE/READ LOGIC
WRITE:	BIT A,F.HSTB	;STROBE DOWN?
	BMI 1$		;NOPE. GO GET DATA
	BIT A,F.HRUN	;RUN REQUEST?
	BPL WRITE	;YEP.
3$:	WRTBLK		;NOPE. FLUSH LAST BLOCK
	CLR STAT
	STA A,CNTRLS	;DROP OUT TAGS
	JMP MAIN
1$:	LDA STAT
	ORA I,F.TAG
	STA A,CNTRLS	;RAISE OUTBOUND TAG
4$:	BIT A,F.HSTB	;STROBE DOWN?
	BPL 2$		;YES
	BIT A,F.HRUN	;DONE?
	BMI 3$		;YES
	BPL 4$		;NOPE
2$:	LDX INDEX	;GET INDEX
	MOVB <ZX,0>,<A,INTFI>	;PUT DATA INTO BUFFER
	ADD CHKSUM
	STA CHKSUM	;UPDATE THE CHECKSUM
	MOVB <A,CNTRLS>,STAT	;DROP OUTBOUND TAG
	INC INDEX	;BUFFER FULL?
	BPL WRITE	;NO. PROCEED
	WRTBLK		;YEP. EMPTY IT
	JMP WRITE	;AND PROCEED


READ:	RDBLK		;FILL THE BUFFER
2$:	BIT A,F.HSTB	;STROBE DOWN?
	BMI 1$		;NOPE
	BIT A,F.HRUN	;RUN REQ?
	BPL 2$		;YEP
4$:	CLRBUF		;CLEAR THE BUFFER
	CLR STAT
	STA A,CNTRLS	;DROP TAGS
	JMP MAIN
1$:	LDX INDEX
	MOVB <A,INTFO>,<ZX,0>	;PASS DATA TO USER
	LDA STAT
	ORA I,F.TAG	;RAISE OUTBOUND TAG
	STA A,CNTRLS
5$:	BIT A,F.HSTB	;STROBE DOWN?
	BPL 3$		;YEP
	BIT A,F.HRUN	;DONE?
	BMI 4$
	BPL 5$
3$:	MOVB <A,CNTRLS>,STAT	;DROP OUTBOUND TAG
	INC INDEX	;NEXT BYTE
	BMI READ	;BUFFER EMPTY. FILL IT
	BPL 2$		;ELSE PROCEED
	.PAGE
	.SBTTL TAPE I/O
	.ENABL LSB
RDBLK:	CLR R4		;RETRY COUNT
RLOOP:	CLR R5		;ICC ERRORS
	SEC
	ROR R3		;INDICATE LAST COMMAND NOT REWIND
	CLRBUF		;CLEAR EVERYTHING
	STA A,T.RUN	;START TAPE DRIVE
	LDA A,T.RDTA	;CLEAR ICC
	LDX I,101.	;WAIT 400MS TO SEE IF EOF
5$:	LDY I,235.	;(4MS INNER LOOP)
	DEX
	BEQ 1$
2$:	BIT A,T.RDY	;OFF THE END?
	BMI HERR	;YES
	DEY
	BEQ 5$
	BIT A,T.IRG	;GET OUT OF GAP
	BPL 2$
	LDX I,0		;INDEX TO 0
1$:	RDBYT
	STA ZX,0	;PUT IT IN THE BUFFER
	ADD CHKSUM	;CHECKSUM IT
	STA CHKSUM
	INX
	BPL 1$
	RDBYT		;GET CHECKSUM BYTE
	EOR CHKSUM
	ORA R5
	STA R5		;SAVE ERROR STATUS
	STOP		;STOP THE TAPE
	LDA R5
	BEQ 4$		;WE'RE DONE
	BIT A,O.NOER	;IGNORE ERRORS?
	BPL 4$		;YEP
	LDA I,F.EOF	;END-OF-FILE?
	BIT STAT
	BNE 4$		;YES. IGNORE ERRORS
	LDA I,T.RWND
	ORA STAT
	STA A,CNTRLS	;REWIND 1 RECORD
	STA A,T.RUN
	WAIT 30.
3$:	BIT A,T.IRG	;WAIT FOR IRG
	BMI 3$
	WAIT 2
	STA A,T.STOP	;STOP
	WAIT 60.
	MOVB <A,CNTRLS>,STAT	;DROP REWIND FLAG
	INC R4		;RETRY COUNT
	LDA R4
	CMP I,11.	;DO IT 10 TIMES
	BPL HERR
	JMP RLOOP
HERR:	LDS <I,0FF>	;RESET STACK
	CLRBUF		;RESET BUFFER
	MOVB STAT,<I,F.ERR>
	STA A,CNTRLS	;GIVE UP
	STA A,STOP	;STOP THE DRIVE
	JMP MAIN
4$:	CLR INDEX
	RTS
	.DSABL LSB
RDBYT:	BIT A,T.IRG	;OVERRECORD?
	BMI 2$		;NO
	LDA I,F.EOF
	ORA STAT
	STA STAT	;SIGNAL EOF
	LDA I,0		;YES. FILL WITH ZEROES
	STA A,T.STOP	;STOP THE DRIVE
	RTS		;AND EXIT
2$:	BIT A,T.RBF	;BYTE AVAIL?
	BMI RDBYT	;WAIT FOR BYTE
	BIT A,T.ICC	;ERROR?
	BMI 1$		;NO
	INC R5		;YES. FLAG IT
1$:	LDA A,T.RDTA	;READ BYTE FROM DRIVE
	RTS
WRTBYT:	BIT A,T.WBE
	BMI WRTBYT
	STA A,T.LDWB
	RTS
WRTBLK:	LDA INDEX	;BUFFER EMPTY
	BNE 1$		;NO
	RTS		;YES. DON'T DO ANYTHING
1$:	LDA I,T.WRT
	ORA STAT
	STA A,CNTRLS	;MAKE WRITE MODE
	BIT A,T.RDY	;WRITE PROTECT?
	BPL 2$		;NO
	MOVB <A,CNTRLS>,<I,F.ERR>
	STA STAT
	JMP HERR
2$:	STA A,T.RUN	;START THE TAPE
	WAIT 40.	;(LONG IRG'S)
	BIT R3		;LAST THING A REWIND?
	BMI 5$		;NOPE
	WAIT 235.	;ELSE WAIT SOME MORE
	SEC
	ROR R3		;INDICATE INITIAL GAP SET
5$:	LDX I,0
	MOVB <A,T.LDWB>,<ZX,0>	;WRITE THE FIRST BYTE
4$:	INX		;BUMP INDEX
	BMI 3$		;DONE
	LDA ZX,0	;GET NEXT BYTE
	WRTBYT		;WRITE IT
	BPL 4$		;(ALWAYS)
3$:	LDA CHKSUM
	WRTBYT		;WRITE CHECKSUM
	STOP		;STOP THE TAPE
	CLRBUF		;RESET ALL
	RTS		;EXIT
REWIND:	CLR STAT
	MOVB <A,CNTRLS>,<I,T.RWND>
	STA A,T.RST	;RESET THE DRIVE
	WAIT 50.	;WAIT AWHILE
	BIT A,T.RDY
	BPL 3$
	JMP HERR
3$:	STA A,T.RUN	;BEGIN REWIND
1$:	BIT A,T.BOT	;BOT?
	BMI 1$		;NOPE
	STOP
	WAIT 30.	;EXTRA TIME
	CLR <<A,CNTRLS>>
	STA A,T.RUN	;FORWARD
2$:	BIT A,T.RDY	;TO LOAD POINT
	BMI 2$
	STOP
	LDA A,O.ERSE	;ERASE MODE OR
	AND A,O.DIO	;DID MODE OR
	AND A,O.DVLP	;DEVELOPMENT SYS?
	AND I,80	;JUST FOR COMPAT
	BPL 6$		;YEP. EXIT
	LDA I,F.TAG
	STA A,CNTRLS	;RAISE DATA RDY TAG
4$:	BIT A,F.HSTB	;WAIT FOR STROBE
	BMI 4$
	CLR <<A,CNTRLS>>  ;DROP TAG
5$:	BIT A,F.HSTB	;WAIT FOR STROBE TO DROP
	BPL 5$
6$:	STA R3		;LAST THING A REWIND
	RTS
STOP:	WAIT 5
	STA A,T.STOP
	WAIT 30.
	RTS
CLRBUF:	LDX I,INDEX
1$:	CLR <<ZX,0>>
	DEX
	BNE 1$
	STA 0
	MOVB CHKSUM,<I,0AA>
	RTS

TIME:	LDY I,200.
1$:	DEY
	BNE 1$
	DEX
	BNE TIME
	RTS

	.REPT 7FFC-.
	.BYTE 0
	.ENDR
	.=7FFC
	.WORD ENTRY,DVLIRQ
	.END ENTRY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        