;	14-NOV-77
;	16:50:00

;	LINKER AS MODIFIED 20-NOV-76 BY D.SHEPPERD

	.TITLE	LNKOV4 V04-03 RTLINK  
; RT-11 LINKER
;
; DEC-11-ORLLA-E
;
; MARCH 11, 1974
; EP / ENHANCED BY JG
;
; COPYRIGHT (C) 1974,1975
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE,
; OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE MADE
; AVAILABLE TO ANY OTHER PERSON EXCEPT FOR USE ON SUCH SYSTEM AND TO
; ONE WHO AGREES TO THESE LICENSE TERMS. TITLE TO AND OWNERSHIP OF THE 
; SOFTWARE SHALL AT ALL TIMES REMAIN IN DIGITAL.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE
; OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DIGITAL.
;
	.PAGE
	.SBTTL	SYMBOLIC CONSTANTS


	R0=%0
	R1=%1
	R2=%2
	R3=%3
	R4=%4
	R5=%5
	SP=%6
	PC=%7


	TAB=	11
	LF=	12
	FF=	14
	CR=	15
	SPAC=	40
	PER=	56


	GSD=	1	;OBJECT MODULE CODES
	TXT=	3
	RLD=	4
	MODEND=	6
	LBR=	7	;LIBRARY MODULE CODE
	LBREND= 10	;LIBRARY END CODE

	BYTBLK=	512.	;BYTE BLOCK SIZE
	BEGIN=	40	;DISPS INTO SYS JOB DATA AREA
	JSTACK=	42	;JOB'S INITIAL STACK POINTER
	JSTATS=	44	;JOB STATUS WORD
	USRLOC=	46	;ADDR OF SWAPPING USR
	HIGH=	50	;HIGHEST LOC USED BY USER
	ERRBYT=	52	;MONITOR ERROR INDICATOR
	MONLOW=	54	;ADDR OF RMON LOWER LIMIT


	.CSECT=	2	;LINKER SYMBOL TABLE FLAGS
	.OVR=	4


	$DEFIN=	10	;GSD FLAGS
	$RELOC=	40
; OFFSETS INTO ENTRY POINT TABLE
	EPTALO=	30	;EPT ENTRIES ALLOCATED(BYTES)
	LHEND=	44	;REL END OF LBR HEADER


	;OFFSETS INTO OVERLAY SECTION BLOCK
	LEVPTR=	2	;POINTER TO LEVEL BLOCK
	IDNO=	4	;OVERLAY SECTION ID NUMBER
	BASBLK=	6	;BASE BLOCK OF SECTION ON OUTPUT
	SECLEN=	30	;SECTION LENGTH
	NXSPTR=	32	;POINTER TO NEXT SECTION SAME LEVEL

	LVLN=	-8.	;OFFSETS INTO OVERLAY LEVEL BLOCK
	LVLP=	-6
	SECP=	-4


	OVJOB=	1000	;BIT IN JSTATS WORD TO INDICATE
			;AN OVERLAY JOB


	; USEFUL EMT INSTRUCTIONS
	LKEMT=	EMT+20	;LOOKUP EMT
	SSEMT=	EMT+120	;SAVESTATUS EMT
	WEMT=	EMT+240	;WAIT EMT

	FOURK=20000

	M65=0		;DEFINE FOR CONDITIONAL 6500 ASSEMBLY



	.MCALL	..V1..
	..V1..
	.MCALL	.CSISPC,.CSIGEN,.SETTOP,.LOCK,.UNLOCK
	.MCALL	.FETCH,.LOOKUP,.PRINT,.TTYIN,.WAIT,.ENTER
	.MCALL	.CLOSE,.SRESET,.READW,.WRITW,.WRITE
	.MCALL   .REOPEN,.RCTRLO,.QSET,.DATE


	LDA=	0	;TURN ON LDA FEATURE


	.NLIST	CND
	.SBTTL	MISCELLANEOUS MACRO DEFINITIONS

	.MACRO	ERROR	MSG
	JSR	R0,ERROR
	.ASCIZ	"?'MSG'?"
	.EVEN
	.ENDM

	.MACRO	PRINT	MSG
	JSR	R5,PR00
	.WORD	MSG
	.ENDM

	.MACRO	LERROR	MSG,REG
	.CSECT	CHAR4
	CHARPT=.
	.ASCIZ	"MSG"
	.CSECT	MAIN4
	.IF NB	REG
	MOV	REG,R0
	JSR	R5,LERROR
	.IFF
	JSR	R5,LERROR+2
	.ENDC
	.WORD	CHARPT
	.ENDM

	.MACRO	LERRA	MSG
	.CSECT	CHAR4
	CHARPT=.
	.ASCIZ	"MSG"
	.CSECT	MAIN4
	JSR	R5,LERRA
	.WORD	CHARPT
	.ENDM
	.SBTTL	PASS2 - LIBRARY PROCESING ROUTINE
	.CSECT	MAIN4

	.GLOBL	PASS2,DMP0,DMPA,ONEPT,LIBDIR
	.GLOBL	CSECT,FILPT,SYMM20,EPTSER,CURBLK
	.GLOBL	NEWBUF,ISWIT,BUFSWT,NEWBLK,SKPBLK,FILPT1
	.GLOBL	INIO,PASS,MODCNT,BYTE,TXTBLK,ERROR
	.GLOBL	LERRA,BASE,TEMP,GT1BYT,LERROR,BOTTOM
	.GLOBL	HGHLIM,TXTLEN,LSWIT,PADDR,OBUF,OBLK
	.GLOBL	ODBLK,SEGBAS,SEGBLK,ABWMAP,LDAPTR,CKSUM
	.GLOBL	EOBUF,LOOKUP,CLC,SSWIT,RESLIB
	.GLOBL	LMLSWT,BEGLML,STLML,ENDLML,LMLBLK,HARDER
	.GLOBL	PA2LML,GETLIB,LIBBLK,IBUF1,IBUF2
	.GLOBL	TDMP0					;###


; THIS ROUTINE INSURES THAT THE LINKER,DURING PASS2,
; PROCESSES THE LIBRARY OBJECT MODULES EXACTLY AS THEY
; WERE ENCOUNTERED DURING PASS1.
;
	.ENABL	LSB
LIBPA2:	MOV	#SSWIT,R2
	DECB	ONEPT		;IND LIBRARY I/O
	TSTB	(R2)+		;LIBRARY DIRECTORY AREA EXIST ?
	BNE	LIBPA5		;NO
	TSTB	@R2		;LML ON DISK ?
	BMI	LIBPA8		;YES
LIBPA3:	MOV	BEGLML,R1	;GET PTR TO START OF LML
	MOV	#LIBBLK,R4
	TSTB	SSWIT		;LIB DIR IN CORE ?
	BNE	LIBPA4		;NO - NO BLK OPTIMIZATION
	CMP	@R1,@R4		;REQUESTED MOD IN BUFFER ?
	BEQ	15$
	BLO	LIBPA4		;NO
	MOV	@R1,R0
	DEC	R0
	BEQ	LIBPA4		;MOD IMMEDIATELY FOLLOWS EPT
;				/OF 1 BLK (SPECIAL CONSIDERATION)
	CMP	R0,@R4		;REQUESTED MOD IN NXT BUFFER ?
	BEQ	18$
LIBPA4:	MOV	(R1)+,@R4	;IND MOD BLK ADR
	BMI	LENPA0		;YES - END OF LIBRARY ?
	MOV	(R1)+,R3	;GET BYTE ADR WITHIN BLK
	JSR	PC,GETLIB	;GET THE CORRECT BLK #
7$:	ADD	R3,R4		;PT TO CORRECT BYTE IN BLK
	MOV	R1,BEGLML	;UPDATE LML PTR
	BISB	#100,ISWIT	;IND PROCESSING LIBR FILE
	BR	PA2NXT		; CALL MAIN PROCESSING ROUTINE
15$:	MOV	IBUF1,R4
16$:	TST	(R1)+		;MOD IN BUFFER 1
	MOV	(R1)+,R3
	BR	7$
18$:	MOV	IBUF2,R4	;PT TO 2ND BUFFER
	TST	-(R4)
	BR	16$
	.DSABL	LSB
LIBPA5:	TSTB	@R2		;LML CORE RESIDENT ?
	BPL	LIBPA3		;YES
	MOV	STLML,R1	;PT TO START OF LML
	MOV	#256.,R2
	MOV	LMLBLK,R0
LIBPA6:	.READW	2,R1,R2,R0	;READ LML
	BCC	2$		;ERRORS ?
	JMP	HARDER		;TERMINATE FOR I/O ERROR
2$:	INC	LMLBLK		;IND NEXT BLK
	BR	LIBPA4
LIBPA8:	MOV	LIBDIR,R1	;READ LML OVER LIBR DIR
	MOV	#FOURK,R2	;SPECIFY MAX DIR SIZE
	ROR	R2		;CALC. # OF WORDS
	CLR	R0
	BR	LIBPA6
; ALL THE CSECTS IN THE LIBRARY HAVE BEEN PROCESSED.
; RESET ALL POINTERS, TERMINATE THE LIBRARY FILE
; AND GO BACK TO IN LINE PROCESSING.
LENPA0:	MOV	R1,BEGLML	;UPDATE LML PTR
	CLR	@R4		;RESET LIB BLK # FOR NXT LIBR
	CLRB	ONEPT
	.WAIT	0
	.WAIT	3
	.CLOSE	3		;TERMINATE LIBRARY FILE
	CLRB	ISWIT		;RESET LIB SWITCHES
	BR	PASS2A		;RECALL PASS2
	.SBTTL	PASS2 - PRODUCE SAVE IMAGE FILE

PASS2:	MOV	FILPT1,R0	;RESET FILE POINTER
	MOV	PA2LML,BEGLML	;INIT FOR LIBRARY PROCESSING
	CLR	LMLBLK
	JSR	PC,INIO		;INIT I/O
	MOVB	#2,PASS		;SET PASS SWITCH
	BR	PA2NXT
PASS2A:	JSR	PC,NEWBUF
	JSR	PC,NEWBUF	;READ NXT FILE
	BR	PA2NXT
PA2SKP:	JSR	PC,SKPBLK
PA2NXT:	JSR	PC,NEWBLK	;ENTER MAIN PASS2 LOOP HERE
	CMP	R0,#LBR		;PROCESSING A LIBR. ?
	BNE	1$
	JMP	LIBPA2
1$:	CMP	R0,#TXT
	BNE	5$
	JMP	DMPTXT
5$:	CMP	R0,#RLD
	BEQ	PA2RLD
	CMP	R0,#MODEND	;END OF THIS OBJ MOD?
	BNE	PA2SKP		;NO
	INC	MODCNT
	BITB	#100,ISWIT	;LIBR PROCESSING ?
	BEQ	PA2SKP
	CLRB	ONEPT
	BR	LIBPA2
	.SBTTL	PROCESS RLD'S

PA2RLD:	JSR	PC,BYTE		;GET 1ST BYTE OF RLD
	CLR	-(SP)
	MOVB	R0,@SP		;STORE THE COMMAND BYTE
	JSR	PC,BYTE
	CLR	R1
	BISB	R0,R1		;GET RELATIVE REFERENCE IN R1
	MOV	R1,R3
	ADD	#TXTBLK-2,R1	;LOC OF TARGET IN TXTBLK
	BIT	#1,TXTBLK	;IS TXT BLK ON ODD BOUNDARY?	;###
	BEQ	1$		;IF EQ-NO			;###
	INC	R1		;YES-INCR RELATIVE REFERENCE,	;###
				;SINCE BLK WAS SHIFTED BY A	;###
				;BYTE AT LOC. DMPTXT.		;###
1$:	ADD	TXTBLK,R3	;PROG ADDR OF TARGET		;###
	MOV	R3,R0
	SUB	#4,R0		;COMPUTE ABSOLUTE ADDRESS FOR PRINTING
	MOV	R0,(PC)+
PGMTGT:	.WORD	0		;PROGRAM LOCATION OF BYTE (USED IF REL. ERROR)
	SUB	#2,R3		;CURRENT LOC+2 (YES, SUBTRACT)
	NEG	R3		;MINUS CURR LOC + 2
	SUB	#2,R2		;SUBTRACT FROM LEN OF RLD BLK
	MOV	@SP,R0		;GET COMMAND BYTE
	CLR	M6800		;RESET M6800 MODE
	ASLB	R0		;DOUBLE AND CHECK M6800 FLAG
	BPL	2$		;NORMAL FETCH
	MOV	SP,M6800	;SET 6800 MODE
	BIC	#200,R0		;RESET M6800 MODE
2$:	CMP	R0,#RLDTBE-RLDTBL
	BHI	RLDERR		;ERROR: INVALID RLD COMMAND
	MOV	RLDTBL(R0),PC
	.CSECT	DPUR4
RLDTBL:	.WORD	RLDERR
	.WORD	RLDIR		;INTERNAL RELOCATION
	.WORD	RLDGR		;GLOBAL RELOCATION
	.WORD	RLDIDR		;INTERNAL DISPLACED RELOCATION
	.WORD	RLDGDR		;GLOBAL DISPLACED RELOCATION
	.WORD	RLDGAR		;GLOBAL ADDITIVE RELOCATION
	.WORD	RLDGAD		;GLOBAL ADDITIVE DISPLACED REL
	.WORD	RLDLCD		;LOCATION COUNTER DEFINITION
	.WORD	RLDLCM		;LOCATION COUNTER MODIFICATION
	.WORD	RLDSPL		;SET PROGRAM LIMITS
	.WORD	RLDGR
	.WORD	RLDERR
	.WORD	RLDGDR
	.WORD	RLDGAR
RLDTBE:	.WORD	RLDGAD
M6800:	.WORD	0

	.CSECT	MAIN4
RLDERR:	ERROR	<BAD RLD>
RLDGR:	CLR	R3
RLDGDR:	JSR	PC,RLDLK
	BR	RLDST
RLDGAR:	CLR	R3
RLDGAD:	JSR	PC,RLDLK
	BR	RLDIDR
RLDIR:	MOV	BASE,R3		;ADD SECTION BASE
RLDIDR:	MOV	R3,-(SP)
	JSR	PC,GETDIS	;GET GLOBAL DISP
RLDID0:	ADD	(SP)+,R3
	SUB	#2,R2		;SUB FROM LENGTH OF BLOCK
	.ENABL	LSB
RLDST:	TSTB	(SP)+		;TEST IF BYTE COMMAND
	BPL	1$		;NO, GO STORE WORD
	MOVB	R3,@R1		;STORE BYTE
	BIT	R3,#177400	;FITS IN 8 BITS?
	BEQ	RLDNXT		;YES
	MOV	#177600,R0	;TEST IF MINUS
	BIC	R3,R0
	BEQ	RLDNXT		;YES, OKAY
	LERROR	<BYTE RELOCATION ERROR AT>,PGMTGT
	BR	RLDNXT
1$:	TST	M6800
	BEQ	15$
	SWAB	R3
	MOVB	R3,(R1)+	;STORE HIGH BYTE
	SWAB	R3
	MOVB	R3,(R1)+	;STORE LOW BYTE
	BR	RLDNXT
15$:	MOVB	R3,(R1)+	;STORE LOW BYTE
	SWAB	R3
	MOVB	R3,(R1)+	;STORE HIGH BYTE
RLDNXT:	TST	R2
	BGT	PA2RLD
	BNE	RLDERR		;CAN'T HAPPEN *************************
	JSR	PC,BYTE
JPA2NX:	JMP	PA2NXT						;###
	.DSABL	LSB
RLDLCD:	CLR	R3
	JSR	PC,RLDLK	;LOOKUP CSECT NAME
	MOV	R3,BASE		;SET UP NEW CSECT BASE
RLD2:	MOV	#CLC,R1		;WILL STORE RESULT INTO CLC
	BR	RLDIDR
RLDLCM:	MOV	BASE,R3		;LOCATION COUNTER MODIFICATION
	BR	RLD2
RLDSPL:	TST	M6800		;BACKWARDS?
	BEQ	1$		;NO
	SWAB	BOTTOM
	SWAB	HGHLIM
1$:	MOVB	BOTTOM,(R1)+	;SET PROGRAM LIMITS
	MOVB	BOTTOM+1,(R1)+	;ONLY BYTES AT A TIME
	MOVB	HGHLIM,(R1)+
	MOVB	HGHLIM+1,(R1)
	TST	M6800		;BACKWARDS?
	BEQ	2$		;NOPE
	SWAB	BOTTOM
	SWAB	HGHLIM
2$:	BR	RLDNXT


GETDIS:
	MOV	#TEMP,R3	;ADDRESS OF WORK SPACE
	JSR	PC,GT1BYT		;GO GET DATA BYTE
	JSR	PC,GT1BYT		;GO GET NEXT DATA BYTE
	MOV	-(R3),R3		;LOAD RELOCATABLE ADDRESS INTO R3
	TST	M6800
	BEQ	36$
	SWAB	R3
36$:	RTS	PC
	.SBTTL	WRITE TEXT TO OUTPUT FILE
;
; MODIFIED  BY BC TO HANDLE TXT BLKS WHICH ARE ON AN ODD BOUNDARY.
; IF SUCH A BLK IS FOUND, THE DATA BYTES (BUT NOT THE ADDRESS!)
; ARE SHIFTED DOWN IN MEMORY (HIGHER) BY ONE BYTE WHEN THE BLOCK
; IS FIRST READ IN, AND SHIFTED BACK UP WHEN THE BLOCK IS OUTPUT.
; OTHER AREAS AFFECTED BY THIS FIX ARE  LOC PA2RLD IN LNKOV4.
;					LOC PA2RLD IN LNKOV5
;					LOC DMPTXT IN LNKOV5
;					LOC NBF2   IN LINK0
;					LOC TDMP0  IN LINK0
;


DMPTXT:	MOV	R2,-(SP)	;SAVE LENGTH OF NEW BLOCK
7$:	JSR	PC,TDMP0	;GET RID OF OLD BLOCK		;###
	MOV	(SP)+,R2	;GET LEN OF NEW BLK
	MOV	R2,TXTLEN	;AND ESTABLISH AS CURRENT
	MOV	#TXTBLK,R3
	MOV	R3,R1		;COPY ADDR OF TXTBLK		;###
2$:	CMP	R4,R5		;CHECK IF ANY MORE BYTES TO MOVE
	BLO	3$
	JSR	PC,NEWBUF	;READ A NEW INPUT BUFFER LOAD
3$:	MOVB	(R4)+,(R3)+	;MOVE TXT BLOCK INCLUDING CKSUM
	DEC	R2
	BGE	2$
	ADD	BASE,(R1)	;ADD BASE TO GIVE ABS LOAD ADDR	;###
	BIT	#1,(R1)+	;IS PROG ADDR OF TXTBLK ODD?	;###
	BEQ	5$		;IF EQ-NO			;###
4$:	MOVB	-(R3),1(R3)	;YES-MOVE BLK DOWN IN MEMORY(HIGHER);###
	CMP	R3,R1		;DONE WHOLE BLOCK?		;###
	BNE	4$		;IF NE-NO			;###
5$:	BR	JPA2NX		;YES-GO ON			;###
	.SBTTL	RLD SYMBOL LOOKUP ROUTINE

; SUBROUTINE TO LOOK UP THE SYMBOL IN THE CURRENT RLD ITEM,
; AND ADD ITS VALUE TO R3.
RLDLK:	MOV	R3,-(SP)	;SAVE CURRENT R3
	MOV	#TEMP,R3
1$:	CMP	R4,R5
	BLO	2$
	JSR	PC,NEWBUF
2$:	MOVB	(R4)+,(R3)+	;GET 4 BYTES OF SYMBOL NAME
	CMP	R3,#TEMP+4
	BLO	1$
	MOV	#TEMP,R3
	JSR	PC,LOOKUP
	TST	@R0		;SYMBOL MUST HAVE BEEN DEFINED
	BEQ	3$		;CAN'T HAPPEN************************
	MOV	-(R0),R3	;GET SYMBOL'S VALUE
	ADD	(SP)+,R3	;ADD FORMER R3 VAL
	SUB	#4,R2		;SUBTRACT FROM LENGTH OF BLOCK
	RTS	PC
3$:	JMP	RLDERR		;BAD RLD
	.END	
                                                                                                                                             