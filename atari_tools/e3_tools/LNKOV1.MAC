	.TITLE	LNKOV1 V04-03 RTLINK START & INITIALIZATION LOGIC  
; RT-11 LINKER
;
; DEC-11-ORLLA-E
;
; MAY 16,1974
;
; EP/ ENHANCED BY JG
;
; COPYRIGHT (C) 1974,1975
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE,
; OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE MADE
; AVAILABLE TO ANY OTHER PERSON EXCEPT FOR USE ON SUCH SYSTEM AND TO
; ONE WHO AGREES TO THESE LICENSE TERMS. TITLE TO AND OWNERSHIP OF THE 
; SOFTWARE SHALL AT ALL TIMES REMAIN IN DIGITAL.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE
; OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DIGITAL.

	.PAGE
	.SBTTL	SYMBOLIC CONSTANTS


	R0=%0
	R1=%1
	R2=%2
	R3=%3
	R4=%4
	R5=%5
	SP=%6
	PC=%7


	TAB=	11
	LF=	12
	FF=	14
	CR=	15
	SPAC=	40
	PER=	56


	GSD=	1	;OBJECT MODULE CODES
	TXT=	3
	RLD=	4
	MODEND=	6
	LBR=	7	;LIBRARY MODULE CODE
	LBREND= 10	;LIBRARY END CODE

	BYTBLK=	512.	;BYTE BLOCK SIZE
	BEGIN=	40	;DISPS INTO SYS JOB DATA AREA
	JSTACK=	42	;JOB'S INITIAL STACK POINTER
	JSTATS=	44	;JOB STATUS WORD
	USRLOC=	46	;ADDR OF SWAPPING USR
	HIGH=	50	;HIGHEST LOC USED BY USER
	ERRBYT=	52	;MONITOR ERROR INDICATOR
	MONLOW=	54	;ADDR OF RMON LOWER LIMIT
	RSIZE=	52	;ROOT SIZE OF PGM
	OVSIZE=	54	;SUMS OF THE LARGEST OVERLAY REGIONS
	RELID=	56	;F/B IDENTIFIER ADR
	RELBLK=	60	;ADR OF REL BLK (BLOCK #)
	MONCOM=	356	;OFFSET TO BATCH COMMUNICATION BYTE


	.CSECT=	2	;LINKER SYMBOL TABLE FLAGS
	.OVR=	4


	$DEFIN=	10	;GSD FLAGS
	$RELOC=	40
; OFFSETS INTO ENTRY POINT TABLE
	EPTALO=	30	;EPT ENTRIES ALLOCATED(BYTES)
	LHEND=	44	;REL END OF LBR HEADER


	;OFFSETS INTO OVERLAY SECTION BLOCK
	LEVPTR=	2	;POINTER TO LEVEL BLOCK
	IDNO=	4	;OVERLAY SECTION ID NUMBER
	BASBLK=	6	;BASE BLOCK OF SECTION ON OUTPUT
	SECLEN=	30	;SECTION LENGTH
	NXSPTR=	32	;POINTER TO NEXT SECTION SAME LEVEL

	LVLN=	-8.	;OFFSETS INTO OVERLAY LEVEL BLOCK
	LVLP=	-6
	SECP=	-4


	OVJOB=	1000	;BIT IN JSTATS WORD TO INDICATE
			;AN OVERLAY JOB


	; USEFUL EMT INSTRUCTIONS
	LKEMT=	EMT+20	;LOOKUP EMT
	SSEMT=	EMT+120	;SAVESTATUS EMT
	WEMT=	EMT+240	;WAIT EMT


	SEVENK=	20700		;MIN CORE NEEDED TO START LINKER
	ELEVNK=	40700		;CORE NEEDED TO MAKE FORLIB DIRECTORY
;				/RESIDENT (JUST UNDER 11 K)
	FOURK=	20000		;MAX SIZE OF FORLIB DIRECTORY
	LMLMAX=	4000		;MAX SIZE OF LIBRARY MOD LIST


	.MCALL	..V1..
	..V1..
	.MCALL	.CSISPC,.CSIGEN,.SETTOP,.LOCK,.UNLOCK
	.MCALL	.FETCH,.LOOKUP,.PRINT,.TTYIN,.WAIT,.ENTER
	.MCALL	.CLOSE,.SRESET,.READW,.WRITW,.WRITE
	.MCALL   .REOPEN,.RCTRLO,.QSET,.DATE,.EXIT,.TTYOUT
	.MCALL	.HERR,.SERR,.TRPSET


	LDA=	0	;TURN ON LDA FEATURE
;	FB=	0	;TURN ON FB


	.NLIST	BEX
	.NLIST	CND
	.PAGE
	.SBTTL	MISCELLANEOUS MACRO DEFINITIONS

	.MACRO	ERROR	MSG
	JSR	R0,ERROR
	.ASCIZ	"?'MSG'?"
	.EVEN
	.ENDM

	.MACRO	PRINT	MSG
	JSR	R5,PR00
	.WORD	MSG
	.ENDM

	.MACRO	LERROR	MSG,REG
	.CSECT	CHAR1
	CHARPT=.
	.ASCIZ	"MSG"
	.CSECT	MAIN1
	.IF NB	REG
	MOV	REG,R0
	JSR	R5,LERROR
	.IFF
	JSR	R5,LERROR+2
	.ENDC
	.WORD	CHARPT
	.ENDM

	.MACRO	LERRA	MSG
	.CSECT	CHAR1
	CHARPT=.
	.ASCIZ	"MSG"
	.CSECT	MAIN1
	JSR	R5,LERRA
	.WORD	CHARPT
	.ENDM
	.SBTTL	START & INITIALIZATION MESSAGES

	.CSECT	CHAR1

ABS:	.RAD50	/. ABS./
IMSG:	.ASCIZ	<CR><LF><LF>/LIBRARY SEARCH: /
	.EVEN
OIGN:	.ASCIZ	"/O IGNORED"
BSWI:	.ASCII	"BAD "
BSWIC:	.ASCIZ	"  SWITCH IGNORED"
	.SBTTL	SYMBOL TABLE INITIALIZATION
; ENTER WITH R3 POINTING TO FIRST LOCATION OF AVAILABLE SPACE
	.CSECT	MAIN1

	.GLOBL	INIT,START1,BSWIT,BEGLML,CSIPT
	.GLOBL	STLEN,SYMEND,STSIZE,STINCR,STDIV,SYMM12
	.GLOBL	SYMM6,SYMM20,SYMM22,LOOKUP,ASECT
	.GLOBL	BEGBLK,ENDOL,ISWIT,TEMP,RPACK
	.GLOBL	FILPT1,STK,IMPURE,IMPURT,BEGBLK,LERROR
	.GLOBL	BWMAP,ABWMAP,DOLB,DOSB,BOTTOM,ODBLK
	.GLOBL	DEFEXT,ERROR,CRLF,TAM,CSWIT,ASWIT
	.GLOBL	SEGBLK,NXTBLK,OBLK,LSWIT,LDAEXT
	.GLOBL	SECNUM
	.GLOBL	OBUF,LDAPTR,MDBLK,LIMIT,INIO,OVSPTR
	.GLOBL	PASS1,SSWIT,LIBDIR,LERRA,DIREND,IBUF1
	.GLOBL	STKBLK,STLML,LMLSWT,PA2LML,EIBUF1,EIBUF2
	.IF DF FB
	.GLOBL	RSWIT,RELEXT,RELID1,OVLNUM
	.ENDC
	.GLOBL	BSECT,CSISZE,LINBUF,MAPBUF,EMAPBU,MAPBLK

INIT:	ADD	#5,R3		;ROUND R3 TO NEXT MULT OF 8
	BIC	#7,R3
	ADD	#2,R3		;PLUS TWO
	MOV	@#MONLOW,R0	;LOW LIMIT OF MONITOR
	MOV	R0,R1
	MOV	266(R0),R0	;PT TO USR
	BIT	#1000,300(R1)	;SET USR NOSWAP ?
	BNE	20$		;YES - DON'T INCLUDE USR AREA
	ADD	#7776,R0	;PT TO TOP OF USR
20$:	BIC	#7,R0		;NEXT MULT OF 8
	ADD	#2,R0		;PLUS TWO
8$:	CMP	R3,R0
	BLO	9$
	JMP	NOCORE
9$:	MOV	R0,R1
	SUB	R3,R1
	BPL	1$		;LIMIT SIZE OF SYMBOL TABLE TO 
	MOV	#77760,R1	;16K WORDS
	MOV	R3,R0
	ADD	R1,R0
1$:	SUB	#10,R1
	BIT	#10,R1		;MUST BE AN ODD NUMBER OF ENTRIES
	BNE	2$
	SUB	#10,R0
	BR	8$
2$:	MOV	R1,STLEN	;TABLE LENGTH IN BYTES
	.SETTOP	R0		;SET TO TOP OF FREE CORE
	MOV	R0,SYMEND	;ADR OF 1ST FREE LOCATION AFTER TABLE
	MOV	R1,R0
	ASR	R1
	ASR	R1
	ASR	R1
	MOV	R1,STSIZE	;SYMBOL TABLE SIZE  (# OF ENTRIES)
	MOV	#40000,R1
3$:	CMP	R1,R0
	BLOS	4$
	ASR	R1
	BR	3$
4$:	ASR	R1
	ASR	R1
	CMP	R1,#8.		;MAKE SURE INCR IS AT LEAST 8
	BHIS	5$
	MOV	#8.,R1
5$:	SUB	#2,R1
	MOV	R1,STINCR	;SYMBOL TABLE INCREMENT =
				;GREATEST POWER OF 2 <= STLEN/4
6$:	ASL	R0
	BPL	6$
	MOV	R0,STDIV	;TO USE FOR DIVISIONS IN LOOKUP
;NOW SET UP HEADCELL OF UNDEFINED SYMBOLS, ETC...
	CLR	(R3)+
	CLR	(R3)+
	MOV	R3,R0
	MOV	R3,SYMM12	;SAVE FOR LATER
	ADD	#2,R0
	MOV	R0,(R3)+	;POINT HEADCELL TO
	MOV	#177767,(R3)+	;ITSELF TO START
	MOV	R3,SYMM6
	MOV	R3,R0
	SUB	#12,R3
	MOV	R3,SYMM20
	SUB	#2,R3
	MOV	R3,SYMM22
	MOV	SYMEND,R1
7$:	CLR	(R0)+		;SET SYMBOL TABLE TO ZEROS
	CMP	R0,R1
	BLO	7$
	MOV	#ABS,R3		;ENTER THE ASECT INTO TABLE
	JSR	PC,LOOKUP
	MOV	R0,ASECT	;AND SET UP POINTERS TO IT
	MOV	#.CSECT,@R0	;SET CSECT BIT IN ASECT
	MOV	#1,BEGBLK	;MODCNT OF ASECT
	MOV	R0,ENDOL
; /I SWITCH MODIFICATIONS START HERE
	TSTB	ISWIT		;INCLUDE GLOBALS ?
	BEQ	NGLOB1		;NO-BRANCH
; REQUEST THE USER TO ENTER THE GLOBALS TO BE SEARCHED
; FROM THE LIBRARY
	.PRINT	#IMSG		;REQUEST USER SPECIFICATION
	MOV	#TEMP,R4	;IND INPUT PTR TO RPACK RTN
15$:	MOV	R4,R3		;SAVE INPUT PTR
	CLR	(R4)+		;INITIALIZE GLOBAL INPUT AREA
	CLR	@R4
	MOV	R3,R4
	MOV	#6,R5		;INDICATE MAX # OF CHARS
	JSR	PC,RPACK	;GET USER INPUT
	MOV	R3,R4		;RESTORE INPUT PTR
	TST	@R4		;MORE GLOBAL INPUT ?
	BEQ	NGLOB1		;NO BRANCH
; THE FOLLOWING CODE CREATES A SYMBOL TABLE ENTRY IN THE
; UNDEFINED SYMBOL TABLE LIST. (THE USE HAS SPECIFIED
; THE CSECT NAMES THAT ARE PLACED IN THE UNDEFINED
; SYMBOL TABLE)
	JSR	PC,LOOKUP	;PUT UNDEF IN SYM. TAB.
	MOV	SYMM12,R1	;GET SYMMTAB-12 PTR
	MOV	@R1,-(SP)	;SAVE PTR TO HEAD OF LIST
	MOV	R0,@R1		;ADR OF SYM TAB IN UNDEF LIST
	MOV	#177767,@R0	;POINT TO LIST HEAD
	MOV	R0,R1
	SUB	SYMM20,R1	;CREATE NEXT ENTRY ADR
	COM	R1		;IND UNDEFINED SYMBOL
	MOV	(SP)+,-(R0)	;IND BKWD PTR TO HEAD UNDEF LIST
	MOV	R1,@(R0)+	;UNDEF ADR IN WRD 6 OF SYM. ENTRY
	BR	15$		;LOOK FOR MORE GLOBALS TO LNK
; END OF /I SWITCH MODIFICATIONS

NGLOB1:	JMP	PASS1		;CALL PASS1 OVERLAY
	.SBTTL  PROGRAM START

START1:	CLR	(PC)+		;RESET INDIRECT COMMAND MODE
INDFLG:	.WORD	0
	CLR	EFFNAM		;RESET INDIRECT POINTER
START2:	MOV	#STK,SP		;RESET THE STACK
	MOV	#IMPURE,R1	;ADDR OF IMPURE AREA TO BE CLEARED
	MOV	#IMPURT,R2	;END OF AREA
20$:	CLR	(R1)+
	CMP	R1,R2
	BLO	20$
	BIS	#20000,@#JSTATS	;MARK LINKER RESTARTABLE
	MOV	#DOSB,OVSPTR
	MOV	#1,BEGBLK
	MOV	ABS,BEGBLK+2
	MOV	ABS+2,BEGBLK+4
	MOV	#1,BEGBLK+8.	;INITIAL TRANSFER ADDRESS
	MOV	#BWMAP,ABWMAP	;POINTER TO BIT MAP
	MOV	#DOLB,DOSB+LEVPTR
	MOV	#DOSB,DOLB+SECP
	MOV	#1000,BOTTOM	;INITIAL BOTTOM ADDRESS
	.SETTOP	#SEVENK
	MOV	@#MONLOW,R0	;GET LOW LIMIT OF MONITOR
	CMP	266(R0),#SEVENK		;UNLOCK USR ?
	BHI	CSI1		;THERE'S ROOM
	JMP	NOCORE		;AUGHHH!!! THERE'S NO ROOM
;
;	MOD ADDED 8/77 BY D.SHEPPERD
;
CSI1:	MOV	INDFLG,R2	;GET INDIRECT BUFFER POINTER
	BEQ	CSI4		;NOT INDIRECT MODE
	JSR	PC,CSI5		;PROCESS INPUT
	BR	CSI6

CSI5:	MOV	R2,R3		;START HERE
2$:	CMPB	#CR,(R2)	;END?
	BEQ	1$		;YES
	CMPB	#32,(R2)+	;CNTRL Z?
	BHIS	CSI3		;END
	CMP	R2,#CSISZE	;BUFFER EMPTY?
	BLO	2$		;NO
	BR	CSI3		;YES ERROR
1$:	CLRB	(R2)+		;ZAP THE CR
	CMPB	#LF,(R2)+	;MAKE SURE LF IS NEXT
	BNE	CSI3		;ERROR
	MOV	R2,INDFLG	;SAVE POINTER
	MOV	#ODBLK,R1	;INIT R1
	RTS	PC


CSI4:	MOV	#CSIPT,R1	;SET POINTER
	JSR	PC,CSI7		;GET STRING FROM TTY
	MOV	#ODBLK,R1
	MOV	@#MONLOW,R0	;GET RMON ADDRESS
	CLRB	MONCOM(R0)	;START WITH NO ERRORS
	MOV	#CSIPT,R3	;POINT TO INPUT STRING
CSI6:	.CSISPC	R1,#DEFEXT,R3	;REQUEST 1ST COMMAND
	BCC	CSI0		;OK
	.CSECT	CHAR1
CHARPT=.
	.ASCIZ	/INVALID COMMAND/
	.CSECT	MAIN1
CSI3:	.PRINT	#CHARPT
	MOV	@#MONLOW,R0	;GET RMON ADDRESS
	MOVB	#200,MONCOM(R0)	;PASS AN ERROR CODE TO BATCH
	BR	START1		;LOOP
;
;	END OF MOD
;

CSI7:	.RCTRLO
	.TTYOUT	#'*		;PROMPT
3$:	.TTYIN		;GET CSI INPUT
	MOVB	R0,(R1)+
	CMP	#CSISZE,R1		;OVERFLOW?
	BLOS	CSI3		;YES.
	CMPB	R0,#LF		;END?
	BNE	3$		;NOPE
	CLRB	-2(R1)		;ERASE CR FROM BUFFER
	MOV	R1,(PC)+	;KEEP POINTER FOR LATER
CSIPTS:	.WORD	0
	MOV	R1,R2		;COPY END ADDRESS TO R2
	RTS	PC
	.PAGE
	.SBTTL	FILE FINDER CODE
CSI0:	.LOCK			;KEEP THE USR FOR AWHILE
	MOVB	#CR,-2(R2)	;RESTORE CR TO ORIGINAL CSI
	MOV	LIMIT+2,R3	;TOP OF ASSEMBLED CODE
	TST	INDFLG		;INDIRECT MODE?
	BNE	SCHEND		;YES. WE CAN SKIP THE FOLLOWING
	MOV	#DVCLST+6,R5	;GET DEVICE NAME ADDRESS
	MOV	#100000,R2
	BIC	R2,-(R5)	;DROP ERROR FLAG FROM NAME
	BIC	R2,-(R5)
	BIC	R2,-(R5)
	.TRPSET	#TA,#TB		;INTERCEPT M-TRAPS
	CLR	R0
	TST	@#176000	;SYKES AVAILABLE?
	.TRPSET	#TA,#0		;NO MORE TRAP INTERCEPTS
	.SERR
2$:	.FETCH	R3,R5		;GET DX FOR A SEC
	MOV	R5,R0
	LKEMT			;LOOK UP A PHONIE NAME
	TSTB	@#ERRBYT	;JUST TO SEE IF IT WORKS
	BPL	1$		; IT DID. AT LEAST IT WAS A SOFT ERROR
	BIS	R2,(R5)		;SIGNAL HARD ERROR
1$:	.SRESET			;RESET ALL
	TST	(R5)+		;SKIP TO NEXT DEVICE
	TST	(R5)		;DONE?
	BPL	2$		;NOPE
	.HERR			;RESTORE HARD ERROR CHECKING
SCHEND:	.QSET	R3,#2		;ADD 2 ITEMS TO I/O QUEUE
	ADD	#2*7*2,R3	;UPDATE FREE CORE POINTER
	TST	@R1		;ANY BINOUT FILE?
	BEQ	11$		;NO
10$:	.FETCH	R3,R1		;FETCH BINOUT HANDLER
	BCS	ERFETC		;ERROR IN FETCH
	MOV	R0,R3		;UPDATE POINTER
11$:	ADD	#10.,R1
	TST	@R1		;ANY MAPOUT?
	BEQ	2$		;NO
1$:	.FETCH	R3,R1
	BCS	ERFETC
	MOV	R0,R3
2$:	ADD	#10.,R1
	TST	@R1		;ANOTHER OUTPUT FILE?
	BEQ	FINDF
TOOMOF:	.UNLOCK
	ERROR	<TOO MANY OUTPUT FILES>

ERFETC:	.UNLOCK
	ERROR	<ERROR IN FETCH>

	.ENABL	LSB
FINDF:	MOV	#3,R5		;INITIAL INPUT CHANNEL
	MOV	R4,-(SP)	;SAVE R4
	MOV	INDFLG,-(SP)	;SAVE INDIRECT POINTER
	CLR	INDFLG		;TO PREVENT LOOPS
	ADD	#2,R1
	CLR	DVCPNT		;START DEVICE SEARCH TABLE AT 0
FND0:	ADD	#8.,R1		;POINT TO NEXT INPUT FILE
	TST	@R1		;ANY FILE
	BEQ	4$		;NO
6$:	.FETCH	R3,R1		;YES, FETCH HANDLER
	BCS	ERFETC
	MOV	R0,R3
	MOV	R1,R0		;BEGIN LOOKUP
	CMP	6(R0),(PC)+
	.RAD50	/LNK/		;INDIRECT TYPE FILE?
	BNE	13$		;NO. PROCEED AS NORMAL
	MOV	CSIPTS,INDFLG	;SET INDIRECT MODE
13$:	MOV	#LKEMT,R4	;LOOKUP EMT
	ADD	R5,R4		;PLUS CHANNEL NUMBER
	MOV	R4,@PC		;AND STORE INTO INSTR STREAM
	EMT	23		;LOOKUP - MODIFIED AT RUNTIME
	BCC	4$
	MOV	DVCPNT,R0
8$:	MOV	DVCLST(R0),(R1)	;PUT NEW DEVICE NAME INTO FILE DESCRIPTOR
	BEQ	7$		;ERROR. FNF
	BPL	9$		;NAME IS OK
	TST	(R0)+		;SKIP IMMEADIATELY
	BR	8$
9$:	TST	(R0)+		;BUMP INDEX
	MOV	R0,DVCPNT	;KEEP UPDATED POINTER
	BR	6$		;TRY AGAIN
7$:	.UNLOCK
	ERROR	<FILE NOT FND>
4$:	CLR	(PC)+		;RESET FILE SEARCH INDEX
DVCPNT:	.WORD	0
	MOV	INDFLG,R4	;INDIRECT MODE?
	BEQ	FND2		;NO
	.UNLOCK
	BIT	#1,R4		;ADDRESS ODD?
	BEQ	16$		;NO
	MOVB	#40,-2(R4)	;PAD IT WITH A SPACE
	MOV	#12*400+15,-1(R4)	;AND CR,LF
	INC	R4		;BUMP IT UP 1
16$:	CLR	-(SP)		;WAIT FOR I/O TO COMPLETE
	MOV	#CSISZE,-(SP)	;COMPUTE BUFFER SIZE
	SUB	R4,(SP)		;BYTE COUNT
	ASR	(SP)		;WORD COUNT
	MOV	R4,-(SP)	;BUFFER LOCATION
	MOV	R4,INDFLG	;IN CASE OF UPDATE
	CLR	R0		;READ BLOCK 0
	ADD	#EMT+200,R5	;COMPUTE .READW R5
	MOV	R5,(PC)		;INSERT INTO JOB STREAM
	EMT	200		;.READW  *** MODIFIED AT RUN TIME
	BCC	15$		;IT WORKED.
	ERROR	<INDIRECT COMMAND FILE INPUT ERROR>
15$:	TSTB	(R4)+
	BNE	15$
	DEC	R4		;BACK UP 1
	.DSABL	LSB
	CMP	R4,#CSISZE-20.	;TOO BIG?
	BHIS	JCSI3		;YEP
	MOV	R4,(PC)+	;KEEP TOP OF INDIRECT FILE
EFFNAM:	.WORD	0
	.SRESET			;RESET ALL
	JMP	START2		;BEGIN AGAIN
JCSI3:	JMP	CSI3
FND2:	INC	R5		;NEXT CHANNEL
	CMP	R5,#8.		;LAST CHANNEL?
	BLOS	FND0
	MOV	(SP)+,INDFLG	;RESTORE INDIRECT POINTER
	JSR	PC,FNUNP	;GO UNPACK SOME FILE NAMES
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R2	;GET SWITCH COUNT FROM CSI
	BMI	1$		;PASS 2 OR MORE. SKIP TO SWPRO
	BNE	SWLOOP		;PROCESS SWITCHES
	JMP	SWEND		;NO SWITCHES
1$:	JMP	SWPRO

DVCLST:	.RAD50	/DK1/		;SEARCH THESE DEVICES FOR THE FILE(S)
	.RAD50	/DX1/
	.RAD50	/DX0/
	.WORD	-1
	.WORD	0		;TERMINATOR

TA:	.WORD	0,TB
TB:	BIS	R2,2(R5)	;ZAP DX LOOKUPS
	BIS	R2,4(R5)
	MOV	SP,R0		;SIGNAL TRAP OCCURED
	RTI

	.GLOBL	DECODE,DCDFLG
	.ENABL	LSB
FNUNP:	MOV	R3,-(SP)	;SAVE THIS
	MOV	#ODBLK+34.,R3	;POINT TO DEVICE
	MOV	EFFNAM,R1	;ASCII STRING GOES HERE
	BNE	1$		;INDIRECT MODE
	MOV	CSIPTS,R1	;ELSE IT GOES TO END OF CSI TEXT
1$:	MOVB	#'(,(R1)	;OPEN BRACKET (INDICATE EFFECTIVE CSI)
19$:	TST	-4(R3)		;ANY FILE?
	BEQ	20$		;NOPE
	CMP	#CSISZE-13.,R1	;IS IT TO FIT?
	BLOS	20$		;NOPE
	INC	R1		;BUMP TO NEXT SPACE
	MOV	SP,DCDFLG	;NO TABS WANTED
	JSR	PC,DECODE
	SUB	#3,R1		;BACK UP
	MOVB	#':,(R1)+	;DEVICE SEPERATOR
	MOV	SP,DCDFLG	;NO TABS
	JSR	PC,DECODE	;UNPACK NAME
	MOVB	#',,(R1)	;FILE SEPERATOR
23$:	CMP	(R3)+,(R3)+	;SKIP TO NEXT FILE
	BR	19$
20$:	MOVB	#'),(R1)+	;CLOSE BRACKET
	MOVB	#CR,(R1)+
	MOVB	#LF,(R1)+
	CLRB	(R1)		;TERMINATE
	MOV	EFFNAM,R2	;PREPARE TO SUPPRESS BLANKS
	BNE	2$		;INDIRECT MODE
	MOV	CSIPTS,R2	;ELSE USE END OF CSI TEXT
2$:	MOV	R2,R1
22$:	MOVB	(R2)+,(R1)
	BEQ	24$		;DONE
	CMPB	#SPAC,(R1)	;SPACE?
	BEQ	22$		;YEP. DON'T USE IT
	INC	R1
	BR	22$
24$:	TST	EFFNAM		;INDIRECT MODE?
	BNE	3$		;YES
	MOV	R1,CSIPTS	;SAVE NEW END OF CSI TEXT
	BR	4$
3$:	MOV	R1,EFFNAM	;KEEP UPDATED POINTER
4$:	MOV	(SP)+,R3	;RESTORE R3
	RTS	PC
	.DSABL	LSB
	.PAGE
; PROCESS 1ST COMMAND STRING SWITCHES
SWLOOP:	CMPB	@SP,#'C		;CONTINUE SWITCH?
	BNE	14$
	INCB	CSWIT
	BR	SWEN1
14$:	CMPB	@SP,#'A		;/A (ALPHABETICAL LISTING)?
	BNE	15$
	INCB	ASWIT
	BR	SWEN1
15$:	.IF DF	LDA
	CMPB	@SP,#'L		;LDA SWITCH?
	BNE	21$
	INCB	LSWIT		;SET FLAG
	CMP	DEFEXT+2,ODBLK+6 ;IS OUTPUT EXTENSION = 'SAV'
	BNE	SWEN1
	MOV	LDAEXT,ODBLK+6	;SUBSTITUTE 'LDA'
	BR	SWEN1
	.ENDC
21$:	CMPB	@SP,#'I		;I SWITCH ?
	BNE	23$		;NO
	INCB	ISWIT		;SET I SWITCH FOUND
	BR	SWEN1
23$:	CMPB	@SP,#'S		;S SWITCH ?
	BNE	24$
	INCB	SSWIT		;IND LIBR DIR NOT RESIDENT
	BR	SWEN1
24$:	CMPB	(SP),#'B	;BOTTOM REQUEST?
	BNE	25$		;NOPE
	TST	(SP)+		;VALUE?
	BPL	BASWT		;NOPE ERROR
	MOV	(SP)+,BOTTOM	;SET THE BOTTOM
	BR	SWEN0
25$:
BASWT:	.UNLOCK
	ERROR	<BAD SWITCH>
SWEN1:	TST	(SP)+		;REMOVE SWITCH
	BPL	SWEN0
	TST	(SP)+		;REMOVE VALUE
SWEN0:	DEC	R2		;COUNT DOWN SWITCHES
	BEQ	SWEND
	JMP	SWLOOP
SWEND:	MOV	#SEVENK,R4	;POINT TO TOP OF 7K
SWPRO:	MOV	#WEMT+3,R1	;GET A WAIT EMT
	MOV	#SSEMT+3,R2	;AND A SAVESTATUS EMT
1$:	MOV	R1,@PC
	.WAIT	3		;WAIT MODIFIED AT RUNTIME
	BCS	2$		;NO FILE THIS CHAN
	SUB	#10.,R4		;POINT INTO NEW FILEBLK
	MOV	R4,R0
	MOV	R2,@PC		;MOVE SAVESTATUS INTO POSITION
	EMT	123		;SAVESTATUS THE FILE
	CLR	-(R4)		;ENTER REMAINING 3 WORDS OF BLK
	CLR	-(R4)
	CLR	-(R4)
	CMP	R4,R3
	BHI	2$
9$:	.UNLOCK			;DONE WITH THE USR
	JMP	NOCORE
2$:	INC	R1
	INC	R2
	CMP	R1,#WEMT+8.	;DONE THIS COMMAND?
	BLOS	1$
8$:	DECB	CSWIT		;ANY MORE COMMAND STRINGS??
	BMI	DIADUN		;INITIAL DIALOGUE COMPLETE
	MOV	R3,R0
	ADD	#80.,R0		;CHECK FOR ENOUGH MEMORY
	CMP	R0,@#HIGH	;ENUF ROOM?
	BHIS	9$		;NOPE
	MOV	INDFLG,R2	;GET BUFFER ADDRESS
	BEQ	15$		;NOT INDIRECT
	MOV	R3,-(SP)	;SAVE R3
	JSR	PC,CSI5		;UNLOAD NEXT COMMAND
	MOV	R3,R1
	MOV	(SP)+,R3	;RESTORE R3
	.CSISPC	R3,#DEFEXT,R1
	BCC	16$		;OK
17$:	.UNLOCK
	JMP	CSI3		;ERROR
15$:	MOV	CSIPTS,R1
	MOV	R1,R5		;POINT TO BEGINING
	.UNLOCK			;SO FOREGROUND CAN RUN
	JSR	PC,CSI7		;GET TTY DATA
	.LOCK			;SO LINKM CAN BE FAST
	.CSISPC	R3,#DEFEXT,R5	;PROCESS
	BCS	17$		;NO GOOD
16$:	MOVB	#CR,-2(R2)	;RESTORE CR
	MOV	(R3),R0		;GET OUTPUT FILE
	BIS	10.(R3),R0
	BIS	20.(R3),R0
	BEQ	4$		;OK
	JMP	TOOMOF		;TOO MANY OUTPUT FILES
4$:	MOV	R3,R2		;COPY ADDRESS
	ADD	#30.,R2		;SKIP TO INPUT FILES
	MOV	#ODBLK+30.,R0	;GET DESTINAION ADDRESS
3$:	MOV	(R2)+,(R0)+	;COPY FILES TO ODBLK
	CMP	R0,#ODBLK+78.	;END?
	BLO	3$		;NOPE
	MOV	(SP)+,R2	;GET SWITCH COUNT
NXTSW:	BNE	10$		;SOMTHING IS THERE
	MOV	#-1,-(SP)	;SIGNAL NO MORE SWITCHES
	MOV	#ODBLK+20.,R1	;SET POINTER FOR LOOKUP'S
	JMP	FINDF		;GO OPEN THE INPUT FILES
10$:	CMPB	@SP,#'C
	BNE	12$
	INCB	CSWIT
	BR	13$
12$:	MOVB	@SP,BSWIC	;BAD SWITCH CHAR
	MOV	@#MONLOW,R0
	INCB	MONCOM(R0)
	.PRINT	#BSWI		;WARNING: BAD SWITCH IGNORED
13$:	TST	(SP)+
	BPL	14$
	TST	(SP)+
14$:	DEC	R2		;COUNT DOWN SWITCHES
	BR	NXTSW

	.ENABL	LSB

DIADUN:	.UNLOCK
	CMP	R4,#SEVENK
	BLO	1$
	ERROR	<NO INPUT>
1$:	SUB	#16.,R4
	BIS	#100000,4(R4)	;SET END OF INPUT BIT
	CMP	R4,R3
	BHI	2$
NOCORE:	ERROR	<CORE>
2$:	MOV	(R4)+,(R3)+	;MOVE ONE FILE BLK
	CMP	R4,#SEVENK	;DONE?
	BLO	2$
	MOV	R3,R0		;POINTER TO 1ST FILE BLOCK
	SUB	#10.,R0		;POINT TO SAVESTATUS INFO
	MOV	R0,FILPT1	;AND SAVE FOR PASS 2
	MOV	#512.,R2	;SET UP FOR I/O BUFFERS
	MOV	#EIBUF1,R4
	CMP	(R3)+,(R3)+	;ROOM FOR LINK MAP PROCESSOR
	MOV	R3,R1
	ADD	R2,R1		;IND BUF1 END ADR
	MOV	R1,@R4
	MOV	R3,-(R4)	;IND HEAD OF BUF1 ADR
	CLR	-(R4)		;INIT BUF1 STATUS
	TST	(R1)+
	MOV	R1,R3		;INIT BUF #2
	MOV	#EIBUF2,R4
	ADD	R2,R1		;IND BUF2 END ADR
	MOV	R1,@R4
	MOV	R3,-(R4)	;IND HEAD OF BUF2 ADR
	CLR	-(R4)		;INIT BUF2 STATUS
	MOV	R1,R3		;UPDATE CORE PTR
	ASR	R2		;MAKE WORD COUNT
	MOV	R3,MAPBUF	;ALLOCATE MAP BUFFER
30$:	CLR	(R1)+
	DEC	R2
	BGT	30$		;CLEAR IT TO START
	MOV	R1,EMAPBU	;POINT TO THE END
	MOV	R1,R3		;UPDATE MEMORY POINTER
	TST	(R3)+		;IND NEXT TABLE ARE
	MOV	#LMLSWT,R4
	TSTB	SSWIT		;MAKE LIBR DIR RESIDENT ?
	BNE	10$		;NO
	MOV	#ELEVNK+LMLMAX,R1
	MOV	@#MONLOW,R2
5$:	CMP	R2,R1		;ROMM FOR FORLIB DIR & LML TABLE ?
	BHI	15$
	TSTB	@R4		;LML CHECKED ?
	BMI	12$
	DECB	@R4		;IND LML MAX SIZE OF 256 WORDS
	SUB	#LMLMAX,R1
	BR	5$
12$:	INCB	-(R4)		;IND LIBR DIR NOT RES
	INC	R4		;PT TO LMLSWT
	BR	10$
14$:	ADD	#256.,R3	;IND MIN SIZE OF LML
	BR	16$
10$:	DECB	@R4		;IND LML SIZE IS 256 WORDS
	BR	20$
15$:	.SETTOP	R1		;REQUEST ENOUGH CORE FOR DIRECTORY
	TST	-(R1)
	CMP	R1,@#HIGH	;REQUEST FULFILLED ?
	BHI	12$
	MOV	R3,LIBDIR	;PT TO LIBR DIRECTORY
	ADD	#FOURK,R3	;IND SYMBOL TABLE AREA
	MOV	R3,DIREND	;IND DIRECTORY END
	TST	(R3)+
20$:	MOV	#BEGLML,R1
	MOV	R3,(R1)+	;POINT TO START OF LML LIST
	MOV	R3,(R1)+
	MOV	R3,PA2LML
	TSTB	@R4		;BIG LML ?
	BMI	14$		;NO
	ADD	#LMLMAX,R3
16$:	MOV	R3,@R1		;POINT TO END OF LML
	CLRB	@R4		;INIT LML SWITCH FOR PASS1
	MOV	-(R1),R1	;GET START OF LML AREA
18$:	CLR	(R1)+		;SET LML TO ZEROES
	CMP	R1,R3		;DONE INITIALIZATION ?
	BLO	18$
	.IF DF	LDA
	.LOCK
	TSTB	LSWIT		;LDA OUTPUT?
	BEQ	DIAE		;NO
	TST	ODBLK		;OUTPUT WANTED?
	BEQ	DIAE
	MOV	#OBUF,LDAPTR	;INIT THE LDA BUFFER POINTER
	.ENTER	0,#ODBLK,ODBLK+8. ;AND ENTER LDA FILE
DIAE:
	.ENDC
	TST	MDBLK		;ANY MAPOUT?
	BEQ	UNLK		;NO
	CLR	MAPBLK		;START AT BLOCK 0
	.ENTER	1,#MDBLK,MDBLK+8.	;YES, ENTER IT
UNLK:	.UNLOCK
	JMP	INIT
	.DSABL	LSB

	.END	
                                                                                                                                                                                                                                                                                                                                                            