	.IF DF	MBUILD
	.TITLE	MBUILD ROOT V02-03
	.IFF
	.TITLE	PIP ROOT V04-06
	.ENDC
; RT-11 PIP  (PERIPHERAL INTERCHANGE PROGRAM)
;      AND
; RT-11 MBUILD   (MAGTAPE BUILD PROGRAM
;
; DEC-11-ORPPA-E
;
; COPYRIGHT (C) 1973,1974,1975
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE,
; OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE MADE
; AVAILABLE TO ANY OTHER PERSON EXCEPT FOR USE ON SUCH SYSTEM AND TO
; ONE WHO AGREES TO THESE LICENSE TERMS. TITLE TO AND OWNERSHIP OF THE 
; SOFTWARE SHALL AT ALL TIMES REMAIN IN DIGITAL.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE
; OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DIGITAL.
;
;	MAY 2, 1973
;
;	HANK MAURER
;	LOUISE GERHART
;	ANTON CHERNOFF

;	JUNE 25, 1974
;
;	BOB FRIEDENTHAL
;
;	NOVEMBER 1974,JANUARY 1975,AUGUST 1975
;
;	BOB BEAN
;
;
	.SBTTL	MACRO DEFINITIONS

	.MCALL	..V1..
	.MCALL	.CLOSE,	.CSISPC,.DELETE,.DSTATU,.FETCH,	.HRESET
	.MCALL	.LOOKUP,.PRINT,	.RCTRLO,.RENAME,.REOPEN,.SAVEST
	.MCALL	.SETTOP,.SRESET,.TTYIN,	.TTYOUT,.UNLOCK,.LOCK
	.MCALL	.READW,	.WAIT,	.DATE,  .WRITW,	.EXIT,	.REGDEF
	.MCALL	.CSIGEN,.SERR  ,.TRPSET,...CM1,...CM2,...CM3

	..V1..	;USE V1 MACRO FORMAT
	.REGDEF	;DEFINE REGISTERS

.MACRO	MESSAGE	TEXT
	JSR	R3,PUTMSG
	.ASCIZ	TEXT
	.EVEN
.ENDM	MESSAGE

.MACRO	ERROR	TEXT
	JSR	R0,MSG
	.ASCIZ	"?TEXT?"
	.EVEN
.ENDM	ERROR

.MACRO	SWITCH	CHAR,ADR,MODE,VALUE
	.BYTE	''CHAR,MODE
.IF B	VALUE
	.WORD	0
.IFF
VALUE:	.WORD	0
.ENDC
.IF EQ	MODE
	.WORD	ADR-COPY
.IFF
ADR:	.WORD	0
.ENDC
.ENDM	SWITCH

;THE FOLLOWING MONITOR FEATURES ARE USED IN NON-STANDARD CALLS
;	HENCE, THE USUAL MACROS ARE NOT USED

.MACRO	.ENTER	CH
	EMT	40+CH
.ENDM	.ENTER

.MACRO	.READ	CH
	EMT	200+CH
.ENDM	.READ

.MACRO	.WRITE	CH
	EMT	220+CH
.ENDM	.WRITE

;SYMBOL DEFINITIONS

NLIMIT	= 37			;MAX # OF DIRECTORY SEGMENTS ALLOWED
STRTAD	= 40			;USER PROGRAM START ADDRESS
JSW	= 44			;JOB STATUS WORD
EMTERR	= 52			;RT-11 ERROR RETURN WORD
SYSPTR	= 54			;POINTER TO RT-11 RESIDENT
DIRBLK	= 6			;STARTING BLOCK OF DIRECTORIES
OFFSET	= 256			;OFFSET TO VITAL RMON WORDS
				;OFFSET IS DIFF OF BLKEY AND $RMON
SYSUNT	= 275			;OFFSET TO SYSTEM DEVICE UNIT #
CONFIG	= 300			;OFFSET TO CONFIG WORD
MONCOM	= 356			;OFFSET TO BATCH COMMUNICATION BYTE
R50STAR	= 132500		;* IN RADIZ 50 (FROM CSI)
DIREOB	= 4000			;DIRECTORY BIT SAYING END OF BLOCK
DIRPRM	= 2000			;BIT SAYING PERMANENT FILE
DIREMP	= 1000			;BIT SAYING EMPTY ENTRY
DIRESZ	= 16			;SIZE OF 1 ENTRY (+ XTRABY)
FGACTV	= 200			;BIT IN CONFIG SAYING FG ACTIVE
CSWEOF	= 20000			;EOF BIT IN CSW
HDR1	= 42110			;ASCII H,D
EOF1	= 47505			;ASCII E,O

RXCS	= 177170		;ADDRESS OF RX11 CONTROL/STATUS REGISTER
	.IF NDF	MBUSSC
RSCS2	= 172050		;ADDRESS OF RH11/RJS03/4 CONT REG 2
	.ENDC
	.IF DF	MBUSSC
RSCS2	= 176310		;ADDRESS OF RH11/RJS03/4 CR2
	.ENDC

				;DEVICE IDENTIFICATION CODES IN $STAT
RKIDEN=0			;RK11/RK05,RK03
DTIDEN=1			;TC11/TU56
TMIDEN=11			;TM11/TU10/TSO3
RFIDEN=12			;RF11/RS11
CTIDEN=13			;TA11/TU60
RJIDEN=16			;RJS03/4
TJIDEN=20			;TJU16
DPIDEN=21			;RP11/RP02,RP03
DXIDEN=22			;RX11/RX01
CLIDEN=23			;COMMUNICATION LINK

;ASCII CHARACTERS
RUBOUT=377			;RUBOUT
ASTRSK=52			;ASTERISK

	.GLOBL	ILLCMD,FGCHK,DEVINF,HANERR,SSB,REBOT,FILDES
	.SBTTL	COMMAND DISPATCHER
	.CSECT	PIP

MSG:	.PRINT			;PRINT ERROR MESSAGE
	MOV	@#SYSPTR,R0
	BISB	#200,MONCOM(R0)	;HARD ERROR
	BR	ESTRT		;SKIP OVER WARNING MESSAGE TESTS-ALSO REENTRY POINT
START:	TST	REBMES		;SHOULD WE TYPE REBOOT MESSAGE?
	BNE	1$		;NO
	.PRINT	#RBMSG		;PRINT ?REBOOT?
1$:	TST	SYSMES		;SHOULD WE PRINT NO SYS ACTION MESSAGE?
	BNE	ESTRT		;NO
	.PRINT	#SYSMSG		;YES-PRINT ?NO SYS ACTION?
	MOV	@#SYSPTR,R0
	INCB	MONCOM(R0)	;SOFT ERROR
ESTRT:	.DATE			;GET TODAY'S DATE
	MOV	R0,(PC)+	;AND REMEMBER IT IN TODAY
TODAY:	0
	JSR	PC,UNLOCK	;RELEASE USR AND RE-ENABLE CTRL/C INTERRUPTS
	MOV	#1000,SP	;SET STACK POINTER
	CLR	@BLKEY		;CAUSE FRESH DIRECTORY TO BE READ
	.RCTRLO			;RESET CTRL/O SWITCH
	.SRESET			;SOFT RESET (PURGE FILES, HANDLERS)
	MOV	USRBUF,R0
	TST	-(R0)		;SET R0 TO BOTTOM OF USR
	.SETTOP			;TELL MONITR HOW MUCH CORE WE NEED
	.SETTOP	#FREE		;THEN CAUSE NOT TO BE SWAPPED OUT BY CTRL/C
	.CSISPC	#FILDES,#DEFEXT,#0	;GET CSI COMMAND STRING FROM TTY
	MOV	@#SYSPTR,R0	;RMON @
	BCC	8$		;NO ERROR
	BISB	#200,MONCOM(R0)	;HARD ERROR
	BR	START
8$:	CLRB	MONCOM(R0)	;START WITH NO ERRORS
	MOV	#CLRLST,R0	;POINT TO LIST OF STUFF TO CLEAR
1$:	CLR	@(R0)+		;CLEAR A WORD
	TST	@R0		;END OF LIST?
	BNE	1$		;NO, DO MORE
	MOV	#LIST,R0	;POINT TO V2 ARG LIST
7$:	CLR	(R0)+		;CLEAR ARG LIST
	CMP	R0,#LIST+16	;DONE?
	BLO	7$		;LOOP IF NOT
	MOV	SP,(PC)+	;SET SYSMES TO NON ZERO
SYSMES:	1
	MOV	SP,(PC)+	;SET REBMES TO NONZERO
REBMES:	1
	CLR	R3		;CLEAR SWITCH HANDLER ADDRESS
	MOV	(SP)+,R1	;NUMBER OF SWITCHES
2$:	DEC	R1		;ANY MORE SWITCHES ??
	BMI	FETCH		;NO, FETCH ALL HANDLERS
	MOV	(SP)+,R2	;GET SWITCH
	BMI	3$		;VALUE WAS SPECIFIED
	CLR	-(SP)		;USE ZERO FOR SWITCH VALUE
3$:	MOV	#SWTCHS-4,R5	;POINTER TO SWITCH LIST
4$:	CMP	(R5)+,(R5)+	;BUMP SWITCH LIST POINTER
	MOV	(R5)+,R0	;GET SWITCH MODE AND CHARACTER
	BEQ	6$		;END OF SWITCH LIST...BAD SWITCH
	CMPB	R2,R0		;IS THIS THE NAMED SWITCH ??
	BNE	4$		;NO, KEEP LOOKING
	MOV	(SP)+,(R5)+	;STORE SWITCH VALUE
	TST	R0		;WHAT TYPE OF SWITCH
	BMI	5$		;ITS A MODE SWITCH
	TST	R3		;ANY PREVIOUS DIRECTIVE ??
	BNE	6$		;YES, MULTIPLE DIRECTIVES ILLEGAL
	MOV	(R5),R3		;NO, SAVE ADDRESS OF HANDLER
	BR	2$		;LOOK FOR NEXT SWITCH
5$:	MOV	SP,(R5)		;SET SWITCH WORD NON ZERO
	BR	2$		;LOOK FOR NEXT SWITCH
6$:	ERROR	<ILL SWT>

CLRLST:	LCHAN	;LAST CHANNEL NUMBER
	OUCHAN	;OUTPUT CHANNEL NUMBER
	.IF NDF	MBUILD
	ASCII	;(/A)
	FBIN	;(/B)
	IGNORE	;(/G)
	ALLDIR	;(/W)
	.ENDC
	CURRNT	;(/C)
	FILENO	;(/M)
	QUERY	;(/Q)
	SYSBAD	;(/Y)
	EMPTY	;(/E RELATED)
	NOINFO	;(/F RELATED)
	XMODE	;(/X)
	DIRSIZ	;(/N VALUE)
	ZXTRA	;(/Z VALUE)
	FBLOKS	;DIRECTORY COUNTS
	NFILS
	NBLOX
	DIRDES	;DIRECTORY LIST FILE
	DIRFLG	;DIRECTORY LISTING IN PROGRESS FLAG
	0	;END OF LIST
	.SBTTL	SWITCH TABLE
MODE=	200
ACTION=	0

SWTCHS:	.IF NDF	MBUILD
	SWITCH	A ASCII  MODE
	SWITCH	B FBIN	 MODE
	SWITCH	D DELETE ACTION
	SWITCH	G IGNORE MODE
	SWITCH	K BLKSCN ACTION
	SWITCH	S COMPRS ACTION
	SWITCH	T EXTEND ACTION
	SWITCH	V VERSON ACTION
	SWITCH	W ALLDIR MODE
	.ENDC
	SWITCH	C CURRNT MODE
	SWITCH	E FULDIR ACTION
	SWITCH	F FASDIR ACTION
	SWITCH	I COPY   ACTION
	SWITCH	L DIRECT ACTION
	SWITCH	M NUMBER MODE   FILENO
	SWITCH	N NSWIT  MODE	DIRSIZ
	SWITCH	O REBOOT ACTION
	SWITCH	Q QUERY  MODE
	SWITCH	R RENAME ACTION
	SWITCH	U BOOT   ACTION
	SWITCH	X XMODE  MODE
	SWITCH	Y SYSBAD MODE
	SWITCH	Z ZEROD  ACTION ZXTRA
	0
	.SBTTL	HANDLER FETCH
HANERR:	ERROR	<ILL DEV>
FETCH:	MOV	#FILDES,R2	;POINTER TO CSI OUTPUT
	MOV	#FREE,R4	;ADDRESS OF FREE CORE
	MOV	#FILDES+36,R1	;ADDRESS OF INPUT LIST
	.IF NDF	MBUILD
1$:	TST	(R2)		;IS DEVICE NAME NULL? (/E, /L, ETC.)
	BEQ	2$		;YES, DON'T FETCH A HANDLER
	.FETCH	R4,R2		;LOAD HANDLER IN FREE CORE
	BCS	HANERR		;ILLEGAL DEVICE (PROBABLY)
	MOV	R0,R4		;SAVE UPDATED FREE CORE ADDRESS
2$:	ADD	#12,R2		;BUMP LIST POINTER
	CMP	R2,R1		;ARE WE IN THE INPUT LIST ??
	BLOS	1$		;NO, INCREMENT WAS CORRECT
	TST	-(R2)		;INPUT LIST ELEMENTS ARE 1 WORD SHORTER
	CMP	R2,#FILDES+116	;DONE WITH LIST ??
	BLO	1$		;NO, LOOP
	.ENDC
	MOV	R4,INFILS	;SAVE START OF EXPANDED INPUT LIST
	MOV	R4,R2		;AND PUT IT INTO R2
				;NOTE: R1=#FILDES+36
	.SBTTL	INPUT EXPANDER
EXPAND:	ADD	#COPY,R3	;COPY IS THE DEFAULT OPERATION
	MOV	R3,-(SP)	;ADDRESS OF CORRECT ROUTINE
	MOV	#6,-(SP)	;CSI INPUT LIST COUNT
EXPLUP:	CLR	R3		;STAR SWITCH
	MOV	R2,R4		;SAVE START OF NEXT EXPANDED ENTRY
	JSR	PC,CORCHK	;INSURE ENUF FREE CORE FOR NXT FILENAM	;###
	MOV	(R1)+,(R2)+	;COPY DEVICE NAME FROM SHORT INP LIST
	BNE	NOTNUL		;ENTRY WAS NOT NULL
	TST	-(R2)		;NULL ENTRY, BACKUP EXPANDED LIST PTR
	ADD	#6,R1		;SKIP OVER THIS SHORT LIST ENTRY
INFCNT:	.CLOSE	0		;CLOSE CHANNEL USED FOR DIR READS
	JSR	PC,UNLOCK	;RELEASE USR AND RE-ENABLE CTRL/C INTERRUPTS
	DEC	@SP		;ANY MORE TO EXPAND??
	BNE	EXPLUP		;YES
	MOV	(SP)+,(R2)+	;POP 0 TO ZERO END OF EXPANDED LIST
	MOV	#FILDES,R4	;POINTER TO OUTPUT LIST
	MOV	(PC)+,R5	;POINTER TO EXPANDED INPUT LIST
INFILS:	0
				;NOTE: R2 POINTS TO FREE CORE
	JMP	@(SP)+		;JMP TO COMMAND HANDLER
NOTNUL:	CMP	(R1),#R50STAR	;WAS FILE NAME *  ??
	BNE	1$		;NO
	COMB	R3		;SET STAR NAME SWITCH
1$:	MOV	(R1)+,(R2)+	;COPY THE NAME
	MOV	(R1)+,(R2)+	;TWO WORDS OF RAD 50
	MOV	(R1),(R2)+	;COPY THE EXTENSION
	CMP	(R1)+,#R50STAR	;IS THE EXTENSION *  ??
	BNE	2$		;NO
	BIS	#100000,R3	;YES, SET STAR EXTENSION SWITCH
2$:	TST	R3		;IS NAME OR EXT STARRED ??
	BEQ	INFCNT		;NO, NO EXPANSION
	MOV	#DEVNAM,R5	;POINTER TO NON DIR DEV NAM BLOCK
	MOV	(R4),(R5)	;PUT IN THE DEVICE NAME
	MOV	R4,R2		;RESET PTR TO START OF EXPANDED ENTRY
	JSR	PC,GETDIR	;GET THE FIRST BLOCK OF THE DIRECTORY
EXPNDB:	MOV	R0,-(SP)	;SAVE NEXT BLOCK
EXPNDL:	BIT	(R5),#DIREOB	;IS IT THE END OF BLOCK ??
	BEQ	NOEOB		;NO, CHECK FOR PERM
	MOV	(SP)+,R0	;IS THIS THE LAST DIR BLOCK ??
	BEQ	INFCNT		;YES, END OF EXPANSION
	JSR	PC,RDDIR	;READ NEXT DIRECTORY BLOCK
	BR	EXPNDB		;CONTINUE EXPANSION
NOEOB:	BIT	(R5)+,#DIRPRM	;IS IT A PERM FILE ??
	BEQ	NOMACH		;NOT UNLESS THIS BIT IS SET
	TSTB	R3		;WAS THE NAME STARRED ??
	BMI	NMATCH		;YES, DON'T CARE ABOUT THE NAME
	CMP	(R5),2(R4)	;NO STAR, DOES NAME MATCH ??
	BNE	NOMACH		;NO
	CMP	2(R5),4(R4)	;CHECK BOTH WORDS OF THE NAME
	BNE	NOMACH
NMATCH:	TST	R3		;WAS THE EXTENSION STARRED ??
	BMI	EMATCH		;YES, DON'T CARE ABOUT THE EXTENSION
	CMP	4(R5),6(R4)	;NO STAR, DOES EXTENSION MATCH ??
	BNE	NOMACH		;NO
EMATCH:	TST	CURRNT		;SHOULD WE INCLUDE ONLY TODAY'S?
	BEQ	2$		;NO
	CMP	12(R5),TODAY	;DOES DATE MATCH TODAY'S?
	BNE	NOMACH		;NO-DON'T INCLUDE IT
2$:	TST	QUERY		;SHOULD WE VERIFY THIS FILE ?
	BEQ	1$		;NO
	JSR	PC,FNAML	;LIST FILE NAME
	SUB	#6,R5		;FIX R5
	MESSAGE	<"?">
	JSR	PC,YESCHK	;IS IT YES ?
	BNE	NOMACH		;NOPE
1$:	MOV	(R4),(R2)+	;THIS FILE MATCHES, COPY INTO EXP LIST
	MOV	(R5),(R2)+	;COPY MATCHING FILE NAME
	MOV	2(R5),(R2)+
	MOV	4(R5),(R2)+	;INTO EXPANDED LIST
NOMACH:	ADD	#DIRESZ-2,R5	;BUMP R5 TO NEXT FILE ENTRY
	ADD	(PC)+,R5	;DON'T FORGET EXTRA WORDS
XTRABY:	0
	BR	EXPNDL		;LOOK AT NEXT FILE NAME
	.IF NDF	MBUILD
	.SBTTL	DELETE
DELETE:	TST	(R4)		;ANY OUTPUT FILES SPECIFIED?
	BEQ	1$		;NO-COMMAND OK
	JMP	ILLCMD		;YES-ILLEGAL /D COMMAND SYNTAX
1$:	TST	(R5)		;NULL INPUT LIST?
	BEQ	FNF		;YES-GIVE FNF ERROR
2$:	TST	(R5)		;ANY FILES LEFT TO DELETE ??
	BEQ	STL1V		;NO, DO NEXT PIP COMMAND
	MOV	R5,R0		;POINTER TO NEXT FILE DESCRIPTOR
	ADD	#10,R5		;BUMP INPUT LIST POINTER
	JSR	PC,SYSCHK	;CHECK FOR SPECIAL EXTENSIONS
	BEQ	2$		;DON'T DELETE .BAD OR .SYS WITHOUT /S
	JSR	PC,TSTNUM	;GET CONTENTS OF FILENO INTO XTRA ARG
	EMT	^O375		;DELETE VERSION 2 (CODE 0)
	BCC	2$		;OK, DO NEXT ONE
	.ENDC
FNF:	ERROR	<FIL NOT FND>


;TSTNUM ENTERS THE /M SWITCH ARGUMENT FOR LOOKUP, ENTER, AND DELETE
;IT ALSO SETS UP THE VERSION 2 ARG LIST.

TSTNUM:	MOV	R0,-(SP)	;SAVE POINTER TO FILE NAME
	MOV	#FBLOCK,R0	;POINT TO AREA
	MOV	FILENO,@R0	;INSET FILE COUNT (-0 IF /M NOT GIVEN)
	MOV	@R0,-(R0)	;BOTH FBLOCK AND FLEN
	MOV	(SP)+,-(R0)	;POINT TO FILE NAME
	CLR	-(R0)		;CHANNEL 0,CODE 0
	RTS	PC
	.SBTTL	RENAME
RENAME:	TST	(R5)		;NULL INPUT LIST?
	BEQ	FNF		;YES-REPORT ERROR
1$:	TST	(R5)		;ANY MORE FILES TO RENAME ??
	BEQ	STL1V		;NO, RETURN TO PIP
	MOV	R5,R0		;PT R0 TO FILE
	JSR	PC,MTCA		;IF MT OR CT,
	BR	ILLREN		;DISALLOW RENAME EVEN THO MONITR WILL, TOO
	CMP	(R4),(R5)	;ARE DEVICES THE SAME ???
	BNE	ILLREN		;NO, PROBABLY AN ERROR
	JSR	PC,OEXPND	;EXPAND NEXT OUTPUT FILE NAME
	MOV	#OLNAME,R0	;POINT TO OLD NAME
	MOV	(R5)+,(R0)+	;MOVE 4 WORDS OF OLD NAME INTO LIST
	MOV	(R5)+,(R0)+
	MOV	(R5)+,(R0)+
	MOV	(R5)+,(R0)+
	MOV	#OLNAME,R0	;RESTORE POINTER TO OLD NAME
	JSR	PC,SYSCHK	;CHECK FOR PROTECTED FILES
	BEQ	1$		;.SYS OR .BAD FILE
	.RENAME	0		;DO THE RENAME
	.IF DF	MBUILD
	JSR	PC,FATERR	;CHECK TO SEE IF FATAL ERROR
	.ENDC
	BCC	1$		;CONTINUE IF FILE FOUND
	BR	FNF		;ELSE FILE NOT FOUND ERROR
ILLREN:	ERROR	<ILL REN>
STL1V:	JMP	START		;BACK TO PIP
	.SBTTL REBOOT

REBOOT:	JMP	REBOT		;CALL REBOOT OVERLAY

	.SBTTL	COPY

EOF	= 20000			;EOF BIT IN CSW
HDW	= 1			;HARD ERR BIT IN CSW

COPY:	MOV	R2,-(SP)	;SAVE START ADDRESS OF FREE CORE
	TST	(R5)		;NULL INPUT LIST?
	BNE	ONE$		;NO
	JMP	FNF		;YES-REPORT ERROR
ONE$:	TST	(R5)		;ANY MORE INPUT FILES TO OPEN ??
	BEQ	TWO$		;NOPE, ALL OPENED AND SAVED
	JSR	PC,CORCHK	;INSURE ENUF ROOM FOR SAVESTAT OR FOR	;###
				;MT/CT FILENAME				;###
	MOV	R5,R0		;GET DEVICE NAME PTR
	JSR	PC,MTCACL	;IF MAGTAPE OR CASSETTE OR CL,
	BR	DOMC		;GO COPY FILE NAME
 	JSR	PC,LOOKUP	;ELSE, LOOKUP THIS FILE
	MOV	R2,R0		;PUT STATUS BLOCK IN FREE CORE
	ADD	#12,R2		;FIVE WORDS EACH
	.SAVEST	0		;SAVE THE FILE STATUS
	BR	ONE$		;DO NEXT ONE
DOMC:	MOV	(R5)+,(R2)+	;MOVE INPUT LIST TO CORE BLOCK
	MOV	(R5)+,(R2)+	;FOR MT AND CT INSTEAD OF STATUS BLOCK
	MOV	(R5)+,(R2)+
	MOV	(R5)+,(R2)+
	MOV	#-1,(R2)+	;SET LAST WORD NEG. TO INDICATE MT OR CA
	BR	ONE$		;THEN GET NEXT INPUT ELEMENT
TWO$:	CLR	(R2)+		;MARK END OF LIST FOR COMBINE COPY
	JSR	PC,DFNBUF	;DEFINE BUFFER(S) ABOVE INPUT STATII
	MOV	INFILS,R5	;RESET POINTER TO INPUT LIST
MCSTRT:	MOV	(SP),R2		;RESET POINTER TO STATUS BLOCKS
	TST	XMODE		;IS IT A MULTI-COPY ??
	BNE	ENTR15		;YES, ENTER UP TO 15 AT A TIME
	CLR	(R5)		;PREVENT JMP MCSTRT AFTER CLOSE OUT FILE
	MOV	R4,R0		;PREPARE TO ENTER OUTPUT FILE (ONLY 1)
	MOV	OUCHAN,LCHAN	;SAVE # OF OUTPUT CHANNEL
	JSR	PC,ENTER	;DO IT
	BNE	DOCOMB		;OK, GO DO THE COMBINE COPY
STLNK1:	JMP	START		;.SYS OR .BAD, BACK TO START
ENTR15:	MOV	#15,OUCHAN	;ENTER UP TO 14 AT A TIME
6$:	TST	(R5)		;ANY INPUT FILES LEFT ??
	BEQ	7$		;NO, GO MOVE WHAT WE HAVE
	JSR	PC,OEXPND	;GET NEXT OUTPUT FILE NAME
	MOV	R5,R0		;SAVE DEV NAME PTR FOR MTCA BELOW
	ADD	#10,R5		;MOVE POINTER TO NEXT INPUT FILE
	MOV	4(R2),(R3)	;SAME SIZE AS INPUT (OR LESS)
	JSR	PC,MTCACL	;IS INPUT FROM MT OR CT OR CL?
	CLR	(R3)		;IF SO,WE MUST DO 0 LENGTH ENTER
	ADD	#12,R2		;BUMP STATUS BLOCK POINTER
	MOV	#NEWNAM,R0	;PREPARE TO ENTER THIS FILE
	JSR	PC,ENTER	;ENTER THE FILE
	MOV	#NEWNAM,R0	;POINT TO OUTPUT DEVICE NAME AGAIN
	JSR	PC,MTCACL	;AND IF MT OR CA OR CL,
	BR	7$		;DO NO MORE ENTERS
	TST	-2(R2)		;IS INPUT FILE MT OR CA?
	BMI	7$		;YES-DO NO MORE ENTERS
;IF MT OR CA IS INVOLVED IN EITHER SIDE OF TRANSFER,END THIS BATCH OF
;ENTERS,BECAUSE ONLY ONE FILE CAN BE TRANSFERRED AT A TIME
	DEC	OUCHAN		;ELSE, ANY CHANNELS LEFT?
	BPL	6$		;IF SO, ENTER ANOTHER FILE
7$:
	MOV	OUCHAN,LCHAN	;SAVE NUMBER OF LAST ENTERED CHANNEL
	MOV	#15,OUCHAN	;ELSE, PREPARE TO COPY 14 FILES
MCLOOP:	MOV	OUCHAN,WAITN	;COPY CURRENT OUTPUT CHANNEL NUMBER
	ADD	(PC)+,(PC)	;MAKE IT A WAIT AND EXECUTE IT
	.WAIT	1
WAITN:	HALT
	BCS	NOMC		;NO FILE ENTERRED HERE
DOCOMB:	CLR	OUBLK		;ZERO OUTPUT FILE BLOCK NUMBER
	MOV	OUBUF,R2	;INITIALIZE WRITEC
COMBIN:	MOV	(SP),R0		;POINTER TO STATUS OF INPUT FILE
	TST	(R0)		;IS STATUS WORD 0
	BEQ	DOCLOS		;YES, END OF COMBINE COPY
	TST	10(R0)		;IF LAST WORD OF BLOCK<0,
	BMI	MTORCA		;THEN DO THE MT OR CA LOOKUP NOW
	.REOPEN	0		;ELSE, RE-OPEN THE INPUT FILE
	BR	MNORC
MTORCA:	MOV	R5,-(SP)	;SAVE R5 AROUND LOOKUP SUBROUTINE
	MOV	R0,R5		;R0 POINTS TO ELEMENT IN CORE BLOCK
	JSR	PC,LOOKUP	;LOOKUP LOOKS UP ELEMENT PT'D TO BY R5
	MOV	(SP)+,R5	;RESTORE R5
MNORC:	CLR	INBLK		;ZERO INPUT FILE BLOCK NUMBER
	.IF NDF	MBUILD
	CLR	INBUFE		;INITIALIZE READC AND READB
	TST	FBIN		;FORMATTED BINARY
	BNE	BMCOPY		;YES
	TST	ASCII		;WAS IT /A ??
	BEQ	IMCOPY		;NO, COPY IN IMAGE MODE
12$:	JSR	PC,READC	;READ A CHAR
	BEQ	MCEOF		;END OF INPUT FILE
	JSR	PC,WRITEC	;WRITE CHAR
	BR	12$		;DO NEXT CHAR
	.IFF
	BR	IMCOPY		;COPY IN IMAGE MODE
	.ENDC
IMLOOP:	JSR	PC,WRITE	;WRITE THE BUFFER LOAD
	BCS	1$		;GOT A REPORTED ERR. THIS TIME
	MOV	OUCHAN,R0	;SEE IF ERR UNREPORTED
	INC	R0
	MOV	R0,-(SP)
	ASL	R0
	ASL	R0
	ADD	(SP)+,R0	;POINT R0 TO CSW FOR THIS WRITE
	ASL	R0		;MAKE IT BYTES
	CMP	(R0)+,(R0)+
	ADD	@#SYSPTR,R0
	BIT	#EOF+HDW,(R0)
	BEQ	IMCOPY
1$:	JMP	OUTER		;OUTPUT ERRORS
IMCOPY:	JSR	PC,READ		;READ A BUFFER LOAD
	BNE	IMLOOP		;NO EOF, DON'T QUIT
MCEOF:	.CLOSE	0		;CLOSE THE INPUT FILE
	ADD	#12,(SP)	;BUMP STATUS BLOCK POINTER
	TST	XMODE		;IS IT A COMBINE COPY ??
	BEQ	COMBIN		;YES, APPEND NEXT INPUT FILE
DOCLOS:	.IF NDF	MBUILD
	MOV	ASCII,-(SP)	;IF IT IS NEITHER ASCII
	BIS	FBIN,(SP)+	;  NOR FORMATTED BINARY
	BEQ	NOFILL		;    THEN DO NOT FILL BUFFER
	JSR	PC,FILBUF	;FILL END OF BUFFER WITH NULLS
	.ENDC
NOFILL:	MOV	#NEWNAM,R0	;POINTER TO DEVICE NAME IN R0
	JSR	PC,MTCACL	;SEE IF MT OR CA OR CL
	BR	1$		;IF SO,ONLY ONE FILE IS OPEN AT A TIME
	MOV	(SP),R0		;IF INPUT FILE IS MT OR CA AS WELL,
	TST	-(R0)		;ONLY ONE FILE WILL BE OPEN AT A TIME
	BMI	1$
	DEC	OUCHAN		;GO DOWN ONE CHANNEL
	BPL	MCLOOP		;IF MORE TO DO, TRY ANOTHER XFER
1$:	MOV	(PC)+,R2	;SETUP .CLOSE IMAGE
	.CLOSE	0
18$:	MOV	R2,(PC)		;MOV INSTRUCTION AND EXECUTE IT
	HALT
	INC	R2		;BUMP CLOSE CHANNEL NUMBER
	CMP	R2,(PC)+	;IS IT DONE ??
	.CLOSE	17
	BNE	18$		;NO, KEEP CLOSING
	TST	(R5)		;ANY MORE FILES AT ALL ??
	BEQ	STLNK5		;NO-BACK TO PIP
	JMP	MCSTRT		;YES-DO NEXT BATCH
NOMC:	ADD	#12,(SP)	;BUMP INPUT LIST POINTER
	BR	NOFILL
	.IF NDF	MBUILD
BMCOPY:	MOV	R4,R4SAV	;SAVE R4
	MOV	#FIRSTBY,R4	
21$:	JSR	PC,READB	;READ FORMATTED BINARY
	BEQ	22$		;END OF FILE
	JSR	PC,WRITEC	;WRITE A CHARACTER
	BR	21$		;AGAIN
22$:	MOV	(PC)+,R4	;RESTORE R4
R4SAV:	.WORD	0
	BR	MCEOF
	.ENDC

	.PAGE
	.SBTTL	MT,CA OR CL TEST
;MTCA TESTS FOR UNIT NAME POINTED TO BY R0 MAGTAPE OR CASSETTE.  IF SO,
;IT RETURNS TO LOCATION FOLLOWING CALL.  IF NOT, IT RETURNS TO LOCATION +2.
;THUS		MOV	NAMADR,R0
;		JSR	PC,MTCA
;		BR	MTORCA
;		BR	NOTMTORCA

MTCACL:	CLR	-(SP)		;TEST FOR CL TOO
MTCA:	.DSTATU	#DEVINF		;GET STATUS OF THIS DEVICE
MTCA1:	MOV	#DEVINF,R0	;POINT R0 TO STATUS WORD
	CMPB	@R0,#TMIDEN	;TM11 MAGTAPE ?
	BEQ	1$
	CMPB	@R0,#TJIDEN	;TJU16 MAGTAPE?
	BEQ	1$		;YES
	CMPB	@R0,#CTIDEN	;TA11 CASSETTE?
	BEQ	1$
	TST	(SP)		;TEST FOR CL TOO?
	BNE	3$		;NOPE
	CMPB	(R0),#CLIDEN	;CL?
	BEQ	1$		;YES
	TST	(SP)+		;PRUNE STACK
	BR	3$		;AND EXIT
1$:	TST	(SP)		;CL TEST?
	BNE	2$		;NOPE
	TST	(SP)+		;PURGE STACK
2$:	RTS	PC		;AND EXIT
3$:	ADD	#2,(SP)
	RTS	PC


STLNK5:	JMP	START
	.SBTTL	DIRECTORY

FASDIR:	MOV	SP,(PC)+	;ONLY GIVE FILE NAMES
NOINFO:	.WORD	0
	BR	DIRECT
FULDIR:	MOV	SP,(PC)+	;LIST EMPTIES AND THEIR SIZES
EMPTY:	.WORD	0
DIRECT:	INC	(PC)+		;SET DIRECTORY LISTING IN PROGRESS FLAG
DIRFLG:	0
	ADD	#10,R2		;MAKE ROOM FOR POSSIBLE EXTRA ENTRY
	MOV	R5,DEVSAV	;REMEMBER THE DEVICE POINTER
	MOV	R5,R0		;SAVE POINTER FOR FETCH
	TST	(R5)		;IS INPUT DEVICE SPECIFIED?
	BNE	1$		;YES, USE WHAT HE SPECIFIED
	TST	FILDES+36	;IS THIS /L OR NULL EXPANDED LIST?
	BEQ	4$		;JUST /L
	MOV	FILDES+36,(R5)+ ;REMEMBER INPUT DEVICE (DEGENERATE CASE)
	BR	2$
4$:	MOV	(PC)+,(R5)+	;AND PUT IN THE DK:
	.RAD50	/DK /
	.FETCH	R2		;MAKE SURE DK HANDLER IS IN CORE
	BCC	2$		;BOGUS DEVICE ASSIGNED TO DK?
	JMP	HANERR		;GIVE AN ERROR IF SO
2$:	MOV	R0,R2		;GOOD, RESET AVAILABLE CORE
	CLR	(R5)		;CLEAR TARGET FILE NAME
	CLR	6(R5)		;AND MARK END OF LIST
1$:	JSR	PC,DFNBUF	;DEFINE OUTPUT BUFFERS
	CMP	(R4),(PC)+	;IS OUTPUT DEVICE TT: ??
	.RAD50	"TT "
	BNE	3$		;NO, ENTER DIRECTORY FILE
	CLR	(R4)		;YES, MAKE IT 0
3$:	MOV	(R4),DIRDES	;ENABLE LISTING ON DEVICE
	MOV	R4,R0		;POINTER TO OUTPUT FILE NAME
	JSR	PC,ENTER	;ENTER DIR FILE
	MOV	#DEVNAM,R5	;POINTER TO DEVICE NAME BLOCK
	MOV	@INFILS,(R5)	;PUT IN THE DEVICE NAME
	JSR	PC,GETDIR	;START DIRECTORY STUFF
	MOV	R0,-(SP)	;SAVE NEXT BLOCK
	MOV	R5,-(SP)	;SAVE DIR PTR
	MOV	-(R5),DEVLOC	;SAVE START BLOCK OF SEGMENT
	TST	NOINFO		;SUPPRESS DATE ON FAST DIRECTORY
	BNE	DIRLUP
	MOV	TODAY,R3	;GET TODAY'S DATE INTO R3
	JSR	PC,DATOUT	;PRINT THE DATE AND A CRLF
NXTLIN:	JSR	PC,CRLF
DIRLUP:	MOV	(SP),R5		;BUMP R5 TO THE NEXT ENTRY
	ADD	XTRABY,(SP)	;COMPUTE ADDR OF NEXT ENTRY
	ADD	#DIRESZ,(SP)
	MOV	INFILS,R0	;POINTER TO TARGET LIST
	BIT	@R5,#DIREOB	;IS IT END OF BLOCK ?
	BNE	ENDBLK		;YES
	ADD	10(R5),DEVLOC	;UPDATE POSITION ON DEVICE
	BIT	(R5)+,#DIRPRM	;IS THIS A PERM FILE ??
	BNE	TARG1		;YES, SEE IF ITS A TARGET
	ADD	6(R5),FBLOKS	;ADD TO NUMBER OF FREE BLOCKS
	TST	EMPTY		;WAS IT /E  ??
	BEQ	DIRLUP		;NO, DON'T PRINT EMPTIES
	MESSAGE	<"< UNUSED > ">	;PRINT THE UNUSED MESSAGE
	MOV	6(R5),R0	;GET SIZE OF EMPTY
	JSR	PC,R10OVT	;OUTPUT DECIMAL
	BR	NXTLIN		;PRINT CRLF AND CONTINUE
TARGCK:	CMP	(R5),(R0)+	;DOES IT MATCH THIS TARGET FILE ?
	BNE	1$		;NO
	CMP	2(R5),(R0)
	BNE	1$
	CMP	4(R5),2(R0)
	BEQ	TARGET		;A HIT !
1$:	CMP	(R0)+,(R0)+	;ADVANCE TO NEXT IN TARGET LIST
TARG1:	TST	(R0)+		;END OF LIST ?
	BNE	TARGCK		;NO, CONTINUE
	TST	FILDES+40	;PRINT IT ANYWAY ?
	BNE	DIRLUP		;NOPE
TARGET:	TST	CURRNT		;SHOULD WE INCLUDE ONLY TODAY'S?
	BEQ	8$		;NO
	CMP	12(R5),TODAY	;DOES THIS DATE MATCH TODAY'S?
	BNE	DIRLUP		;NO-DON'T INCLUDE IT
8$:	INC	NFILS		;BUMP HIT COUNTER
	JSR	PC,FNAML	;LIST FILE NAME
	ADD	(R5),NBLOX	;BUMP BLOCK CTR
	TST	NOINFO		;WAS IT /F ??
	BNE	NXTLIN		;YES, NO SIZE OR DATE
	MESSAGE	<" ">		;PRINT A SPACE
	MOV	(R5)+,R0	;GET MAX SIZE
	JSR	PC,R10OVT	;OUTPUT DECIMAL
	MESSAGE	<" ">		;PRINT A SPACE
	TST	(R5)+		;ADVANCE TO DATE WORD
	MOV	(R5),R3		;GET DATE WORD
	JSR	PC,DATOUT	;PRINT DATE
	.IF NDF	MBUILD
	TST	ALLDIR		;START BLK & EXTRAS?
	BEQ	NXTLIN		;NOPE
	TST	(R5)+		;WAS DATE = 0 ?
	BNE	10$		;NO
	MOV	#9.,R1		;PRINT 9 SPACES
9$:	MESSAGE	<" ">
	DEC	R1
	BNE	9$
10$:	MOV	DEVLOC,R0	;GET STARTING BLOCK
	SUB	-6(R5),R0	;FIX UP DEVICE BLOCK #
11$:	JSR	PC,R8OUT	;PRHNT IT OCTAL
	CMP	R5,(SP)		;DONE LAST EXTRA WORD ?
	BHIS	NXTLIN		;YES
	MOV	(R5)+,R0	;GET AN EXTRA WORD
	BR	11$		;PRINT IT
	.IFF
	BR	NXTLIN		;DO NEXT LINE
	.ENDC
ENDBLK:	TST	(SP)+		;REMOVE R5 THING FROM STACK
	MOV	(SP)+,R0	;GET REL PTR TO NEXT DIR BLK
	BEQ	ENDDIR		;IF ZERO, END OF THIS DIRECTORY
	JSR	PC,RDDIR	;READ NEXT DIR SEGMENT
	MOV	R0,-(SP)	;SAVE NEXT BLOCK #
	MOV	R5,-(SP)	;AND DIR PTR
	MOV	-(R5),(PC)+	;SAVE START POSITION
DEVLOC:	0
	MOV	FILDES+40,-(SP)	;INTER-BLOCK GAP ?
	BIS	CURRNT,(SP)+	; OR /C?
	BNE	DIRLUP		;NO
	MOV	DEVSAV,R0
	JSR	PC,MTCA		;IS THIS MT OR CT?
	BR	DIRLUP		;YES-NO BLANK LINES
	BR	NXTLIN		;PRINT BLANK LINE TO MARK NEW SEGMENT
ENDDIR:	TST	NOINFO		;IS IT FAST ?
	BNE	ENDLST		;YES, NO FREE BLOCK MSG
	MOV	(PC)+,R0	;GET FILE COUNT
NFILS:	0
	CMP	R0,#1		;IS IT WORTH IT ?
	BLOS	LSTFRE		;NO
	CLR	R3		;LEFT JUSTIFY IT
	JSR	PC,R10CNV	;YES, LIST IT
	MESSAGE	<" FILES, ">
	MOV	(PC)+,R0	;GET BLOCK COUNT
NBLOX:	0
	JSR	PC,R10CNV	;PRINT IT
	MESSAGE	<" BLOCKS"<015><012>>
LSTFRE:	MOV	(PC)+,R0	;NAME OF DEVICE BEING LISTED INTO R0
DEVSAV:	0
	JSR	PC,MTCA		;MT OR CT?
	BR	ENDLST		;YES-DONT PRINT FREE BLOCK MESSAGE
	MOV	(PC)+,R0	;GET TOTAL NUMBER OF UNUSED BLOCKS
FBLOKS:	0
	JSR	PC,R10OVT	;OUTPUT THE FREE BLOCKS MESSAGE
	MESSAGE	<" FREE BLOCKS"<015><012>>
ENDLST:	.IF NDF	MBUILD
	TST	DIRDES		;WAS OUTPUT DEVICE TT: ??
	BEQ	STLNK2		;YES, NO BUFFER TO DUMP
	JSR	PC,FILBUF	;FILL THE BUFFER WITH NULLS
	.CLOSE	1		;CLOSE THE FILE
	.ENDC
STLNK2:	JMP	START		;DO NEXT PIP COMMAND
	.SBTTL	ZERO DIRECTORY
ZEROD:	CMP	DIRSIZ,#NLIMIT	;DID HE SPECIFY A /N SRG TOO LARGE?
	BHI	ILLCMD		;YES-ERROR
	MOV	(R5),R0		;ANY DEVICE GIVEN ??
	BEQ	ILLCMD		;NO,BAD COMMAND
	TST	2(R5)		;IS A FILE NAME GIVEN
	BNE	ILLCMD		;YES-THIS MUST BE A MISTAKE
	JSR	PC,R50OUT	;OUTPUT THE DEVICE NAME
	MESSAGE	<":/Z   ARE YOU SURE ?">
	JSR	PC,YESCHK	;TRY FOR A "Y"
	BNE	STLNK2		;NO, DON'T ZERO
	MOV	R5,R0		;GET PTR TO FILE NAME
	JSR	PC,MTCA		;IF MT OR CA,
	BR	DODEL		;INITIALIZE VOLUME
	CMPB	(R0),#CLIDEN	;CL?
	BEQ	ILLCMD		;YEP. NOT ALLOWED TO ZERO
	JSR	PC,OPNDIR	;ELSE, OPEN THE DIRECTORY FOR WRITING
	.REOPEN	1		;ON CHANNEL 1
ZERIT:	MOV	USRBUF,R4	;USE USR'S DIR BUFFER
	MOV	DIRSIZ,R5	;DIRECTORY SIZE IN SEGMENTS (/N:XXXX)
	BNE	1$		;IF NOT ZERO, OK
	MOV	#4,R5		;OTHERWISE MAKE IT 4 SEGMENTS
1$:	MOV	R5,(R4)+	;THATS FIRST WORD OF THE DIRECTORY
	ASL	R5		;MAKE IT A BLOCK COUNT
	CLR	(R4)+		;ZERO LINK TO NEXT SEGMENT
	MOV	ZXTRA,R3	;GET NUMBER OF EXTRA WORDS (/Z:XXXX)
	ASL	R3		;MAKE IT THE EXTRA BYTE COUNT
	MOV	#1,R0		;SET UP DIRECTORY SEGMENT NUMBER
	MOV	R0,(R4)+	;SET INITIAL HIGHEST SEGMENT = 1
	MOV	R3,(R4)+	;NUMBER OF XTRA BYTES INTO DIR HEADER
	ADD	#DIRBLK,R5	;GIVES TOTAL NUMBER BLOCKS USED
	MOV	R5,(R4)+	;WHICH IS ALSO START BLOCK OF FILES
	MOV	R3,XTRABY	;SAVE IT
	MOV	DEVINF+6,R1	;GET THE TOTAL SIZE OF THE DEVICE
	SUB	R5,R1		;MINUS THE AMOUNT USED BY DIR
	JSR	PC,MAKEMT	;CREATE THE EMPTY
	MOV	#DIREOB,(R4)+	;PUT IN THE END OF BLOCK MARKER
	JSR	PC,DIRWR	;WRITE OUT THE DIRECTORY IN SEG 1
	CLR	R0		;BLOCK # IS 0
	.WRITW	1,#BTMSGP,#400	;WRITE DUMMY BOOTSTRAP ON BLK 0
	.IF NDF	MBUILD
	BCC	2$		;BRANCH IF NO ERROR
	.IFF
	BCC	STLNK2		;BACK TO CSI
	.ENDC
3$:	JMP	OUTER		;PRINT ?OUT ER? MESSAGE
	.IF NDF	MBUILD
2$:	CMPB	DEVINF,#DXIDEN	;IS THIS RX11/RX01 FLOPPY DISK?
	BNE	STLNK2		;BRANCH IF NOT TO RESTART PIP
	MOV	#DXAREA,R0	;ELSE DO SPFUN REQUEST
	EMT	375		;TO WRITE VOL ID IN TRACK 0,SECTOR 7
	BCS	3$		;BRANCH IF HARDWARE ERROR
	BR	STLNK2		;BACK TO PIP
	.ENDC
ILLCMD:	ERROR	<ILL CMD>

	.IF NDF	MBUILD
;ARGUMENT AREA FOR FLOPPY INIT SPFUN REQUEST
DXAREA:	.BYTE 1,32		;CHANNEL 1,SPFUN REQ
	7			;SECTOR 7
	DXBUFF			;ADDRESS OF BUFFER TO BE WRITTEN
	0			;TRACK 0
	.BYTE 377,376		;SECTOR WRITE COMMAND
	0			;WAIT FOR COMPLETION

;BUFFER USED TO WRITE FLOPPY VOL ID. ONLY FIRST 4 BYTES
;ARE SIGNIFICANT
DXBUFF:	.WORD	0		;SPFUN USES FIRST WORD FOR DD FLAG
	.ASCII	/RT11/
	.ENDC
;*********************************************************
;DUMMY BOOT WRITTEN INTO BLOCK 0 OF ALL DEVICES PROPERLY ZEROED
	TPB	= 177566
	TPS	= 177564
BTMSGP:	NOP			;ALL BOOTS START WITH NOP CHECK
	MOV	#BTMSG-BTMSGP,R0
1$:	TSTB	@#TPS
	BPL	1$
2$:	MOVB	(R0)+,@#TPB
	BPL	1$
	BR .

BTMSG:	.BYTE	0,0,15,12,0,0,0,0,0,0,0,0,0,0
	.ASCII	/?B-NO BOOT ON VOLUME/
	.BYTE	15,12,200
	.EVEN
;*********************************************************

	.IF NDF	MBUILD
DODEL:	.DELETE	16,R5		;ZERO TAPE
	BCC	1$		;IF NO ERROR
2$:	JMP	ERRWRD		;OTHERWISE REPORT DIR ERROR
1$:	.CLOSE	0		;MAKE SURE CHANNEL 0 CLOSED
	.LOOKUP	0,R5		;LOOKUP MT OR CT
	BCS	2$		;STRANGE LOOKUP ERROR
	JSR	R5,SPFUN	;REWIND TAPE
	.BYTE	377,-5
	JSR	PC,SKPVL1	;IF MT,SKIP VOL1 1 LABEL
STLNK4:	JMP	START
	.IFF
DODEL:	JMP	HANERR		;IILLEGAL FOR MBUILD TO ZERO MT
	.ENDC

;SUBROUTINE SKPVL1
;IF DEVICE LAST DSTATUSED INTO DEVINF IS MT,ISSUES A
;SPFUN CALL TO SPACE FORWARD 1 BLOCK

SKPVL1:	CMPB	DEVINF,#TMIDEN	;TM11 MAGTAPE?
	BEQ	2$		;YES
	CMPB	DEVINF,#TJIDEN	;TJU16 MAGTAPE?
	BNE	1$		;NO-DONE
2$:	JSR	R5,SPFUN1	;YES-SPACE OVER VOL1 LABEL
	.BYTE	377,-2		;SPACE 1 BLOCK
	JSR	PC,LOCK		;LOCK USR
	MOV	R5,-(SP)	;SAVE R5
	MOV	USRBUF,R5	;POINT R5 TO USR BUFFER
	.READW	0,R5,#400	;READ BLOCK FOLLOWING VOL1
	BCC	4$		;NO ERROR
	JMP	BADDIR		;REPORT READ ERROR
4$:	CMP	(R5),#240	;WAS IT BOOT BLOCK?
	BEQ	3$		;MUST BE BOOT BLOCK:POSITION AFTER IT
	JSR	R5,SPFUN1	;NO-BACKUP AND POSITION BEFORE IT
	.BYTE	377,-3		;BACKSPACE ONE BLOCK
3$:	MOV	(SP)+,R5	;RESTORE R5
1$:	RTS	PC		;RETURN
	.IF NDF	MBUILD
	.SBTTL	BAD BLOCK SCAN 
BLKSCN:	TST	(R5)		;ANY DEVICE GIVEN?
ILLCM2:	BEQ	ILLCMD		;NO-ERROR
	TST	2(R5)		;IS FILE NAME GIVEN?
ILLCM1:	BNE	ILLCMD		;YES-PROBABLY A MISTAKE
	.DSTATU #OLNAME,R5	;GET DEVICE STATUS INFO
	TST	OLNAME		;IS DEVICE FILE STRUCTURED?
	BPL	ILLCMD		;NO-THIS IS A MISTAKE
	.LOOKUP	1,R5		;LOOKUP DEVICE
	BCC	BLKSC1
HANER2:	JMP	HANERR		;SHOULD NEVER GET HERE
BLKSC1:	CLR	R5		;R5 IS BLOCK #
	MOV	OLNAME+6,R4	;R4 IS BLOCK COUNT FOR DEVICE
3$:	.READW	1,R2,#400,R5	;READ A BLOCK INTO FREE CORE
	BCC	2$		;NO ERROR
				;ERROR
	CLR	DIRDES		;MAKE OUTPUT GO TO TTY
	MESSAGE	<"BLOCK">
	MOV	R5,R0		;COPY BLOCK # INTO R0
	JSR	PC,R8OUT	;PRINT BLOCK #
	MESSAGE <" (">
	MOV	R5,R0
	JSR	PC,R10OVT	;PRINT BLOCK NUMBER IN DECIMAL
	MESSAGE <".) IS BAD"<15><12>>
2$:	INC	R5		;BUMP BLOCK #
	DEC	R4		;DECREASE BLOCK COUNT
	BEQ	STLNK4		;IF ZERO,WE ARE ALL DONE
	BR	3$		;AND LOOP
	.SBTTL	COMPRESS
	.LIST
COMPRS:	JSR	PC,FGCHK	;MAKE SURE NO F JOB ACTIVE
	TST	(R5)		;ANY INPUT FILE ??
	BEQ	ILLCM2		;NO, BAD COMMAND
	CMP	DIRSIZ,#NLIMIT	;IS ARG TO /N TOO LARGE?
	BHI	ILLCM1		;YES-BAD COMMAND
	MOV	R5,R0		;PT R0 TO FILE
	JSR	PC,MTCACL	;ON MT OR CA OR CL,
	BR	HANER2		;DISALLOW SCRUNCH
	JSR	PC,LOCK		;LOCK USR IN CORE
	MOV	R4,R0		;SET TO CHECK OUTPUT DEVICE
	TST	(R4)		;WAS OUTPUT DEVICE GIVEN ?
	BEQ	1$		;NO. IT IS A 1-DEVICE SQUISH
	CMP	(R4),(R5)	;IS OUT DEV = IN DEV ?
	BNE	2$		;NO. IT IS A 2-DEVICE SQUISH
	CLR	(R4)		;SET 1-DEVICE FLAG
1$:	DEC	IGNORE		;SET /G IF NOT SET ALREADY
	MOV	R5,R0		;SET TO CHECK INPUT DEVICE
2$:	JSR	PC,SYSALL	;CHECK FOR SYSTEMS DEVICE
	COM	OUCHAN		;WRITE ON CHANNEL 0
	CLR	ASCII		;DON'T WANT SPLIT BUFFERS
	CLR	FBIN		;DON'T SPLIT BUFFERS
	JSR	PC,DFNBUF	;DEFINE BUFFERS
	MOV	SP,@NOCTLC	;DISABLE CTRL/C FOR COMPRESS
	MOV	R5,R2
	MOV	R4,(PC)+	;SAVE OUTPUT DEVICE NAME
OUTDEV:	0
	TST	(R4)		;2 DEVICE TRANSFER?
	BNE	DOSQ		;YES: IGNORE REARRANGING DIRECTORY
	CMP	R0,#1024.	;MUST HAVE AT LEAST THREE BUFFERS
	BHIS	10$		;    TO WORK WITH.
	JMP	COROVR		;NO CORE AVAILABLE
10$:	MOV	#TBUFF,R1	;SCAN DIRECTORY TO DETERMINE ORDER OF
				;DIRECTORY SEGMENTS.
	JSR	PC,GETDIR	;READ IN 1ST DIRECTORY SEGMENT
	MOV	-6(R5),R3	;GET COUNT OF ACTIVE SEGMENTS
	MOV	R3,(PC)+	;SAVE IT FOR LATER
NUMSEG:	.BLKW
	MOVB	#1,(R1)+	;HEAD OF THE LIST IS ALWAYS SEGMENT #1
1$:	MOVB	R0,(R1)+	;SAVE LINK TO NEXT SEGMENT
	DEC	R3		;COUNT SEGMENT
	BLE	2$		;END
	JSR	PC,RDDIR	;READ IN NEXT DIRECTORY SEGMENT
	BR	1$		;CONTINUE UNTIL ALL SEGMENTS HAVE BEEN
				;    READ IN.
2$:	CLR	R3		;START AT TOP OF TABLE
5$:	INC	R3		;NEXT ENTRY
3$:	CMP	R3,NUMSEG	;END OF LIST?
	BGE	DOSQ		;YEP. GO DO SQUISH
	CMPB	TBUFF-1(R3),R3	;IS LINK POINTED CORRECTLY?
	BEQ	5$		;YEP. CONTINUE
	MOV	R3,-(SP)	;SAVE M+1 (NEXT PHYSICAL SEG #)
	DEC	R3		;R3 = M AT THIS POINT
				; (M = CURRENT PHYSICAL SEG #)
	MOV	R3,R0		;GET SEGMENT 'M'
	JSR	PC,RDDIR
	MOV	USRBUF,R1
	TST	2(R1)		;LAST SEGMENT IN LINK?
	BNE	9$		;NOPE ITS OK TO PROCEED
	MESSAGE <?QST DIR?>	;DIR IS N.F.G. IF GET HERE
	BR	4$		;BUT TRY TO FINISH
9$:	MOV	(SP),2(R1)	;CHANGE LINK IN 'M' TO POINT TO
				; 'M+1'
4$:	MOV	R3,R0		;WRITE IT BACK OUT
	JSR	PC,DIRWR
	MOVB	TBUFF(R3),R0	;GET 'N' ('M' PREVIOUSLY POINTED TO N)
	MOVB	(SP),TBUFF(R3)	;UPDATE TABLE ENTRY TO REFLECT
				;THE NEW LINKAGES
	MOV	R0,R3		;SAVE N
	JSR	PC,RDDIR	;GET SEG 'N'
	MOV	INBUF,R5	;TEMP SPACE IS LOCATED (R1)
	MOV	@BLKEY,R1	;SAVE BLKEY SINCE DATA ISN'T GOING
				; INTO USR BUFFER
	MOV	(SP),R0
	JSR	PC,REDDIR	;READ SEG #M+1 INTO TEMP SPACE
	MOV	R1,@BLKEY	;RESTORE BLKEY
	MOV	R3,R0		;WRITE SEG #M+1 INTO SEG 'N'
	MOV	USRBUF,-(SP)	;SAVE USR ADDRESS
	MOV	INBUF,USRBUF	;POINT WRITE ROUTINE TO TEMP SPACE
	JSR	PC,DIRWR	;WRITE IT
	MOV	(SP)+,USRBUF	;RESTORE
	MOVB	TBUFF(R3),R0	;TBUFF(N) <=> TBUFF(M+1) EXCHANGE
	MOV	(SP),R1		;M+1 => R1
	MOVB	TBUFF(R1),TBUFF(R3)
	MOVB	R0,TBUFF(R1)

; START AT M+1 IN THE TABLE 'TBUFF' AND LOOK FOR THE ENTRY THAT
; LINKS TO M+1. WHEN IT IS FOUND CHANGE IT TO LINK TO 'N'. ALSO
; CHANGE THE LINK IN THE CORRESPONDING SEGMENT TO LINK TO 'N'.

7$:	CMPB	TBUFF(R1),(SP)	;ENTRY = M+1?
	BEQ	6$		;YES
	INC	R1
	CMPB	R1,NUMSEG	;CONTINUE UNTIL ALL ENTRIES ARE SEARCHED
	BLO	7$		;YEP
12$:	MOV	(SP)+,R3	;RESTORE R3 TO THE VALUE M+1
	BR	5$		;CONTINUE
6$:	MOV	R1,R0		;R1 IS SEG # TO CHANGE
	JSR	PC,RDDIR
	MOV	R1,R0		;SAVE SEG #
	MOV	USRBUF,R1
	MOV	R3,2(R1)	;LINK TO 'N'
	JSR	PC,DIRWR	;RE-WRITE IT
	BR	12$
;
DOSQ:
	CLR	R1		;CLEAR UNUSED BLOCKS COUNT
	SUB	#512.,BUFSIZ	;REMOVE A SEGMENT SIZE FROM THE CURRENT
	MOV	INBUF,(PC)+	;    FREE BUFFER AREA.
SECBUF:	0
	ADD	#1024.,INBUF
	ADD	#1024.,OUBUF
	MOV	R2,R5
	JSR	PC,GETDIR	;GET FIRST DIRECTORY BLOCK
	MOV	-(R5),OUBLK	;BEGIN WRITING AT THIS BLOCK
	MOV	R0,-(SP)	;SAVE LINK TO NEXT DIR BLOCK
	TST	(R4)		;IS THERE A DIFFERENT OUTPUT DEV ?
	BEQ	3$		;NO, JUST COMPRESS THIS DEVICE TO ITSELF
	MOV	R5,-(SP)	;SAVE INPUT DIRECTORY POINTER
	MOV	R4,R5		;SETUP POINTER TO OUTPUT DEVICE
	JSR	PC,OPNDIR	;SETUP CHKEY FOR OUTPUT DEVICE
	.REOPEN	1		;OPEN THE OUTPUT DEVICE ON CHANNEL 1
	MOV	#1,@BLKEY	;INITIALIZE DIR SEGMENT IN CORE NUMBER
	CLR	OUCHAN		;SETUP TO WRITE DIR ON CH. 1
	MOV	(SP)+,R5	;RESTORE INPUT DIR POINTER
	MOV	DIRSIZ,R0	;GET NUMBER OF DIR BLOCKS WANTED
	BEQ	3$		;NOT SPECIFIED, USE INPUT
	CMP	R0,-10(R5)	;TOO FEW FOR INPUT ?
	BLOS	3$		;YES, USE INPUT
	ASL	R0		;FIND FIRST OUTPUT BLOCK
	ADD	#DIRBLK,R0
	MOV	R0,OUBLK	;AND SET UP NUMBER
	BR	4$		;START THE SQUISH
3$:	MOV	-10(R5),DIRSIZ	;SET OUTPUT HIGHEST = INPUT HIGHEST
4$:	MOV	R5,R4		;SETUP DIRECTORY WRITE POINTER
	MOV	DIRSIZ,-10(R5)	;SET HIGHEST DIR SEGMENT
	MOV	(R5)+,INBLK	;REMEMBER WHER FILES BEGIN ON OLD COPY
	MOV	OUBLK,(R4)+	;STORE NEW FILE BEGINNING BLOCK
	MOV	R4,(PC)+	;CALCULATE END OF USR BUFFER
ENDUSR:	0
	ADD	#1024.-14,ENDUSR
	BR	NXTDB		;ENTER COMPRESS LOOP

;  READ NEXT DIRECTORY BLOCK, IF ANY, INTO CORE
;    IF END OF DIRECTORY, SQUISH IS DONE

NEXTDB:	MOV	(SP)+,R0	;RELATIVE POINTER TO NEXT DIR BLOCK
	MOV	SECBUF,R5	;READ NEXT DIRECTORY BLOCK INTO 2ND DIRECTORY
				;    BUFFER.
	MOV	@BLKEY,-(SP)	;SAVE TEMP
	JSR	PC,REDDIR
	MOV	(SP)+,@BLKEY	;RESTORE FOR OUTPUT'S USE
	TST	-(R5)		;POINT TO FILE BEGINING WORD
	MOV	R0,-(SP)	;SAVE LINK TO NEXT DIR BLOCK
	JSR	PC,CKEND	;CHECK ROOM IN DIRECTORY BEFORE PUTTING
				;    ANOTHER ENTRY INTO IT.
	MOV	(R5)+,INBLK	;BEGIN READING FROM THIS BLOCK
NXTDB:	CLR	R3		;CLEAR BLOCK TRANSFER COUNT
NXTDN3:	JSR	PC,CKEND	;CHECK ROOM IN DIRECTORY BEFORE PUTTING
				;    ANOTHER ENTRY INTO IT.
	MOV	10(R5),-(SP)	;GET NUMBER OF BLOCKS IN THIS ENTRY
	BIT	(R5),#DIRPRM	;IS IT A PERMANENT FILE ??
	BEQ	UNPERM		;NO
	CMP	6(R5),(PC)+	;IS THE EXTENSION .BAD ??
	.RAD50	"BAD"
	BNE	NOTBAD		;NO, GENERAL CASE
	JSR	PC,MOVFLS	;MOVE ANY FILES PREVIOUSLY PAST
	TST	OUCHAN		;DV1:=DV2:/S  ??
	BEQ	SKPBAD		;YES, TREAT .BAD LIKE UNUSED
	TST	R1		;IS THERE ANY EMPTY TO MAKE?
	BEQ	1$		;NO, AVOID CLOBBERING A GOOD ENTRY
	JSR	PC,MAKEMT	;GENERATE AN EMPTY
1$:	ADD	(SP),INBLK	;PUSH INPUT BLOCK POINTER OVER THE BAD
	CLR	(SP)		;AND DON'T LET HIM BUMP TRANSFER COUNT
	MOV	INBLK,OUBLK	;BEGIN WRITING AFTER .BAD FILE
	JSR	PC,CKEND	;CHECK ROOM IN DIRECTORY BEFORE PUTTING
				;    ANOTHER ENTRY INTO IT.
NOTBAD:	MOV	XTRABY,R0	;NUMBER OF EXTRA BYTES PER ENTRY
	ASR	R0		;MAKE IT A WORD COUNT
	ADD	#7,R0		;NUMBER OF WORDS IN ENTRY TO MOVE
3$:	MOV	(R5)+,(R4)+	;MOVE THE ENTRY
	DEC	R0
	BNE	3$
	ADD	(SP)+,R3	;INCREMENT NUMBER OF BLOCKS IN TRANSFER
	BR	NXTDN3		;PROCESS NEXT ENTRY

;  EMPTY DIRECTORY SLOT FOUND
;  MOVE ANY CHUNK OF FILES FOUND SO FAR,
;    THEN PUSH THE INPUT BLOCK POINTER PAST THE EMPTY
;      AND SKIP OVER IT

UNPERM:	JSR	PC,MOVFLS	;MOVE FILES ON ANY NON PERMANENT
	BIT	(R5),#DIREOB	;IS IT THE END OF BLOCK
	BNE	DBDONE		;YES
	ADD	(SP),R1		;INCREMENT NUMBER OF UNUSED BLOCKS
SKPBAD:	ADD	(SP)+,INBLK	;INCREMENT READ POINTER BY UNUSED
	ADD	#16,R5		;SKIP REST OF THIS ENTRY
	ADD	XTRABY,R5
	BR	NXTDN3

;  END OF DIRECTORY BLOCK
;  EOB ENTRIES HAVE NO SIZE, SO THE SIZE IS PURGED FROM THE STACK
;  IF THIS IS THE LAST SEGMENT, AN EMPTY ENTRY IS CREATED
;    WHICH IS THE SIZE OF ALL ACCUMULATED FREE SPACE
;  THE EOB MARKER IS MADE, AND THE SEGMENT IS WRITTEN

DBDONE:	TST	(SP)+		;PURGE ENTRY SIZE FROM STACK
	TST	(SP)		;IS THIS THE LAST BLOCK ??
	BNE	NEXTDB		;NO, READ IN NEXT SEGMENT THEN
	MOV	DEVINF+6,R1	;GET TOTAL SIZE OF OUTPUT DEVICE
	SUB	OUBLK,R1	;MINUS THE NUMBER OF BLOCKS USED
	JSR	PC,MAKEMT	;CREATE AN EMPTY OF THIS SIZE
	MOV	#DIREOB,(R4)	;PUT IN EOB MARKER
	MOV	USRBUF,R4	;SHOW LAST SEGMENT IN CHAIN
	CLR	2(R4)
	JSR	PC,WRDIR	;WRITE OUT THIS DIR BLOCK
 
; COMPRESS FINISHED, NOW FIX UP WORD 3 OF SEGMENT #1 TO CONTAIN
; THE HIGHEST ACTIVE SEGMENT # IN USE.
 
	MOV	@BLKEY,R2	;GET LAST SEGMENT # USED
	CLR	@BLKEY
	CLR	@CHKEY
	MOV	OUTDEV,R5
	TST	(R5)		;TWO DEVICE SQUISH?
	BNE	1$		;YES
	MOV	#1,R0		;NO: READ IN FIRST DIRECTORY SEGMENT
	JSR	PC,RDDIR	;    AGAIN.
	BR	2$
1$:	.CLOSE	0		;CLOSE OUT CHAN #0
	JSR	PC,GETDIR	;GET THE FIRST DIRECTORY SEGMENT
				;    FROM OUTPUT CHANNEL.
2$:	MOV	USRBUF,R1	;UPDATE HIGHEST ACTIVE SEGMENT #
	MOV	R2,4(R1)
	JSR	PC,WRDIR	;NOW WRITE IT BACK OUT
	JMP	STLNK3		;COMPRESS COMPLETE

;  HERE WE MOVE A CHUNK OF FILES WHICH WERE FOUND BETWEEN EMPTIES
;  IF IT IS A ONE-DEVICE SQUISH AND THE INPUT AND OUTPUT BLOCK NUMBERS
;    ARE THE SAME, NO I/O IS DONE.
;  OTHERWISE, THE BLOCKS ARE TRANSFERRED AS ONE BIG CHUNK

MOVFLS:	TST	OUCHAN		;IS IT A TWO DEVICE COMPRESS ??
	BEQ	2$		;YES, COPY ALWAYS
	CMP	INBLK,OUBLK	;ARE READ AND WRITE BLOCKS THE SAME ??
	BNE	2$		;NO, DO THE MOVE
	ADD	R3,INBLK	;OTHERWISE JUST BUMP BLOCK NUMBERS
	ADD	R3,OUBLK
1$:	CLR	R3		;CLEAR BLOCK TRANSFER COUNT
	RTS	PC
2$:	TST	R3		;ANY MORE BLOCKS TO MOVE ?
	BLE	1$		;NO
	MOV	BUFSIZ,R0	;SIZE OF BUFFER
	SWAB	R0		;MAKE IT A BLOCK COUNT
	SUB	R0,R3		;DOES IT ALL FIT IN CORE ??
	BCC	3$
	ADD	R3,R0		;YES, ONLY TRANSFER THAT AMOUNT
3$:	SWAB	R0		;MAKE IT A WORD COUNT AGAIN
	JSR	PC,READN	;READ N BLOCKS
	JSR	PC,WRITE	;THEN WRITE THEM
	BCC	2$		;OUT OF ROOM OR OUTPUT ERROR
	.PRINT	#OUMES		;TELL HIM ABOUT AN OUTPUT ERROR
	TST	OUCHAN		;ONE DEVICE SQUISH ?
	BNE	2$		;YES, PUSH ONWARD
	CLR	@BLKEY
	CLR	DIRSIZ
	CLR	ZXTRA
	JMP	ZERIT
 
; CHECK ROOM IN DIRECTORY BLOCK BEFORE PUTTING ANOTHER ENTRY INTO IT.
; IF FULL, WRITE BLOCK OUT AND RESET WRITE BUFFER POINTERS.
 
CKEND:	MOV	XTRABY,-(SP)	;MAKE SURE THERE'S ROOM FOR AN ADDITIONAL ENTRY
	ADD	#16,(SP)
	ADD	R4,(SP)
	CMP	(SP)+,ENDUSR
	BLOS	1$		;ROOM LEFT:  RETURN
				;NO:  CLEAN UP THIS SEGMENT, WRITE IT
				;    OUT AND START ANOTHER ONE.
	JSR	PC,MOVFLS	;MOVE FILES ACCUMULATED SO FAR
	MOV	USRBUF,R0	;INSERT LINKAGE TO NEXT SEGMENT
	MOV	@BLKEY,R2
	INC	R2
	MOV	R2,2(R0)
	MOV	#DIREOB,(R4)	;SET "END OF BLOCK" ID
	JSR	PC,WRDIR	;WRITE OUT DIRECTORY SEGMENT
	MOV	USRBUF,R4	;RESET POINTER TO BEGINNING OF BLOCK
				;    TO START NEW SEGMENT.
	ADD	#10,R4		;UPDATE FILE STARTING BLOCK
	MOV	OUBLK,(R4)+
	INC	@BLKEY		;SHOW THAT NEXT SEGMENT IS THE ONE WE'RE
1$:	RTS	PC		;    GOING TO WORK ON NEXT.
 
TBUFF:	.BLKW	20		;STORAGE AREA FOR MAP OF DIRECTORY
				;    SEGMENTS PRIOR TO SHUFFLING.
SAVBLK	=	.-1		;SAVED BLOCK NUMBER DURING SHUFFLING
	.NLIST
	.SBTTL	EXTEND
EXTEND:	TST	(R4)		;IS  THERE AN OUTPUT DEVICE
	BEQ	STLNK3		;NO
	MOV	R4,R0		;CHECK FOR .SYS AND .BAD
	JSR	PC,SYSCHK	;DON'T EXTEND THEM WITHOUT /Y
	BEQ	STLNK3		;NO GOOD
	JSR	PC,MTCA
	NOP			;FILLER FOR RETURN
	CMPB	(R0),#CLIDEN	;SOME THINGS JUST CANNOT BE DONE
	BEQ	STLNK3		;AND THIS IS ONE OF THEM
	JSR	PC,LOCK		;LOCK USR IN CORE
	MOV	SP,@NOCTLC	;DISABLE CTL/C FOR EXTEND
EXTTRY:	COM	OUCHAN		;PREPARE TO WRITE ON CHANNEL 0
	MOV	#DEVNAM,R5	;OPEN DEVICE AS NON FILE STRUCTURED
	MOV	(R4),(R5)	;PUT IN DEVICE NAME
	JSR	PC,GETDIR	;GET FIRST DIRECTORY BLOCK
	MOV	10(R4),R1	;DESIRED SIZE OF FILE
	BR	LTSTEB		;BEGIN SEARCHING FOR FILE
LOCATE:	TST	R0		;IS THIS THE LAST DIR BLOCK ??
	BEQ	EXTNEW		;YES, CREATE FILE
	JSR	PC,RDDIR	;READ NEXT DIRECTORY BLOCK
	BR	LTSTEB		;BEGIN SEARCHING THIS BLOCK
LSKP14:	TST	(R5)+		;SKIP FIRST WORD OF NAME
LSKP12:	TST	(R5)+		;SKIP SECOND WORD OF NAME
LSKP10:	TST	(R5)+		;SKIP EXTENSION WORD
LSKP6:	ADD	#6,R5		;SKIP SIZE WORDS AND DATE
	ADD	XTRABY,R5	;SKIP EXTRA WORDS
LTSTEB:	BIT	#DIREOB,(R5)	;IS THIS THE END OF BLOCK ??
	BNE	LOCATE		;YES, GET NEXT BLOCK
	BIT	#DIRPRM,(R5)+	;IS THIS A PERM FILE ??
	BEQ	LSKP14		;NO, SKIP TO NEXT ENTRY
	CMP	2(R4),(R5)+	;CHECK FIRST WORD OF NAME
	BNE	LSKP12		;NO MATCH
	CMP	4(R4),(R5)+	;CHECK SECOND WORD
	BNE	LSKP10		;NO MATCH
	CMP	6(R4),(R5)+	;CHECK EXTENSION
	BNE	LSKP6		;NO MATCH
	SUB	(R5)+,R1	;AMOUNT NEEDED
	BCS	EXTNEG		;NEGATIVE EXTEND ??
	MOV	R5,-(SP)	;SAVE POSITION (IN CASE WE SWITCH
	MOV	@BLKEY,-(SP)	;                    DIRECTORY BLOCKS)
	CMP	(R5)+,(R5)+	;SKIP DATA SIZE AND DATE
	ADD	XTRABY,R5	;SKIP XTRA WORDS
	BIT	#DIREOB,(R5)	;IS NEXT THING AN END OF BLOCK ??
	BEQ	NOEEB		;NO
	TST	R0		;LAST SEGMENT ?
	BEQ	EXTROM		;YES, NO CAN DO
	JSR	PC,RDDIR	;YES, READ NEXT DIRECTORY BLOCK
NOEEB:	BIT	#DIREMP,(R5)	;IS NEXT THING AN EMPTY (<UNUSED>) ??
	BEQ	EXTROM		;NO, ERROR
	SUB	R1,10(R5)	;THIS IS THE EXCESS
	BCS	EXTROM		;NOT ENOUGH ROOM
	CMP	(SP),@BLKEY	;IS EMPTY IN SAME BLOCK AS FILE ??
	BEQ	SAMDB		;YES, SAME DIRECTORY BLOCK
	JSR	PC,WRDIR	;NO, WRITE FIRST MODIFIED BLOCK
SAMDB:	MOV	(SP)+,R0	;GET BLOCK NUMBER OF FIRST DIR BLK
	JSR	PC,RDDIR	;READ BLOCK CONTAINING FILE
	MOV	(SP)+,R5	;RESTORE POINTER TO SIZE OF FILE
	ADD	R1,-(R5)	;MODIFY THIE SIZE
	JSR	PC,WRDIR	;WRITE OUT THIS MODIFIED BLOCK
STLNK3:	JMP	START		;BACK TO PIP
EXTNEW:	INC	OUCHAN		;WORK WITH CHANNEL 1
	MOV	R4,R0		;CREATE A NEW FILE
	JSR	PC,ENTER	;ENTER IT
	BEQ	STLNK3		;.SYS OR .BAD
	.CLOSE	0		;CLOSE DIRECTORY
	.CLOSE	1		;CLOSE THE FILE
	BR	EXTTRY		;AND DO IT AGAIN RIGHT
EXTNEG:	ERROR	<EXT NEG>
EXTROM:	ERROR	<ROOM>
	.ENDC
	.SBTTL	BOOTSTRAP COPY
;BOOT COPY PROVIDES A METHOD OF TRANSFERRING THE RT-11
;BOOTSTRAP BLOCKS BETWEEN DEVICES. THE SYNTAX IS:
;	*ODEV:FILE=IDEV:BOOTF/U
;THE INPUT FILE IS A FILE WHICH CONTAINS THE RT-11
;BOOTSTRAP BLOCKS IN BLOCKS 0 AND 1. BOOT COPY READS THESE
;TWO BLOCKS AND WRITES THEM INTO BLOCKS 0 AND 2 OF THE
;OUTPUT DEVICE. USUALLY, THE INPUT FILE WILL BE MONITR.SYS.

BOOT:	MOV	R4,R0		;PT R0 TO FILE
	JSR	PC,MTCA		;IF MT OR CT,
	BR	BADBOT		;DISALLOW BOOT
	JSR	PC,DFNBUF	;DEFINE BUFFERS
	CMP	R0,#1000	;NEED TWO BLOCKS AT LEAST
	BLO	COROVR		;NOT ENOUGH BUFFER
	TST	(R4)		;IS THERE AN OUTPUT DEVICE
	BEQ	BADBOT
	JSR	PC,LOOKUP	;OPEN INPUT FILE ON CH. 0
	CLR	2(R4)		;OPEN OUTPUT AS NON-FILE DEVICE
	.LOOKUP	1,R4		;OPEN CHANNEL 1 FOR OUTPUT
	.IF DF	MBUILD
	JSR	PC,FATERR	;CHECK TO SEE IF FATAL ERROR
	.ENDC
	BCS	BADBOT
	MOV	#1000,R0	;READ 2 BLOCKS
	JSR	PC,READN
	CLR	OUBLK		;WRITE BLOCK 0
	MOV	#400,R0		;ONE BLOCK
	JSR	PC,WRITE
	BCS	1$		;ERROR ON WRITE
	MOV	#2,OUBLK	;AND NOW BLOCK 2
	ADD	#1000,OUBUF	;SECOND RECORD
	JSR	PC,WRITE
	.IF NDF	MBUILD
	BCC	STLNK3		;IF NO ERRORS,WE ARE DONE
	.IFF
	BCS	1$		;REPORT ERROR
	JMP	START		;IF NO ERRORS,WE ARE DONE
	.ENDC
1$:	JMP	OUTER
BADBOT:	ERROR	<BOOT COPY>
	.IF NDF	MBUILD
	.SBTTL	VERSION
VERSON:	.PRINT	#VMESAG		;TELL HIM OUR VERSION NUMBER
	BR	STLNK3		;BACK TO PIP
VMESAG:	.ASCIZ	"PIP V04-06  "
	.ENDC
 	.EVEN
	.SBTTL	DFNBUF   (DEFINE BUFFER(S))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	DFNBUF IS ENTERED WITH R2 POINTING TO THE START OF THE
;	AVAILABLE BUFFER SPACE. BUFFER ALLOCATION IS DONE
;	DEPENDING ON THE AMOUNT OF AVAILABLE CORE AND ON THE
;	ASCII SWITCH. INBUF, OUBUF, OUBUFE, AND BUFSIZ ARE SET
;	AND CHECKS ARE MADE FOR INSUFFICIENT BUFFER SPACE.
;	REGISTER 2 IS LEFT POINTING AT THE START OF THE OUTPUT
;	BUFFER.  R0 IS USED AS A TEMPORARY.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DFNBUF:	MOV	USRBUF,R0	;POINTER TO USR DIRECTORY BUFFER
	MOV	R2,INBUF	;SAVE START OF INPUT BUFFER
	SUB	R2,R0		;TOTAL SPACE FOR BUFFERS
	BCS	COROVR		;NO ROOM FOR BUFFER(S)
	BIC	#777,R0		;ROUND TO BLOCKS
	.IF NDF	MBUILD
	MOV	ASCII,-(SP)	;IF IT IS NEITHER ASCII
	BIS	FBIN,(SP)+	;  NOR FORMATTED BINARY
	BEQ	1$		;    THEN WE NEED BUT ONE BUFFER
	BIC	#1000,R0	;SINCE WERE SPLITTING,NEED EVEN # OF BLOCKS
	ROR	R0		;HALVE THE BUFFER SIZE (/A USES 2)
	ADD	R0,R2		;GET START ADDR OF OUTPUT BUFFER
	.ENDC
1$:	MOV	R2,OUBUF	;SAVE START ADDRESS OF OUTPUT BUFFER
	MOV	R2,(PC)+	;GET ENDING ADDRESS OF OUTPUT BUFFER
OUBUFE:	0
	ADD	R0,OUBUFE
	ROR	R0		;GET SIZE OF BUFFER(S) IN WORDS
	MOV	R0,BUFSIZ	;SAVE IT
	BNE	RTSPC		;RETURN OK IF BUFFERS NON-ZERO
COROVR:	ERROR	<COR OVR>	;NO ROOM IN CORE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	CORCHK IS ENTERED WITH R2 POINTING TO START OF AVAILABLE
;	CORE.  WE CHECK IF THERE IS ENOUGH ROOM FOR A SAVESTATUS
;	BLOCK, OR FOR A MT/CT FILENAME, OR FOR THE NEXT FILE
;	NAME IN AN INPUT EXPANSION. ALL THREE ARE CHECKED BY
;	INSURING THERE IS AT LEAST 12. BYTES OF FREE CORE LEFT.
;	CALLED FROM INPUT EXPANDER AND FROM COPY ROUTINE. (BC)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CORCHK:	MOV	USRBUF,-(SP)	;USE SAME CHECK THAT DFNBUF USES	;###
	MOV	R2,-(SP)	;PUT FREE CORE PTR ON STACK		;###
	ADD	#14,(SP)	;ADD 14 TO FREE CORE PTR-NEED 6 WDS	;###
	SUB	(SP)+,(SP)+	;DO THE SUBTRACT 			;###
	BCC	RTSPC		;IF CC-ENUF ROOM-JUST RETN.		;###
	BR	COROVR		;NOT ENUF ROOM-GIVE CORE MSG		;###
	.SBTTL	OEXPND   (EXPAND OUTPUT LIST)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	OEXPND EXAMINES THE CURRENT OUTPUT FILE ENTRY FOR A POSSIBLE
;	WILD CARD (*) CHARACTER IN EITHER THE FILE NAME OR EXTENSION.
;	IF SUCH EXISTS, THE CORRESPONDING PART OF THE CURRENT INPUT
;	FILE IS MOVED INTO THE OUTPUT FILE DESCRIPTOR. THE NEW
;	OUTPUT FILE DESCRIPTOR IS STORED IN THE FOUR WORD BLOCK
;	NEWNAM. THE ROUTINE IS ENTERED WITH R4 POINTING TO THE
;	CURRENT OUTPUT FILE AND R5 POINTING TO THE CURRENT INPUT
;	FILE. THE OUTPUT LIST POINTER IS INCREMENTED AS REQUIRED. ONE
;	CALL TO OEXPND PRODUCES ONE OUTPUT FILE. R0 IS USED AS
;	A TEMPORARY.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OEXPND:	CLR	R0		;CLEAR OUTPUT LIST BACKUP COUNT
	CMP	R4,#FILDES+36	;ARE WE GETTING INTO INPUT COUNTRY?
	BHIS	BADOUF		;  THAT'S A NO-NO
	MOV	#NEWNAM,R3	;POINTER TO SPACE FOR NEW NAME
	MOV	(R4)+,(R3)+	;COPY DEVICE NAME
	CMP	(R4),#R50STAR	;IS FILE NAME *  ??
	BNE	1$		;NO
	MOV	2(R5),(R3)+	;YES, SUBSTITUTE NAME FROM INPUT LIST
	MOV	4(R5),(R3)+	;(TWO WORDS)
	CMP	(R4)+,(R4)+	;MOVE OUTPUT LIST POINTER TO EXTENSION
	MOV	#12,R0		;SET BACKUP COUNT
	BR	2$		;GO CHECK EXTENSION
1$:	MOV	(R4)+,(R3)+	;COPY NAME FROM OUTPUT LIST
	MOV	(R4)+,(R3)+
2$:	CMP	(R4),#R50STAR	;IS EXT .*  ??
	BNE	3$		;NO
	MOV	6(R5),(R3)+	;YES, USE EXTENSION FROM INPUT LIST
	TST	(R4)+		;BUMP OUTPUT LIST POINTER
	MOV	#12,R0		;SET OUTPUT LIST BACKUP COUNT
	BR	4$
3$:	MOV	(R4)+,(R3)+	;EXT IS OK, COPY IT
4$:	TST	(R4)+		;SKIP OUTPUT FILE SIZE FROM CSI
	SUB	R0,R4		;SUBTRACT BACKUP COUNT
RTSPC:	RTS	PC		;RETURN OUTPUT FILE NAME IN NEWNAM
	.SBTTL	ENTER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	ENTER IS USED TO DO AN RT-11 ENTER OF THE FILE WHO'S
;	NAME IS POINTED TO BY R0. CHECKS ARE MADE FOR ALL KNOWN
;	ILLEGAL CASES (* IN FILE NAME OR EXTENSION OR NULL FILE).
;	OUCHAN CONTAINS THE CHANNEL NUMBER TO BE USED FOR THE
;	FILE. ATTEMPTS TO ENTER A .SYS OR .BAD FILE WITHOUT A
;	/Y WILL CAUSE ENTER TO RETURN WITH Z=1. A SUCCESSFUL
;	ENTER RETURNS WITH Z=0  (BEQ FAILS). OUBLK IS CLEARED
;	TO INITIALIZE WRITE.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENTER:	TST	(R0)		;ANY FILE TO ENTER
	BEQ	2$		;NO, RETURN WITH Z=1
	CMP	2(R0),#R50STAR	;IS NAME * ??
	BEQ	BADOUF		;YES, BAD OUTPUT FILE
	CMP	6(R0),#R50STAR	;HOW ABOUT THE EXT ??
	BEQ	BADOUF		;YUP, ITS BAD
	TST	2(R0)		;NULL NAME?
	BNE	1$		;NO-OK
	MOV	R0,-(SP)	;YES-SAVE R0
	.DSTATU	#DEVINF		;GET DEVICE STATUS
	.IF DF	MBUILD
	JSR	PC,FATERR	;CHECK TO SEE IF FATAL ERROR
	.ENDC
	TST	DEVINF		;FILE STRUCTURED?
	BMI	BADOUF		;YES-DISALLOW THE ENTER
	MOV	(SP)+,R0	;RESTORE R0
1$:	JSR	PC,SYSCHK	;DON'T WRITE .SYS FILE UNLESS /Y
2$:	BEQ	RTSPC		;.BAD OR .SYS    RETURN WITH Z=1
	MOV	10(R0),-(SP)	;PUSH SIZE
	CLR	OUBLK		;SET OUTPUT FILE BLOCK NUMBER TO 0
	JSR	PC,TSTNUM	;SET UP REST OF LIST
	MOV	(SP)+,FLEN	;RETRIEVE LENGTH
	MOV	#2*400,(R0)	;INSERT ENTER CODE (2) IN HI BYTE
	MOVB	OUCHAN,(R0)	;CHANNEL IN LO BYTE
	INCB	(R0)
	EMT	375
	.IF DF	MBUILD
	JSR	PC,FATERR	;CHECK TO SEE IF FATAL ERROR
	.ENDC
	BCS	3$		;ENTER BAD-REPORT ERROR
	JMP	CLZRTS		;ENTER OK,RETURN AFTER CLZ
3$:	ERROR	<DEV FUL>
BADOUF:	ERROR	<OUT FIL>
	.SBTTL	LOOKUP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	LOOKUP DOES AN RT-11 LOOKUP OF THE FILE WHO'S NAME IS
;	POINTED TO BY R5. THIS REGISTER IS THEN INCREMENTED PAST
;	THE FILE DESCRIPTOR. LOOKUP INITIALIZES READ AND READC BY
;	CLEARING INBLK AND INBUFE.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LOOKUP:	MOV	R5,R0		;GET FILE DESCRIPTOR POINTER
	CLR	INBLK		;INITIALIZE INPUT FILE BLOCK NUMBER
	.IF NDF	MBUILD
	CLR	INBUFE		;INITIALIZE READC ROUTINE
	.ENDC
	ADD	#10,R5		;BUMP INPUT LIST POINTER
	JSR	PC,TSTNUM	;GET XTRA ARG FOR MT AND CA
	MOV	#1*400,(R0)	;SET CODE TO LOOKUP, CHANNEL 0
	EMT	375		;THEN DO V2 LOOKUP
	.IF DF	MBUILD
	JSR	PC,FATERR	;CHECK TO SEE IF FATAL ERROR
	.ENDC
	BCC	RTS7		;LOOKUP OK, RETURN
	ADD	(PC)+,(PC)	;ON ERROR CLOSE LAST OUTPUT CHANNEL
	.CLOSE	1		;IN CASE MT OR CA, BECAUSE THESE PRECEDE LOOKUPS
LCHAN:	HALT			;IGNORE POSSIBLE ERROR ON CLOSE
	ERROR	<FIL NOT FND>
	.SBTTL	READ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	READ IS USED TO READ BUFSIZ NUMBER OF WORDS FROM THE INPUT
;	FILE CURRENTLY OPEN ON CHANNEL 0. INBLK IS THE RELATIVE 
;	BLOCK NUMBER, AND INBUF IS THE BUFFER ADDRESS. IF THE READ
;	IS COMPLETELY SUCCESSFUL, READ RETURNS WITH Z=0 (BEQ FAILS)
;	AND THE ACTUAL NUMBER OF WORDS READ IN R0. THIS MAY BE LESS
;	THAN BUFSIZ IF THE READ OVERLAPPED THE END OF FILE. IF THE
;	READ IS UNSUCCESSFUL (EOF ENCOUNTERRED) Z=1 UPON RETURN
;	SIGNALING THAT NOTHING WAS READ. READ WILL IGNORE HARD
;	INPUT ERRORS IF THE /G SWITCH WAS SPECIFIED. READ WILL
;	INCREMENT THE INPUT FILE BLOCK NUMBER (INBLK) BY THE
;	NUMBER OF BLOCKS TRANSFERRED. READN WILL READ THE NUMBER
;	OF WORDS IN R0.
;	BEFORE BEGINNING THE READ OPERATION,A SPECIAL CASE CHECK IS
;	MADE TO SEE IF THE INPUT DEVICE IS CASSETTE OR MAGTAPE.
;	IF IT IS,THE BUFFER SIZE IS REDUCED TO 256 WORDS,TO PREVENT
;	FILE ELONGATION BY EXTRA NULLS DURING THE TRANSFER. A FURTHER SPECIAL
;	CASE CHECK IS MADE FOR CASSETTE,AND IF CASSETTE IS THE INPUT
;	DEVICE,THE 256 WORD BUFFER IS "READ" BY FOUR SMALLER READS TO
;	THE CASSETTE OF ONE RECORD EACH (64 WORDS). THIS IS NECESSARY TO
;	PROPERLY DETECT END-OF FILE,WHICH MAY COME AFTER AN ODD NUMBER
;	OF RECORDS ON CASSETTE.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
READ:	MOV	2(SP),R0	;GET PTR TO CORE BLOCK
RCOM:	MOV	@#SYSPTR,-(SP)	;POINT TO RMON
	ADD	#6,(SP)		;SKIP TO STARTING BLOCK NUMBER CHAN 0
	TST	@(SP)+		;IF 0 THEN SEQUENTIAL
	BNE	CORBL		;ELSE FILE STRUCTURED
	MOV	#256.,BUFSIZ	;FOR NON-FILE STRUCTURED DO 1 BLOCK TRANSFERS
	MOV	OUBUF,OUBUFE
	ADD	#1000,OUBUFE	;RESET OUTPUT BUFFER LIMITS
	TST	10(R0)		;TEST 5TH WORD IN STATS TABLE
	BPL	CORBL		;MUST BE PR,TT,CL,3M,ETC.
	.DSTATU	#DEVINF		;DETERMINE CURRENT INPUT DEVICE
	CMPB	DEVINF,#CTIDEN	;IS IT TA11?
	BNE	CORBL		;NO
	.IF NDF	MBUILD
	MOV	INBUF,CTBADD	;YES-SET UP BUFFER ADDRESS
1$:	MOV	#READBK,R0	;POINTER TO ARG LIST IN R0
	EMT	375		;V2 READ CALL
	BCC	4$		;ERROR MUST BE HARD
	JSR	PC,RDERR	;SEE IF EOF OR HARD ERROR
	BEQ	RTS7		;EOF
4$:	MOV	@#SYSPTR,R0	;BASE ADDR OF RESIDENT INTO R0
	MOV	4(R0),SSB	;CSW FOR CHANNEL 0 INTO SSB
	BIT	#CSWEOF,SSB	;DID LAST READ DETECT EOF?
	BNE	2$		;YES-IGNORE LAST RECORD
	ADD	#64.*2,CTBADD	;NO-BUMP BUFFER ADDR OVER NEW MATERIAL
2$:	MOV	CTBADD,R0	;ADDR OF NEXT BUFFER INTO R0
	SUB	INBUF,R0	;DETERMINE HOW MANY BYTES READ SO FAR
	ROR	R0		;MAKE INTO WORDS
	BEQ	SEZRTS		;IF NOTHING WAS READ AT ALL,WE HAVE LOGICAL EOF
	BIT	#CSWEOF,SSB	;DID LAST READ DETECT EOF?
	BNE	CLZRTS		;YES-RETURN WHAT WE HAVE SO FAR
	CMP	R0,#256.	;IS BUFFER COMPLETE YET
	BLT	1$		;NO-READ NEXT RECORD
	BR	CLZRTS		;"READ" COMPLETE;WC IS IN R0


;AREA PACKET FOR CASSETTE READ
READBK:	.BYTE	0,10		;READW ON CHANNEL 0
	1			;BLOCK # ALWAYS 1
CTBADD:	0			;BUFFER ADDR
	64.			;WORD COUNT = 64 WORDS
	0			;WAIT MODE

	.IFF
	HALT			;IMPOSSIBLE TO GET HERE
	.ENDC

CORBL:	MOV	(PC)+,R0	;ELSE, READ A BUFFER LOAD
BUFSIZ:	0
READN:	CLR	-(SP)		;USE WAIT I/O
	MOV	R0,-(SP)	;PUSH WORD COUNT
	MOV	(PC)+,-(SP)	;PUSH BUFFER ADDRESS
INBUF:	0
	MOV	(PC)+,R0	;GET RELATIVE BLOCK NUMBER
INBLK:	0
	.READ	0		;READ CHANNEL 0
	ROR	-(SP)		;SAVE CARRY BIT FOR ERROR CHECK
	SWAB	R0		;NUMBER OF BLOCKS ACTUALLY READ
	ADD	R0,INBLK	;INCREMENT RELATIVE BLOCK NUMBER
	SWAB	R0		;RESTORE IT TO A WORD COUNT
	TST	(SP)+		;DID READ GIVE ERROR ?
	BMI	RDERR		;YES, CHECK ON IT
	MOV	R0,-(SP)	;SAVE WORD COUNT
	MOV	@#SYSPTR,R0	;BAS OF MONITR INTO R0
	MOV	4(R0),SSB	;FIRST WORD OF $CSW FOR CHANNEL 0 NTO SSB
	MOV	(SP)+,R0	;RESTORE COUNT
	BIT	#CSWEOF,SSB	;DID LAST READ RESULT IN NFS EOF?
	BEQ	CLZRTS		;BIT OFF MEANS MORE TO COME
SEZRTS:	SEZ			;BIT ON MEANS EOF FOR CT OR MT
	RTS	PC
CLZRTS:	CLZ			;CLEAR EOF INDICATOR
RTS7:	RTS	PC
RDERR:	TSTB	@#EMTERR	;WHAT KIND OF ERROR ??
	BEQ	RTS7		;RETURN WITH COND CODES =0
	.IF NDF	MBUILD
	TST	IGNORE		;SHOULD WE IGNORE IT (/G)
	BGT	CLZRTS		;YES, REGULAR IGNORE
	BEQ	EBOMB		;NO, BOMB ON ERROR
	MOV	R0,-(SP)	;SAVE ACTUAL COUNT
	.PRINT	#INERR		;SQUISH! PRINT, BUT CONTINUE
RR0RTS:	MOV	(SP)+,R0	;RESTORE COUNT
	BR	CLZRTS		;SO RETURN
	.ENDC
EBOMB:	JSR	R0,MSG		;PRINT AN ERROR AND DIE
.NLIST	BEX
INERR:	.ASCIZ	"?IN ER?"
.LIST	BEX
	.IF NDF	MBUILD
	.SBTTL	READC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	READC IS USED TO READ CHARACTERS FROM THE CURRENT INPUT FILE
;	(OPEN ON CHANNEL 0). R1 IS USED AS THE BUFFER POINTER
;	AND THE CHARACTERS ARE RETURNED ONE AT A TIME IN R0 AS SEVEN
;	BIT ASCII. READC USES READ TO DO THE ACTUAL READING.
;	IF THE EOF IS ENCOUNTERRED, READC RETURNS WITH
;	Z=1  (BNE FAILS).
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
READC:	CMP	R1,(PC)+	;IS BUFFER EMPTY ??
INBUFE:	0
	BLO	1$		;NO, DON'T READ
	MOV	2(SP),R0
	JSR	PC,RCOM		;EMPTY BUFFER, READ SOME
	BEQ	2$		;END OF FILE
	MOV	INBUF,R1	;RESET BUFFER POINTER
	ASL	R0		;GET ACTUAL NUMBER OF BYTES READ
	ADD	R1,R0		;NOW GET ADDR OF END OF BUFFER
	MOV	R0,INBUFE	;SAVE THIS
1$:	MOVB	(R1)+,R0	;GET A CHARACTER FROM THE FILE
	BIC	#177600,R0	;MAKE IT SEVEN BIT
	BEQ	READC		;IGNORE NULLS
	CMP	R0,#177		;IS IT A RUBOUT ??
	BEQ	READC		;YES, IGNORE IT
	CMP	R0,#32		;IS IT CTRL/Z? (NE RETURNS CHAR,EQ RETURNS EOF)
2$:	RTS	PC		;RETURN CHARACTER
	.SBTTL	FORMATTED BINARY READ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	READB IS USED TO READ FORMATTED BINARY FILES
;	IT WILL DISCARD ANY DATA BEFORE THE BYTE 001
;	MARKING THE FIRST BLOCK
;	USED REGISTERS 0,1, AND 4
;	PLEASE NOTE, REGISTER 4 MUST BE INITALLY SET TO FIRSTBY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
READB:	CMP	R1,INBUFE	;END OF BUFFER?
	BLO	2$		;NO
	MOV	2(SP),R0	;GET PTR TO CORE BLOCK
	JSR	PC,RCOM		;READ SOME MORE DATA
	BEQ	NFIL		;END OF FILE
	MOV	INBUF,R1
	ASL	R0		;MAKE WORD COUNT , BYTE COUNT
	ADD	R1,R0		;THIS IS END OF INPUT BUFFER
	MOV	R0,INBUFE	;
2$:	MOV	@R4,PC		;THIS IS A JMP IN DISGUISE
BYTE1:	DECB	(R1)+		;IS THIS BYTE AN 001 ?
	BNE	READB		;WELL, NOT A BLOCK
	INCB	-(R1)		;FIX REG 1 AND THE BYTE
	CLR	CKSUM		;CLEAR THE CHECKSUM
	CLR	BYSIZ		;CLEAR THE BYTE COUNTER
	BR	OUTCHA		;ADVANCE THREAD AND OUTPUT BYTE
BSIZE:	MOVB	(R1),(PC)+	;STORE FIRST BYTE OF BYTE SIZE
BYTMP:	0
	BR	OUTCHA		;OUTPUT THIS CHARACTER
BSIZE2:	MOVB	(R1),BYTMP+1	;STORE SECOND BYT OF BYTE SIZE
	ADD	BYTMP,BYSIZ	;COMPUTE BYTE SIZE
	INC	BYSIZ		;ADJUST FOR CHECKSUM BYTE
				;FALL THRU TO FINISH THE BLOCK
OUTCHA:	TST	(R4)+		;ADVANCE THE THREAD
OUTCH:	MOVB	(R1)+,R0	;FOR WRITEC
	ADD	R0,(PC)+
CKSUM:	0			;CALCULATE CHECKSUM
	DEC	(PC)+		;DECREMENT BYTE COUNTER
BYSIZ:	0
	BNE	NFIL		;AND EXIT
	TSTB	CKSUM		;IS CHECKSUM EQUAL TO ZERO
	BNE	CKERR		;NO, ERROR
CCONT:	MOV	#FIRSTBY,R4	;RESET FOR A NEW BLOCK
				;  (ALSO SET NON-ZERO RETURN CODE)
NFIL:	RTS	PC		;RETURN WITH CHARACTER IN R0
CKERR:	TST	IGNORE		;IGNORE READ ERRORS
	BNE	CCONT		;YES, CONTINUE
	ERROR	<CHK SUM>

FIRSTBY:.WORD	BYTE1		;FIND A BYTE CONTAINING 001
	.WORD	OUTCHA		;OUTPUT THE NULL AFTER THE 001
	.WORD	BSIZE		;SAVE & OUTPUT THE FIRST
	.WORD	BSIZE2		;  AND 2ND COUNT BYTES
	.WORD	OUTCH		;THEN OUTPUT WITHOUT UPDATING THREAD
	.ENDC
	.SBTTL	WRITE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	WRITE IS USED TO WRITE SOME NUMBER OF WORDS ONTO THE CHANNEL
;	OUCHAN FROM THE BUFFER OUBUF TO THE RELATIVE BLOCK
;	NUMBER OUBLK.  THE WORD COUNT IS SPECIFIED BY R0.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WRITE:	CLR	-(SP)		;USE WAIT I/O
	SWAB	R0		;MAKE WORD COUNT A BLOCK COUNT
	MOV	R0,-(SP)	;PUT ONTO STACK
	MOV	(PC)+,R0	;GET RELATIVE BLOCK NUMBER
OUBLK:	0
	ADD	(SP),OUBLK	;UPDATE THE BLOCK NUMBER
	SWAB	(SP)		;MAKE THE STACK ENTRY A WORD COUNT
	MOV	(PC)+,-(SP)	;PUSH BUFFER ADDRESS
OUBUF:	0
	MOV	(PC)+,-(SP)	;GET CHANNEL NUMBER
OUCHAN:	0
	ADD	(PC)+,(SP)	;ADD PROTOTYPE EMT
	.WRITE	1
	MOV	(SP)+,(PC)	;PUT IT IN LINE
	0			; AND DO THE WRITE
	RTS	PC
OUTER:	JSR	R0,MSG
.NLIST	BEX
OUMES:	.ASCIZ	'?OUT ER?'
.LIST	BEX
	.EVEN
	.IF NDF	MBUILD
	.SBTTL	WRITEC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	WRITEC IS USED TO WRITE CHARACTERS TO THE CURRENT OUTPUT FILE
;	OPEN ON CHANNEL OUCHAN. R2 IS USED AS THE OUTPUT BUFFER
;	POINTER, AND WRITE IS USED TO DO THE ACTUAL IO TRANSFER.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WRITEC:	CMP	R2,OUBUFE	;IS BUFFER FULL ??
	BLO	1$		;NO, DON'T WRITE IT
	MOV	R0,-(SP)	;SAVE CHARACTER TO BE WRITTEN
	MOV	BUFSIZ,R0	;PUT WORD COUNT INTO R0
	JSR	PC,WRITE	;WRITE ONE BUFFER LOAD
	BCS	OUTER		;OUTPUT ERROR
	MOV	(SP)+,R0	;RESTORE CHARACTER
	MOV	OUBUF,R2	;SETUP BUFFER POINTER
1$:	MOVB	R0,(R2)+	;STUFF CHARACTER INTO BUFFER
	RTS	PC
	.SBTTL	FILBUF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	FILBUF FILLS THE CURRENT BLOCK OF THE OUTPUT BUFFER WITH
;	NULLS AND THEN WRITES OUT THE LAST BUFFER LOAD. THIS
;	MAY BE SHORTER THAN BUFSIZ.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FILL:	CLRB	(R2)+		;PUT IN ANOTHER NULL
FILBUF:	MOV	R2,R0		;GET CURRENT BUFFER POINTER
	SUB	OUBUF,R0	;GET CURRENT BUFFER SIZE
	BIT	#777,R0		;IS SIZE A MULTIPLE OF 1000 BYTES ?
	BNE	FILL		;NO, MORE NULLS
	ASR	R0		;MAKE THIS A WORD COUNT
	JSR	PC,WRITE	;WRITE OUT LAST PIECE OF FILE
	BCS	OUTER		;A WRITE ERROR
	RTS	PC
	.ENDC
	.SBTTL	SYSCHK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	SYSCHK  USED TO PROTECT .SYS AND .BAD FILES FROM INADVERTENT
;	DELETION, RENAMING, OR MODIFICATION.  THE ROUTINE IS ENTERRED
;	WITH R0 POINTING TO THE FILE DESCRIPTOR TO BE CHECKED.
;	IF THE FILE HAS AN EXTENSION OF .BAD OR .SYS AND THE /Y SWITCH
;	HAS NOT BEEN SET, SYSCHK WILL RETURN WITH Z=1 (BEQ
;	SUCCEEDS). OTHERWISE THE RETURN IS WITH Z=0 (BEQ FAILS).
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SYSCHK:	CMP	6(R0),(PC)+	;IS IT A .BAD FILE ??
	.RAD50	"BAD"
	BEQ	1$		;YES, GO CHECK /Y
	CMP	6(R0),(PC)+	;IS IT A .SYS FILE ??
	.RAD50	"SYS"
	BNE	SCRET		;NO, JUST RETURN
1$:	TST	SYSBAD		;WAS THERE A /Y ??
	BEQ	CHKMES		;INFORM USER
SYSALL:	MOV	R0,-(SP)	;SAVE REGISTER ZERO
	.DSTATU	#DEVINF		;GET DEVICE STATUS INFORMATION
	MOV	#DEVINF+4,R0	;POINT TO DEVINF+4 (USED AS SCRATCH TOO)
	CMP	@R0,@#SYSPTR	;IS THIS IS A SYS DEVICE
	BLO	POPST		;NO
	CLR	-(R0)		;SET UP FOR NON-FILE-STRUCTURED
	MOV	@(SP),-(R0)	;PUT IN THE DEVICE NAME
	.LOOKUP	0		;OPEN THE DEVICE NON-STRUCTURED
	.SAVEST	0,#SSB		;AND GET INFORMATION THEREON
	MOV	@#SYSPTR,R0	;BASE OF RES INTO R0
	CMPB	SYSUNT(R0),SSB+11 ;IS IT SYSTEM DEVICE?
	BNE	POPST		;NOT SYS DEVICE (AT LAST)
	CLR	REBMES		;SET SWITCH SO REBOOT PRINTED WHEN DONE
POPST:	MOV	(SP)+,R0	;RESTORE REGISTER 0
CHKSLS:	TST	SYSBAD		;WAS THERE A /Y  ??
SCRET:	RTS	PC
CHKMES:	CLR	SYSMES		;SET FLAG TO PRINT MESSAGE
	BR	CHKSLS
.NLIST	BEX
SYSMSG:	.ASCIZ	'?NO .SYS/.BAD ACTION?'
RBMSG:	.ASCIZ	'?'<7>'REBOOT'<7>'?'
	.EVEN
.LIST	BEX
	.SBTTL	GETDIR AND RDDIR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	GETDIR IS USED TO OPEN A DIRECTORY AND TO READ ITS FIRST
;	BLOCK INTO THE USR DIRECTORY BUFFER. R5 SHOULD POINT TO THE
;	DEVICE NAME IN RAD50 FOLLOWED BY A ZERO WORD. THE DEVICE
;	IS THEN OPENNED ON CHANNEL 0 AS A NON FILE STRUCTURED
;	DEVICE, ALLOWING READING OF ABSOLUTE BLOCKS. GETDIR
;	WILL SET CHKEY TO THE INDEX OF THE DEVICE WHO'S DIRECTORY
;	IS BEING EXAMINED. THE REMAINING FUNCTIONS OF GETDIR ARE
;	THE SAME AS THOSE OF RDDIR.
;	RDDIR IS USED TO READ SUCCESSIVE DIRECTORY BLOCKS. IT
;	WILL UPDATE BLKEY TO REFLECT THE ABSOLUTE BLOCK NUMBER
;	OF THE DIRECTORY BLOCK CURRENTLY IN THE USR'S BUFFER.
;	THIS PREVENTS UNECCESSARY DIRECTORY READS IN THE USR.
;	GETDIR AND RDDIR ALSO EXAMINE THE TWO KEYS (BLKEY
;	AND CHKEY) BEFORE READING TO DETERMINE IF THE BLOCK
;	DESIRED IS ALREADY IN CORE.
;	UPON EXIT R5 POINTS TO THE FIRST ENTRY OF THE CURRENT
;	DIRECTORY BLOCK, R0 CONTAINS THE ABSOLUTE BLOCK NUMBER OF
;	THE NEXT DIRECTORY BLOCK (0 MEANS THIS IS THE LAST), AND
;	XTRABY CONTAINS THE NUMBER OF EXTRA BYTES IN EACH
;	DIRECTORY ENTRY.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GETDIR:	JSR	PC,LOCK		;LOCK USR IN CORE

	MOV	#NOP,RDDIR	;INITIALIZE CONDITIONAL BRANCH
	MOV	R5,R0		;POINT TO DEVICE NAME
	JSR	PC,MTCA		;AND IF MT OR CA
	BR	MCDIR		;GO DO SPECIAL DIRECTORY PROCESS
	JSR	PC,OPNDIR	;ELSE, OPEN THE DIRECTORY
	.REOPEN	0		;ON CHANNEL 0 (THIS IS SKIPPED IF DVC = 'CL')
	MOV	#1,R0		;READ FIRST DIRECTORY BLOCK
RDDIR:
	NOP			;EITHER NOP OR BR TO MTCT CODE
	MOV	(PC)+,R5	;USE THE USR DIRECTORY BUFFER
USRBUF:	0			;POINTER TO RMON-USRSIZ
	CMP	R0,@BLKEY	;IS THIS BLOCK ALREADY HERE ??
	BEQ	DIRIN		;YES, DON'T READ AGAIN
REDDIR:	MOV	R0,-(SP)	;SAVE BLOCK NUMBER
	ASL	R0		;MAKE IT AN ABSOLUTE BLOCK NUMBER
	ADD	#DIRBLK-2,R0
	.READW	0,R5,#512.	;READ 2 BLOCKS INTO USRBUF
	BCS	BADDIR		;ERROR READING DIRECTORY
	CMP	4(R5),#37	;THIS ISNT A SURE TEST
	BHI	ILGER
	MOV	(SP)+,@(PC)+	;SAVE BLOCK NUMBER IN USER
BLKEY:	0
DIRIN:	TST	(R5)+		;SKIP NBLOCKS
	MOV	(R5)+,R0	;POINTER TO NEXT DIR BLOCK
	TST	(R5)+		;SKIP HIGHEST SEGMENT NUMBER
	MOV	(R5)+,XTRABY	;GET EXTRA WORD COUNT
	TST	(R5)+		;SKIP FILE BEGINNING BLOCK
	RTS	PC
BADDIR:	ERROR	<ER RD DIR>
ILGER:	ERROR	<ILL DIR>

	.SBTTL	MCDIR
;MCDIR READS AN MT OR CT DIRECTORY.
;WHEN ENTERED THROUGH MCDIR IT REWINDS THE VOLUME READS ITS 1ST LABEL
;AND RETURNS AN ENTRY IN USRBUF SIMILAR TO THOSE IN THE DIRECTORY OF A FILE
;STRUCTURED DEVICE.  ON SUBSEQUENT CALLS TO MCDIRR IT READS AND RETURNS THE NEXT LABEL
;IT ENCOUNTERS.  WHEN IT REACHES LEOT OR PEOT IT RETURNS AN END-OF-
;DIRECTORY ENTRY.


MCDIR:	MOV	#MCDIRR-RDDIR/2+377,RDDIR	;NEXT RDDIR BR'S DOWN
	CLR	2(R5)		;NON-FILE LOOKUP TO OPEN CHANNEL
	.LOOKUP	0,R5
	.IF DF	MBUILD
	JSR	PC,FATERR	;CHECK TO SEE IF FATAL ERROR
	.ENDC
	BCS	BADDIR
	JSR	R5,SPFUN	;REWIND BEFORE DIRECTORY
	.BYTE	377,-5
	JSR	PC,SKPVL1	;SKIP VOL1 IF MT
MCDIRR:	MOV	R1,-(SP)	;SAVE R1
	MOV	R4,-(SP)	;AND R4
	MOV	USRBUF,R5	;POINT R5 TO INPUT BUFFER FOR READS
	MOV	R5,R4		;USE 2ND HALF OF BUFFER FOR DIRECTORY
	ADD	#1000,R4
	.IF NDF	MBUILD
	CMPB	DEVINF,#CTIDEN	;IF CT,
	BEQ	CTDIR		;GO DO A CT DIRECTORY
	.ENDC
RDHDR1:	CLR	R0		;BLOCK # IS 0
	.READW	0,R5,#40.	;READ THE NEXT BLOCK (HDR1)		;###
BDIR1:	BCS	REWDIR
	CMP	(R5),#HDR1	;IS THIS A HDR1?
	BNE	DUNMCD		;IF NOT,WE MUST HAVE LEOT
	CMP	(R5)+,(R5)+	;POINT R5 TO NAME
	JSR	PC,ASCR50	;GET NAME FROM ASCII TO RAD50
DUNNAM:	JSR	R5,SPFUN	;SPACE TO EOF1 LABEL
	.BYTE	377,-2		;(FORWSP CODE)
	BCS	REWDIR
	JSR	R5,SPFUN
	.BYTE	377,-2		;(FORWSP CODE)
	BCS	REWDIR
	MOV	USRBUF,R5	;POINT TO INPUT BUFFER AGAIN
	CLR	R0		;BLOCK # IS 0
	.READW	0,R5,#40.	;READ THE EOF1 LABEL			;###
	BCS	REWDIR
	CMP	(R5),#EOF1	;IF EOF1 NOT READ,
	BNE	ENDSEG		;ASSUME BTE CAUSED LACK OF EOF1 AND
				;IGNORE ITS CONTENTS
OKEOF:	ADD	#74,R5		;POINT R5 TO 1ST DIGIT OF BLOCK COUNT
	JSR	PC,ASCOCT	;CHANGE 6 DIGITS OF ASCII TO OCTAL IN (R4)
	MOV	(R4)+,(R4)+	;COPY COUNT INTO NEXT WORD, TOO
	SUB	#11,R5		;POINT R5 TO FIRST YEAR DIGIT
	JSR	PC,ASCOCT	;GET BIN FOR YEAR IN (R4)
	SUB	#110,(R4)	;YEAR-72(10)
	MOV	(R4),(PC)+	;SAVE YEAR
YEAR:	0
	MOV	#28.,FEB	;INIT MONTH TABLE FOR NORMAL YEAR
	ROR	(R4)
	ROR	(R4)		;IF BOTH LOW ORDER BITS=0,THEN LEAP YEAR
	BCS	1$		;BRANCH IF NOT LEAP
	BMI	1$		;BRANCH IF NOT LEAP
	INC	FEB		;FEBRUARY HAS 29 DAYS THIS YEAR
1$:	CMPB	(R5)+,(R5)+	;BUMP R5 BY 2
	CLRB	(R5)		;MARK END OF DATE FIELD
	ADD	#4,R5		;POINT R5 TO FIRST DIGIT OF DAY
	JSR	PC,ASCOCT	;BINARY FOR DAYS IN @R4
	MOV	#MONTAB,R1	;R1 POINTS TO MONTH TABLE
2$:	SUB	(R1)+,(R4)	;SUB THIS MONTHS DAYS FROM TOTAL
	BGT	2$		;IF MORE LEFT,CONTINUE
	ADD	-(R1),(R4)	;ON OVERFLOW,BACK UP ONE MO
	SUB	#MONTAB,R1	;(MONTH*2)-2 IN R1
	CMPB	(R1)+,(R1)+	;ADD 2 TO MAKE MONTH*2
	ASL	R1
	ASL	R1
	ASL	R1		;SLIDE MO OVER
	ASL	R1
	ADD	R1,(R4)		;COMBINE MO AND DAY
	ASL	(R4)
	ASL	(R4)
	ASL	(R4)		;SLIDE MO AND DAY OVER
	ASL	(R4)
	ASL	(R4)
	ADD	YEAR,(R4)+	;COMBINE YEAR;RT-11 DATE NOW @R4
	JSR	R5,SPFUN	;SPACE TO NEXT HDR1
	.BYTE	377,-2		;(FORWSP CODE)
BCSDIR:	BCS	REWDIR
	BR	ENDSEG		;ELSE, END THIS SEGMENT
DUNMCD:	JSR	R5,SPFUN	;ON DONE,REWIND TO BEGINNING OF TAPE
	.BYTE	377,-5		;(REWIND CODE)
	JSR	PC,SKPVL1	;IF MT,FSPACE OVER VOL1
ENDIR:	CLR	R0		;WHEN DONE, SET R0 TO NO MORE DIRECTORY
ENDSEG:	MOV	#DIREOB,(R4)+	;SET END OF SEGMENT MARKER
	MOV	USRBUF,R5	;POINT R5 TO DIRECTORY
	ADD	#1000,R5
	CLR	XTRABY		;SAY NO EXTRA WORDS
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R1	;RESTORE R1
	RTS	PC		;AND RETURN

REWDIR:	JSR	R5,SPFUN	;ON ERROR, REWIND TO GET KNOWN POSITION
	.BYTE	377,-5		;(REWIND CODE)
	JSR	PC,SKPVL1	;IF MT,FSPACE OVER VOL1
	JMP	BADDIR		;AND TAKE ERROR EXIT


	.IF NDF	MBUILD
;CTDIR CONVERT THE LABELS ON A CASSETTE TO DIRECTORY FORMAT

CTDIR:	CLR	R0		;BLOCK # TO 0
	.READW	0,R5,#20	;READ THE FIRST LABEL INTO BUFFER
	BCS	REWDIR
	TSTB	(R5)		;IF NULL NAME,
	BEQ	DUNMCD		;SENTINAL FILE, DONE
	TSTB	14(R5)		;IS SEQUENCE NUMBER 0?
	BEQ	3$		;YES-CONTINUE
	TST	DIRFLG		;NO-IS A DIRECTORY LISTING IN PROGRESS?
	BNE	3$		;YES-CONTINUE
	JSR	R5,SPFUN	;OTHERWISE,IGNORE THIS FILE
	.BYTE	377,-3		;SPACE TO NEXT FILE
	BCS	DUNMCD		;ASSUME ERROR IS EOT
	BR	CTDIR		;TRY NEXT FILE
3$:	JSR	PC,ASCR50	;ELSE, GET NAME INTO DIRECTORY
	ADD	#3,R5		;POINT TO SEQ NO
	BIC	#177400,(R5)	;STRIP LEVEL IDENTIFIER
	MOV	(R5)+,(R4)+	;INSERT SEQ NO. BYTE AS BLOCK COUNT
	CLR	(R4)+		;0 DATA LENGTH
	CMPB	(R5),#60	;IS THERE A DATE THERE
	BGE	1$		;YES
	CLR	(R4)		;NO:ZERO DATE WORD IN DIRECT
	BR	2$
1$:	ADD	#5,R5		;POINT R5 TO NEXT TO LAST BYTE OF DATE
	JSR	PC,ASCOCT	;CONVERT 5 DIGITS OF DATE TO BINARY EQUIVALENT
2$:	MOV	(R4),R1		;SAVE THIS VALUE IN R1
	BEQ	NULDAT		;NO DATE HERE
	CLR	(R4)		;CLEAR DATE
	MOV	USRBUF,R5
	MOVB	23(R5),(R4)	;PUT IN LAST DIGIT OF DATE FROM LABEL
	SUB	#60,(R4)	;LESS ITS ASCII PART
	MOV	#TENTH,R5	;PT. R5 TO TABLE OF DECIMAL VALUES
	MOV	#OCTH,R0	;PT. R0 TO TABLE OF OCTAL VALUES
;THE THREE VALUES IN THE DECIMAL TABLE CORRESPOND TO THE 3 PLACES IN THE
;ORIGINAL DECIMAL DATE WHERE MONTH, DAY, AND YEAR BEGIN.
;THE THREE VALUES IN THE OCTAL TABLE PT. TO THE BITS WHERE
;THE DAY, MONTH, AND YEAR START IN THE RT11 FORMATTED DATE.
SUBDAY:	SUB	(R5),R1		;SUBTRACT CURRENT TEN VALUE FROM DEC. DATE
	BLT	DUNDAY		;IF DATE GOES <0, THIS PART OF DATE DONE
	ADD	(R0),(R4)	;ELSE, ADD CURRENT OCTAL TO RT11 DATE
	BR	SUBDAY		;AND GO SUBTRACT AGAIN
DUNDAY:	ADD	(R5),R1		;WHEN VALUE GOES <0, ADD BACK THE LAST SUB
	CMP	-(R5),-(R5)	;THEN PT R5 TO NEXT TEN VALUE (THIS ONE/1000)
	TST	-(R0)		;AND R0 TO NEXT OCTAL
	BGT	SUBDAY		;IF NOT END OF OCTAL LIST (A 0), DO NEXT PART
	SUB	#110,(R4)	;RT11 USES DATE-110
NULDAT:	TST	(R4)+		;POP R4 TO NEXT ENTYR
	JSR	R5,SPFUN	;SPACE TO NEXT FILE
	.BYTE	377,-3		;(NEXTFILE CODE)
	BCS	DUNMCD		;ON ERR ASSUME PHYSICAL EOT
	BR	ENDSEG		;ELSE, END THIS SEGMENT
	.ENDC


;SPFUN EXECUTES THE SPECIAL FUNCTION WHOSE CODE FOLLOWS THE SUBROUTINE
;CALL.  IT DOES SO BY SETTING UP THE LIST AND EXECUTING EMT 375.
;SPFUN SETS THE WCOUNT TO 0,SPFUN1 SETS IT TO -1

SPFUN1:	MOV	#1,-(SP)	;WC TO 1
	BR	SPFUN2
SPFUN:	CLR	-(SP)		;WC TO 0
SPFUN2:	MOV	#LIST,R0	;PT R0 TO LIST
	MOV	#32*400+0,(R0)	;LOAD SPECIAL FUNC. CODE, CHANNEL 17
	MOV	(R5)+,10(R0)	;GET CODE INTO 5TH WORD
	MOV	(SP)+,6(R0)	;SET UP WC
	MOV	R0,-(SP)	;SAVE R0 (IT GETS ZEROED)
	EMT	375		;THEN DO IT
	MOV	(SP)+,R0	;GET R0 BACK
	RTS	R5		;AND GO BACK

;ASCR50 DETERMINES THE TYPE OF ENTRY, NULL OR GOOD, BY THE FIRST LETTER
;OF THE FILE NAME POINTED TO BY R5 AND INSERTS THIS INFORMATION AS THE
;STATUS OF THIS DIRECTORY ENTRY IN THE SLOT POINTED TO BY R4
;THEN IT CONVERTS THE ASCII STRING POINTED TO BY R5 TO 3 RAD50 WORDS
;IN THE SPACE POINTED TO BY R4.
;### ASCR50 WILL IGNORE A '.' (DOT) IN COLUMN 7 OF THE ASCII FILENAME
;AND EXTENSION STRING, SINCE THE MT HANDLER PUTS ONE THERE FOR EASE
;OF TRANSFERABILITY TO RSX  ASCR50 WILL ALSO MAKE FILENAMES
;LIKE  'ABC.DAT' ON MAGTAPE (OR CASSETTE) LOOK LIKE PROPER RT 
;FILENAMES ON THE DIR LISTING.		B.C.
;###
ASCR50:	MOV	#DIREMP,R0	;SET EMPTY IF NON-NULL NAME
	CMPB	(R5),#RUBOUT	;DELETED FILES START WITH RUBOUT
	BEQ	NULNAM
	CMPB	(R5),#ASTRSK	;DELETED FILES ALSO START WITH *
	BEQ	NULNAM
	ASL	R0		;TYPE 4 FOR GOOD NAME
NULNAM:	MOV	R0,(R4)+	;INSERT TYPE AS STATUS OF THIS ENTRY
	MOV	#9.,(PC)+	;COUNT 9 CHARACTERS
CTR:	.WORD	0
NXTCAR:	MOVB	(R5)+,R0	;GET CHAR INTO R0
	CMPB	#'.,R0		;IS CHAR A DOT?			;###
	BNE	R50PAK		;IF NE-NO			;###
	CMP	CTR,#3		;IS THIS CHAR POS 7?		;###
	BLO	R50PAK		;IF PAST 7, TREAT DOT AS DOT	;###
	BEQ	NXTCAR		;IF AT POS. 7 JUST IGNORE DOT	;###
	MOV	#40,R0		;IF BEFORE 7, MAKE DOT A SPACE	;###
	DEC	R5		;AND ADJ PTR TO PAD FILNAM W/SPACES ;###
R50PAK:	DEC	(PC)+		;COUNT DOWN FROM 3
R50CTR:	.WORD	0
	BGT	1$		;SPACE LEFT, SO GO *50
	CLR	(R4)+		;CLEAR THE NEXT WORD
	MOV	#3,R50CTR	;RESET COUNT
1$:	SUB	#72,R0		;CHECK FOR DIGIT
	ADD	#12,R0
	BCC	2$		;NO, GO TRY FOR LETTER
	ADD	#36,R0		;SCALE DIGIT
	BR	4$
2$:	SUB	#20,R0		;REDUCE TO LETTER RANGE
	BLE	3$		;DELIMITER!
	CMP	R0,#32		;A TO Z?
	BLE	4$		;GOT IT
	SUB	#40,R0		;MAY AS WELL TRY LOWER CASE
	BGT	2$
3$:	CLR	R0		;(DELIMITER)-CALL IT A SPACE	;###
4$:	ASL	-(R4)		;*50+CHAR
	ASL	@R4
	ASL	@R4
	ADD	@R4,R0
	ASL	@R4
	ASL	@R4
	ADD	R0,(R4)+	;KEEP POINTING PAST IT
	DEC	CTR		;COUNT THIS CHARACTER
	BGT	NXTCAR		;IF MORE LEFT, GET NEXT CHAR
DDUN:	RTS	PC


;ASCOCT CONVERTS THE 6 DIGITS POINTED TO BY R5 FROM ASCII DECIMAL TO
;OCTAL IN THE WORD POINTED TO BY R4.
;IT DOES THIS BY GOING THROUGH EACH DIGIT OF THE VALUE ADDING TO
;THE COUNT THE CORRESPONDING BINARY EQUIVALENT OF THAT PLACE ENOUGH
;TIMES TO SEND THAT DIGIT TO 0.

ASCOCT:	MOV	#TENS,R0	;POINT R0 TO DEC. EQUIVALENTS
	CLR	(R4)		;CLEAR BLOCK COUNT IN DIRECTORY
DIG:	MOVB	-(R5),R1	;GET ASCII/DECIMAL DIGIT
NOTZER:	SUB	#60,R1		;RID ASCII
	BLT	DDUN		;THEN FINAL BLANK(MT) OR 0(CT) GOES <0
DDEC:	BEQ	NDIG		;WHEN DIGIT REACHES 0, GO TO NEXT
	ADD	(R0),(R4)	;ELSE, ADD EQUIVALENT TO COUNT
	DEC	R1		;AND KNOCK DIGIT DOWN ONE
	BR	DDEC
NDIG:	TST	(R0)+		;WHEN DIGIT DONE, PT TO NEXT TENS
	BR	DIG		;AND DO NEXT HIGHER DIGIT

;LIST FOR V2 EMT'S
LIST:	.WORD	0		;CODE/CHANNEL
FFILE:	.WORD	0		;FILE NAME OR SPECIAL FUNCTION BLOCK
FLEN:	.WORD	0		;LENGTH FOR ENTER, BLOCK FOR DELETE AND LOOKUP, BUFFER FOR SPECIAL FUNCTION
FBLOCK:	.WORD	0		;BLOCK FOR ENTER, WC FOR SPECIAL FUNCTION
FWC:	.WORD	0		;FUNCTION CODE FOR SPECIAL FUNCTION
FCONT:	.WORD	0		;CONTINUATION ADDR.(NOT USED)
	.WORD	0		;USED BY SPFUNC CALL


;THE FOLLOWING TABLE CONTAINS OCTAL EQUIVALENTS OF DECIMAL POWERS OF
;TEN.

	.WORD	1		;KLUDGEY WORD FOR DATE CONVERSION
TENS:	.WORD	1		;1.
	.WORD	12		;10.
	.WORD	144		;100.
TENTH:	.WORD	1750		;1000.
	.WORD	23420		;10000.
	.WORD	0		;100000. (TOO BIG FOR 16 BITS)

;THE TABLE BELOW POINTS TO THE BITS IN THE RT11 FORMAT DATE WHERE
;MONTH, YEAR, AND DAY BEGIN.

	.WORD	12		;POINTER TO YEAR PLACE*10
	.WORD	2000		;POINTER TO MONTH PLACE
OCTH:	.WORD	40		;POINTER TO DAY PLACE

;THE FOLLOWING MONTH TAVLE IS USED TO CONVERT JULIAN MAGTAPE DATES
;TO RT-11 FORMAT

MONTAB:	31.			;JAN
FEB:	28.			;FEB
	31.			;MAR
	30.			;APR
	31.			;MAY
	30.			;JUN
	31.			;JUL
	31.			;AUG
	30.			;SEP
	31.			;OCT
	30.			;NOV
	31.			;DEC

	.SBTTL	OPNDIR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	OPNDIR WILL OPEN THE DEVICE SPECIFIED BY THE STRING
;	POINTED TO BY R5 ON CHANNEL 17 AND SET UP THE RMON
;	CHANNEL CONTROL WORD CHKEY.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPNDIR:	JSR	PC,LOCK		;LOCK USR IN CORE
	.DSTATU	#DEVINF,R5	;FIND OUT WHAT KIND OF DEVICE
	TST	DEVINF		;WELL, IS IT FILE STRUCTURED?
	BPL	OPNSPC		;NOT A DIRECTORY DEVICE
	CLR	2(R5)		;DO A NON-FILE-STRUCTURED LOOKUP
	.LOOKUP	16,R5		;LOOKUP THE FILE (OPEN NON-STRUCT)
	.IF DF	MBUILD
	JSR	PC,FATERR	;CHECK TO SEE IF FATAL ERROR
	.ENDC
	BCS	BADJMP		;ERROR LOOKING UP DIRECTORY
OPNCNT:	.SAVEST	16,#SSB		;SAVE THE STATUS OF THE DEVICE
	MOV	#SSB,R0		;RESTORE THAT POINTER (CALLER EXPECTS IT!)
	MOV	10(R0),-(SP)	;GET INDEX AND POINTER FOR CHKEY
	MOVB	(R0),(SP)
	BIC	#301,(SP)
	CMP	(SP),@CHKEY	;IS IT THE SAME AS CURRENTLY ??
	BEQ	1$		;YES, MAYBE NO READ NEEDED
	CLR	@BLKEY		;NO, CAN'T AVOID A READ
1$:	MOV	(SP)+,@(PC)+	;PUT IN NEW CHANNEL KEY
CHKEY:	0			;POINTER TO RMON+206
	RTS	PC
BADJMP:	JMP	BADDIR		;ERROR VECTOR

OPNSPC:	CMPB	#CLIDEN,DEVINF	;IS DEVICE CL?
	BNE	BADJMP		;NO. ERROR
	.LOOKUP	0,R5		;OPEN ON CHAN 0
	BCS	BADJMP
	MOV	#FLEN,FLEN	;SET UP A BUFFER FOR SPFUN
	JSR	R5,SPFUN	;GET ACTUAL DEVICE NAME
	.WORD	-1		;ANY CODE WILL DO
	.DSTAT	#DEVINF,#FLEN	;GET STATUS INDIRECT
	TST	DEVINF		;FILE STRUCTURED?
	BPL	BADJMP		;NOPE
	CLR	@BLKEY		;ALWAYS READ A SEGMENT!!!!
	ADD	#2,(SP)		;MODIFY RETURN ADDRESS
	RTS	PC		;AND RETURN
	.SBTTL	WRDIR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	WRDIR WILL WRITE OUT THE DIRECTORY CURRENTLY IN THE USR'S
;	DIRECTORY BUFFER ONTO THE DEVICE SPECIFIED BY CHKEY AT
;	THE BLOCK SPECIFIED BY BLKEY USING CHANNEL OUCHAN.
;	DIRWR WILL WRITE OUT THE DIRECTORY SEGMENT SPECIFIED BY R0.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WRDIR:	MOV	@BLKEY,R0	;BLOCK NUMBER OF DIR BLOCK IN CORE
DIRWR:	ASL	R0		;MAKE IT AN ABSOLUTE BLOCK NUMBER
	ADD	#DIRBLK-2,R0
	CLR	-(SP)		;WAIT I/O
	MOV	#1000,-(SP)	;TWO BLOCKS
	MOV	USRBUF,-(SP)	;FROM THE USR BUFFER
	MOV	OUCHAN,1$	;GET THE OUTPUT CHANNEL NUMBER
	ADD	(PC)+,(PC)	;ADD IN THE .WRITE IMAGE
	.WRITE	1
1$:	0			;AND EXECUTE THE WRITE
	BCC	GDRTS		;OK
ERRWRD:	ERROR	<ER WR DIR>	;SUPER BAD ERROR
	.SBTTL	MAKEMT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	MAKEMT WILL CREATE AN EMPTY ENTRY IN THE DIRECTORY AT 
;	THE PLACE POINTED TO BY R4 USING R1 AS THE SIZE IN
;	BLOCKS. R4 IS THEN BUMPED TO POINT TO THE START OF THE NEXT
;	DIRECTORY ENTRY.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MAKEMT:	MOV	#DIREMP,(R4)	;CREATE AN EMPTY ENTRY
	MOV	R1,10(R4)	;SIZE OF EMPTY IS PREVIOUS UNUSED
	CLR	R1		;NO MORE UNUSED AT THIS POINT
	ADD	#DIRESZ,R4	;BUMP NEW DIRECTORY POINTER
	ADD	XTRABY,R4	;PAST THIS ENTRY
GDRTS:	RTS	PC
	.SBTTL	CONV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	CONV WILL CONVERT THE NUMBER IN R0 TO A DIGIT STRING
;	USING RADIX. THE RESULTING STRING OF DIGITS (LESS
;	LEADING ZEROES WILL BE POINTED TO BY R1, WITH A NEGATIVE
;	BYTE TO INDICATE THE END OF STRING. R3 MAY BE SET TO THE
;	DESIRED FIELD WIDTH, IN WHICH CASE CONV WILL OUTPUT (VIA
;	DIRLST) SUFFICIENT BLANKS TO RIGHT JUSTIFY THE DIGITS 
;	IN THAT FIELD.  R4 IS USED AS A TEMPORARY.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CONV:	MOV	#DIGITS,R1	;POINTER TO DIGITS OUTPUT AREA
	MOV	R4,-(SP)	;PRESERVE R4
CNVLUP:	CLR	R4		;CLEAR REMAINDER WORD
	MOV	#17,-(SP)	;SET BIT COUNT
DIVLUP:	ASL	R0		;SHIFT DIVIDEND-QUOTIENT REG
	ROL	R4		;SHIFT REMAINDER REG
	CMP	R4,RADIX	;BIG ENOUGH TO SUBTRACT ??
	BLO	NOFIT		;NO
	SUB	(PC)+,R4	;SUBTRACT DIVISOR
RADIX:	0
	INC	R0		;SET CORRESPONDING BIT IN QUOTIENT
NOFIT:	DEC	(SP)		;ANY MORE BITS ??
	BPL	DIVLUP		;YES
	MOVB	R4,-(R1)	;SAVE REMAINDER AS RIGHTMOST DIGIT
	ADD	(SP)+,R3	;DECREMENT DIGIT COUNT
	TST	R0		;ANYTHING LEFT ??
	BNE	CNVLUP		;YES, KEEP DIVIDING
BLFILL:	DEC	R3		;ENOUGH CHARACTERS ??
	BMI	2$		;YES, RETURN
	MOV	#' ,R0		;NO, PUT OUT ANOTHER BLANK
	JSR	PC,DIRLST
	BR	BLFILL
2$:	MOV	(SP)+,R4	;RESTORE R4
DONE:	RTS	PC
.NLIST	BEX
	.BYTE	0,0,0,0,0,0,0
DIGITS:	.BYTE	377
.LIST	BEX
	.SBTTL	R10OUT AND R10OVT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	R10OUT WILL OUTPUT THE NUMBER IN R0 IN DECIMAL VIA DIRLST,
;	WITH A FIELD WIDTH OF 2. R10OVT WILL USE A FIELD WIDTH OF 4.
;	BOTH ROUTINES USE CONV.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
R10OVT:	MOV	#4,R3		;PRINT 4 DIGIT FIELD
	BR	R10CNV
R10OUT:	MOV	#2,R3		;STANDARD IS 2 DIGITS
R10CNV:	MOV	#10.,RADIX	;SET RADIX TO 10.
R810:	JSR	PC,CONV		;CONVERT THE NUMBER
1$:	MOVB	(R1)+,R0	;GET NEXT DIGIT
	BMI	DONE		;NEGATIVE IS INDICATOR
	ADD	#'0,R0		;MAKE ITT ASCII
	JSR	PC,DIRLST	;PRINT ON DIRECTORY LISTING FILE
	BR	1$		;DO NEXT DIGIT

	.IF NDF MBUILD
R8OUT:	MOV	#7,R3		;OCTAL FIELDS ARE 7 LONG
	MOV	#10,RADIX
	BR	R810
	.ENDC
	.SBTTL	R50OUT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	R50OUT WILL OUTPUT (VIA DIRLST) THE WORD IN R0 AS THREE
;	RADIX 50 CHARACTERS. SPACES ARE PRINTED FOR 0,33,34,35.
;	R50OUT USES CONV.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FNAML:	JSR	PC,R50WD	;FIRST 3 CHARS
	JSR	PC,R50WD	;NEXT 3
	MOV	#' ,R0		;PREPARE TO PRINT . OR BLANK
	TST	(R5)		;IS EXTENSION NON-BLANK ??
	BEQ	1$
	MOV	#'.,R0		;NO, PUT OUT DOT FIRST
1$:	JSR	PC,DIRLST	;PRINT IT

R50WD:	MOV	(R5)+,R0	;GET THE RAD50 WORD
R50OUT:	MOV	R3,-(SP)	;PRESERVES R3, R1
	MOV	R1,-(SP)
	MOV	#3,R3		;OUTPUT THREE CHARS ALWAYS
	MOV	#50,RADIX	;SET RADIX TO 50
	JSR	PC,CONV		;CONVERT FROM RAD 50
1$:	MOVB	(R1)+,R0	;GET NEXT CHARACTER
	BMI	5$		;MINUS IS INDICATOR CHARACTER
	BEQ	2$		;ZERO IS A BLANK
	CMP	R0,#32		;IS IT A LETTER  (1-32)  ??
	BLE	3$		;YES
	SUB	#36,R0		;IS IT A DIGIT  (36-47)  ??
	BCC	4$		;YES
2$:	MOV	#-40,R0		;PRINT A SPACE FOR 0,33,34,35
3$:	ADD	#20,R0		;CONVERT FROM (1-32) TO (101-132)
4$:	ADD	#60,R0		;CONVERT FROM (36-47) TO (60-71)
	JSR	PC,DIRLST	;OUTPUT THE CHAR
	BR	1$
5$:	MOV	(SP)+,R1
	MOV	(SP)+,R3
	RTS	PC
	.SBTTL	YESCHK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	YESCHK GETS A FULL LINE FROM THE TTY
;	IT RETURNS CC EQUAL IF THE FIRST CHAR WAS "Y"
;	OTHERWISE CC NONEQUAL
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YESCHK:	.TTYIN			;READ CHARACTER FROM TT:
	MOV	R0,-(SP)	;SAVE THE RESPONSE CHARACTER
1$:	.TTYIN			;GET NEXT TT: CHARACTER
	CMP	R0,#12		;IS IT A LINE FEED ??
	BNE	1$		;NO, KEEP SKIPPING
	CMP	(SP)+,#'Y	;WAS RESPONSE "Y......"  ??
	RTS	PC
	.SBTTL	PUTMSG AND CRLF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	PUTMSG WILL OUTPUT A TEXT STRING VIA DIRLST. THE CALL IS :
;			JSR	R3,PUTMSG
;			.ASCIZ	"TEXT OF MESSAGE"
;			.EVEN
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MSGLUP:	JSR	PC,DIRLST	;PRINT ODD CHAR
	MOVB	(R3)+,R0	;GET ODD CHAR
	BEQ	MSGDUN		;IF ZERO, END OF MESSAGE
	JSR	PC,DIRLST	;PRINT EVEN CHARACTER
PUTMSG:	MOVB	(R3)+,R0	;GET EVEN CHAR
	BNE	MSGLUP		;NOT ZERO, GO PRINT IT
	INC	R3		;EVEN OFF THE RETURN REGISTER
MSGDUN:	RTS	R3
	.SBTTL	DATOUT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	DATOUT OUTPUTS R3 VIA DIRLST AS A DATE. THE DATE
;	WILL ALWAYS OCCUPY 9 CHARACTERS WITH A LEADING BLANK
;	INSERTED IF NECESSARY.  THE FORMAT IS :   12-SEP-73
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DATOUT:	BIT	#36000,R3	;MAKE SURE DATE IS VALID
	BEQ	DIRRTS		;DON'T PRINT, JUST RETURN
1$:	MOV	R3,-(SP)	;PUSH RIGHTMOST FIELD OF DATE WORD
	BIC	#177740,(SP)	;ONLY 5 BITS
	ASR	R3		;SHIFT TO NEXT DATE FIELD
	ASR	R3
	ASR	R3
	ASR	R3
	ASR	R3
	BNE	1$		;MORE FIELDS  (DATE CAN'T BE 0)
	MOV	2(SP),R0	;GET DAY
	JSR	PC,R10OUT	;OUTPUT 2 DIGITS DECIMAL
	MOV	(SP)+,R3		;GET MONTH
	ASL	R3		;TIMES FOUR
	ASL	R3
	ADD	#MONTHS-4,R3	;POINTER TO MONTH TABLE
	MOV	#5,(SP)		;OUTPUT MONTH  (-XXX-)
2$:	MOVB	(R3)+,R0	;GET NEXT CHAR OF MONTH
	JSR	PC,DIRLST	;PRINT IT
	DEC	(SP)		;MORE ??
	BNE	2$		;YES
	TST	(SP)+		;PURGE COUNTER WORD
	MOV	(SP)+,R0	;GET YEAR
	ADD	#72.,R0		;ADD 72 FOR BASE YEAR OF 1973
	BR	R10OUT		;OUTPUT DECIMAL, R10OUT RETURNS
.NLIST	BEX
MONTHS:	.ASCII	"-JAN-FEB-MAR-APR-MAY-JUN-JUL-AUG-SEP-OCT-NOV-DEC-"
.LIST	BEX
	.EVEN
	.SBTTL	DIRLST
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	DIRLST WILL OUTPUT A CHARACTER TO THE DIRECTORY LISTING
;	FILE IF THE SWITCH LISTOF IS 0. A SPECIAL CASE CHECK IS
;	MADE FOR THE DEVICE TT: AND THE SYSTEM'S TELETYPE
;	HANDLER IS USED DIRECTLY.
;
;
;	CRLF WILL OUTPUT A CARRIAGE RETURN LINE FEED VIA DIRLST.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CRLF:	MOV	#15,R0		;OUTPUT A CARRIAGE RETURN
	JSR	PC,DIRLST
	MOV	#12,R0		;THEN A LINE FEED

DIRLST:	TST	(PC)+		;IS ANY OUTPUT DEVICE GIVEN ??
DIRDES:	0
	BNE	NOTTT		;YES, ITS NOT TT:
	.TTYOUT			;IF TT: USE SYSTEM TT: HANDLER
DIRRTS:	RTS	PC
NOTTT:	.IF NDF	MBUILD
	JMP	WRITEC		;WRITE CHARACTER TO DIRLST FILE
	.IFF
	JMP	HANERR		;ILLEGAL DEVICE
	.ENDC
	.SBTTL	FGCHK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	PRINTS "FG PRESENT" ERROR MESSAGE AND RETURNS
;	TO START IF A FOREGROUND JOB IS IN CORE.
;	USES R0
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	.ENABL	LSB
FGCHK:	MOV	@#SYSPTR,R0	;START ADDR OF RES IN R0
	BIT	#FGACTV,CONFIG(R0)	;TEST FG BIT IN CONFIG WORD
	BEQ	1$		;RETURN IF NO FG AROUND
	ERROR	<FG PRESENT>


	.SBTTL	LOCK AND UNLOCK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	LOCK SERVES TO ASSURE THAT PIP HAS POSSESSION OF THE USR
;	BEFORE IT USES THE USR BUFFER FOR DIRECTORY EXAMINATION.
;	UNLOCK SERVES TO RELEASE CONTROL SO THE FOREGROUND CAN GET
;	TO USR AGAIN WHEN PIP IS DONE WITH IT.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LOCK:	TST	(PC)+		;USR IN CORE ALREADY?
LOCKF:	0
	BNE	1$		;YES
	INC	LOCKF		;NO-SET FLAG AS WE ARE ABOUT TO GET IT
	.LOCK			;PULL USR IN CORE
1$:	RTS	PC

UNLOCK:	TST	LOCKF		;USR IN CORE?
	BEQ	2$		;NO-NO NEED TO DO ANYTHING
	CLR	LOCKF		;YES-WE ARE GOING TO KICK IT OUT
	.IF NDF	MBUILD
	CLR	@(PC)+		;RE-ENABLE CTRL/C'S
NOCTLC:	0			;POINTER TO RMON+212
	.ENDC
	.UNLOCK			;BOOT USR OUT
2$:	RTS	PC
	.DSABL	LSB
	.IF DF	MBUILD
	.SBTTL	FATAL ERROR AND TRAP HANDLING CODE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	FATERR HANDLES THE FATAL ERROR RETURNS CAUSED BY THE .SERR
;	ISSUED WHEN MBUILD STARTS. IT PRINTS AN APPROPRIATE MESSAGE
;	IF THE CODE IS MEANINGFUL,ELSE IT LETS NORMAL BCS FOLLOWING
;	EMT EXECUTE. IF CODE IS VALID,FATERR RESTARTS MBUILD
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FATERR:	ROR	-(SP)		;SAVE CARRY
	MOVB	@#52,R0		;GET ERROR CODE
	BMI	1$		;BRANCH IF FATAL
2$:	ROL	(SP)+		;RESTORE CARRY
	RTS	PC		;AND RETURN
1$:	NEG	R0		;MAKE ERROR POSITIVE
	DEC	R0		;ADJUST BY ONE
	ASL	R0		;TURN ERROR CODE INTO INDEX
	MOV	FATTBL(R0),R0	;GET ADDRESS OF APPROPRIATE MESSAGE
	BEQ	2$		;IF NO MESSAGE,LET ORIGINAL CODE HANDLE IT
	.PRINT			;PRINT MESSAGE
	JMP	START		;AND RESTART MBUILD

FATTBL:	0
	M2
	M3
	0
	0
	M6
	0
	0
	0
M2:	.ASCIZ	/?ILL DEV?/
M3:	.ASCIZ	/?M-DIR IO ERR?/
M6:	.ASCIZ	/?M-DIR OVFLO?/
	.EVEN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	TRPLOC HANDLES TRAPS TO 4 AND 10 BY PRINTING ERROR MESSAGE
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TRPLOC:	MOV	R0,-(SP)	;SAVE R0
	.PRINT	#TRP410		;PRINT ERROR MESSAGE
	.TRPSET	#TAREA,#TRPLOC		;REISSUE TRPSET
	MOV	(SP)+,R0	;RESTORE R0
	RTI

TAREA:	.WORD	0,0
TRP410:	.ASCIZ	/?M-TRAP TO 4 OR 10?/
	.EVEN
	.ENDC
	.SBTTL	STORAGE DECLARATIONS
OLNAME:	.WORD	0,0,0,0		;OLD NAME SPACE FOR RENAME
NEWNAM:	.WORD	0,0,0,0,0	;NEW NAME SPACE FOR RENAME
DEVNAM:	.WORD	0,0		;USED FOR NON FILE STRUCTURED OPEN
DEFEXT:	.WORD	0,0,0,0		;DEFAULT EXTENSIONS (ALL BLANK)
DEVINF:	.BLKW	5		;DEVICE INFORMATION BLOCK
SSB:	.BLKW	5		;SAVE STATUS BLOCK
FILDES:	.BLKW	47		;OUTPUT AREA FOR CSI
FREE:				;FREE CORE
				;HANDLERS
				;EXPANDED INPUT LIST
				;STATUS BLOCKS FOR INPUT LIST (/X & /R)
				;BUFFER(S)
	.SBTTL	INITIALIZATION CODE
BEGIN:	.IF DF	MBUILD
	.SRESET			;FLUSH ANYTHING ACTIVE
	.PRINT	#VMESAG		;IDENTIFY SELF
	.SERR			;WE'LL HANDLE ALL ERRORS
	.TRPSET	#TAREA,#TRPLOC	;AND ALL TRAPS
	.ENDC
	MOV	@#SYSPTR,R2	;POINTER TO RMON
	ADD	#OFFSET,R2	;GET ADDRESS OF BLKEY
	MOV	R2,BLKEY
	TST	(R2)+		;GET ADDRESS OF CHKEY
	MOV	R2,CHKEY
	CMP	(R2)+,(R2)+
	.IF NDF	MBUILD
	MOV	R2,NOCTLC
	.IFF
	MOV	SP,@(R2)	;PERMANENTLY DISABLE CTRL C
	.ENDC
	TST	(R2)+		;GE ADDRESS OF USR BUFFER POINTER
	MOV	(R2),USRBUF
	CMP	USRBUF,#BEGIN+512. ;WE NEED AT LEAST 1 BLOCK OF BUFFER
	BHI	1$		;THERE IS ENOUGH
	.PRINT	#NOCOR		;PRINT FATAL ERROR
	.EXIT			;AND RETURN TO MONITOR
1$:	MOV	(R2),R0		;USR BUFFER IS JUST ABOVE KMON
	TST	-(R0)		;BUFFERS GO UP TO USR
	.SETTOP			;TEL THE MONITOR ABOUT IT
	BIS	#20000,@#JSW	;SET REENTERABLE BIT
	MOV	#START,@#STRTAD	;SETUP START ADDRESS
	JMP	START		;START PROGRAM

NOCOR:	.ASCIZ	/?OVR COR?/
	.IF DF	MBUILD
VMESAG:	.ASCIZ	"MBUILD V02-03  "

	.SBTTL	CODE TO WRITE MBUILD CORE IMAGE
	BR	BEGIN		;MBUILD ENTERED AT RE-ENTRY ADDRS
				;BY MSBOOT
BEGINM:	.CSIGEN	#FREEM,#DEFEXT,#0 ;GET NAME OF OUTPUT FILE
	BCS	MWERR		;ERROR IN COMMAND STRING
	MOV	#20000,R0	;WRITE FROM ADRESSES 0-37777
	MOV	#-1,OUCHAN	;USE CHANNEL 0 (DEFAULT IS 1)
	JSR	PC,WRITE	;WRITE CORE IMAGE ON CHANNEL 0
	BCS	MWERR		;SOMETHING IS WRONG WITH WRITE
	.CLOSE	0		;CLOSE CHANNEL 0
	BCS	MWERR		;SOMETHING WENT WRPMG
MBEXIT:	.EXIT			;RETURN TO MONITOR

MWERR:	.PRINT	#OUMES		;PRINT "?OUT ER?"
	BR	MBEXIT		;AND EXIT TO MONITOR
FREEM:	.ENDC

	.IF NDF	MBUILD
	.END BEGIN
	.IFF
	.END BEGINM
	.ENDC                                                                                                                                                                                                                                                                                                                                                                                                                                                                  