	.TITLE	RT-11 BATCH V01-03

; RT-11 BATCH COMPILER

; MARCH, 1975

; JD/DV

; COPYRIGHT (C) 1975

; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754

; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS
; SOFTWARE, OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED
; OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON EXCEPT
; FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE
; LICENSE TERMS. TITLE TO AND OWNERSHIP OF THE SOFTWARE
; SHALL AT ALL TIMES REMAIN IN DIGITAL.

; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
; DIGITAL ASSUMES NO RESPONSIBILITY FOR ANY ERRORS THAT
; MAY APPEAR IN THIS DOCUMENT

; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE
; OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DIGITAL.

	.SBTTL	SYMBOLS AND DEFINITIONS
;THE BATCH COMPILER HAS A HIGH SEG (PURE CODE) AND
;A LOW SEG (NOT SO PURE CODE)
;BATCH EXPECTS THAT R4 POINTS TO THE LOW SEG
;*******************************************************************
	PIC=	0		;SET TO 0 IF NO P.I.C. WANTED
;*******************************************************************

; ASCII CHARACTER DEFINITIONS

	NL=12			;NEW LINE;LINE FEED
	FORM=14			;FORM FEED
	RET=15			;RETURN;CARRIAGE RETURN
	CTRL.Z=32		;CONTROL Z;EOF
	SPC=40			;SPACE,BLANK

; RT-11 MONITOR DEFINITIONS

	FBMON$	=	1
	RONLY$	=	40000	;DEVICE IS READ ONLY
	SPECL$	=	10000	;DEVICE IS NON-RT-11-DIRECTORIED.
	BATBLK	=	6	;BLOCK 6 OF BA.SYS IS USED FOR BATCH STACK
	JSW	=	44
	ERRWRD	=	52	;RT-11 ERROR WORD
	SYSPTR	=	54
	$CSW	=	4	;OFFSET TO CHAN. 0
	CONFIG	=	300	;OFFSET TO MONITOR CONFIGURATION WD
	EMT16	=	316
	CONTXT	=	320
	CHAIN	=	400
	CHNTXT	=	510	;PLACE WHERE TEXT CAN BE FOUND ON CHAIN (RT11)


; BATCH COMPILER DEFINITIONS

SAVNUM=10		;# OF ARGS. SAVED ON BATCH STACK
			;PER RECURSION OF THE COMPILER.
ARGLST=	13		;NUMBER OF ARGUMENTS PASSED BETWEEN BATHND AND BATCH
BATSW1=	ARGS		;POINTER TO BATSW1 LOC. IN BATCH HANDLER
	SOURCE=	     4	;IF 1 GET A CHARACTER THROUGH
			;THE BATCH HANDLER. IF 0 LET
			;THE EMT GO TO THE MONITOR
	BSOURC=	 40000	;IF 1 INPUT COMES FROM THE
			;BATCH STREAM. IF 0 INPUT COMES
			;FROM THE CTY:.
	DESTON=	     2	;IF 1 OUTPUT TO BATCH
			;IF 0 OUTPUT TO RMON.
	BDESTN=	   100	;IF 1 BATCH LOG IS OUTPUT, IF 0 CTY: IS OUTPUT.
	DATA=	    40	;IF 1 CHARACTERS FOLLOWING ARE
			;USER DATA. IF 0 KMON.
	ACTIVE=	    20	;CTY IS ACTIVE.
	COMWAT=	    10	;A COMMAND IS WAITING
	BEXIT=	100000	;EXIT DURING DATA MODE
	BGET=	   200	;"\G" MODE
	HELP=	     1	; HELP MODE

INDATA	=	ARGS+2	;POINTER TO INDATA
ODATA	=	ARGS+4	;POINTER TO ODATA
OUTBUF	=	ARGS+6	;POINTER TO BATHND OUTPUT BUFFER
BATOPT	=	ARGS+10	;POINTER TO OUTPUT CHARACTER POINTER
BATOCT	=	ARGS+12	;POINTER TO OUTPUT CHARACTER COUNTER
BATICT	=	ARGS+14	;POINTER TO INPUT CHARACTER COUNTER
O$EXT	=	ARGS+16
O$TIN	=	ARGS+20
O$TOT	=	ARGS+22
O$PRN	=	ARGS+24
OUBSIZ	=	400		;SIZE OF BATHND OUTPUT BUFFER
	.SBTTL	LOW (IMPURE) SEGMENT DEFINITION
	.CSECT	UNPURE
	.GLOBL	BATSWT,TMPSWT,LINSIZ,LOWSEG

	LINSZ=	^D80		;LENGTH OF LINE BUFFER(MUST BE EVEN!)
	LOTSZ=	^D132		;LENGTH OF LINE OUTPUT BUFFER
	ERSIZE=	^D5		;MAXIMUM NUMBER OF ERROR MESSAGES/LINE
	INBSIZ=	400		;LENGTH OF EACH INPUT BUFFER
	OTBSIZ=	400		;LENGTH OF EACH OUTPUT BUFFER
	SOBSIZ=	400		;LENGTH OF TEMPORARY SOURCE OUTPUT BUFFER
	QSIZE=	4		;NUMBER OF EXTRA I/O QUEUE ELEMENTS
	DEFLOG=	100		;DEFAULT LOG FILE SIZE

.MCALL	..V1..,.REGDEF
.REGDEF
..V1..
.MCALL	.TTYIN,.DELETE,.CLOSE,.EXIT,.TTYOUT,.PRINT
.MCALL	.SRESET,.RCTRLO

.MACRO	ENTRLO	NAME,A1,A2,A3,A4,A5,A6,A7,A8,A9
	.CSECT	UNPURE
	.IF NB NAME
	NAME=.-LOWSEG
	.ENDC
	.IRP X,<A1,A2,A3,A4,A5,A6,A7,A8,A9>
	.IIF NB <X>,.WORD X
	.ENDR
	.CSECT	PROGRM
	.ENDM
;LOWSEG IS THE START OF THE IMPURE AREA
;*****THE COMPILER ASSUMES THAT BATSWT IS THE FIRST ENTRY IN*****
;*****LOWSEG. REFERENCES TO BATSWT ARE ABBREVIATED TO (R4).*****

LOWSEG:	ENTRLO	BATSWT,0		;BATCH CONTROL SWITCHES
		ABORT= 100000		;DON'T ATTEMPT TO RUN AFTER COMPILE
		DATDOL=	40000		;DATA/DOLLARS SET
		NO=	20000		;/"NO"SWITCH IS SET
		CTYOUB=	10000		;"\@" CTY: OUTPUT SENT
		LOGOUB=	 4000		;"\C" LOG OUTPUT
		DATOUB=	 2000		;"\D" USER DATA
		COMOUB=	 1000		;"\E" KMON REQUEST
		JOB=	  400		;$JOB SEEN
;******* KEEP MAKEB AT 200 *******
		MAKEB=	  200		;MAKE BATCH LINKAGE FROM .TTYIN FIRST
		COMMA=	  100		;COMMA TERMINATED COMMAND
		BFORLI=	   40		;NEXT LINK REQUIRES FORTRAN'S FORLIB.OBJ
		UNIQUE=	   20		;FOR UNIQUE MATCHES
		BANNER=	   10		;PRINT BANNER ON $JOB,$EOJ
		RT11=	    4		;RT11 DEFAULT ON NO DOLLAR IN COLUMN 1
		TIME=	    2		;PRINT TIME OF DAY
		MAKE=	    1		;MAKE SOURCE FILE

	ENTRLO	BATSW2,0
	EOJ=		     1
	XSWT=		     2		;(DEBUG ONLY)
	;BEOF=		     4
	LSTDAT=		    10		;LIST DATA SECTIONS
	BNOEOJ=		    20		;$JOB OR $SEQ SEEN BEFORE PREVIOUS $EOJ
	STAROK=		    40		;OK TO LET * NAME OR EXTENSION GO THROUGH
	STARFD=		   100		;STAR SEEN IN FD FIELD
	;MAKEB=		   200		;DITTO FROM BATSWT
	COMSWB=		   400		;COMMAND SWITCHES
	LSTBIT=		  1000		;REQUEST TEMPORARY LISTING
	SEQ=		  2000		;$SEQ HAS APPEARED IN STREAM
	SBIT=		 4000		;/S SWITCH ON THIS COMMAND
	FIRST=		 10000		;1ST CARD OF THIS JOB PROCESSED
	;ABORT=		100000		;SECOND TIME THROUGH ABORTT
	ENTRLO	TMPSWT,0		;TEMPORARY COMMAND SWITCH
	ENTRLO	COMSWT,.-.
	ENTRLO	LINSIZ,LINSZ		;INPUT LINE BUFFER SIZE

;********* KEEP IN ORDER ********
	BFREE=	1			;BUFFER STATUS BIT, 0 INDICATES BUFFER IS FREE
	BWAIT=	2			;IN I/O WAIT (BFREE*2)
	BEOF=	4			;END OF FILE IN BUFFER
	ENTRLO	BINLCT,0		;LAST BUFFER CHARACTER COUNTER
	ENTRLO	INSTAT,0		;INPUT BUFFER STATUS BYTES
	ENTRLO	ICHRPT,.-.		;INPUT CHARACTER POINTER
	ENTRLO	BINCTR,0		;INPUT BUFFER COUNTER
	ENTRLO	BINARG,10*400+3		;INPUT FILE EMT ARG. LIST
	ENTRLO	BATIBK,0		;INPUT BLOCK #
	ENTRLO	BATIBP,.-.,INBSIZ,0	;INPUT BUFFER ADDRESS,SIZE,WAIT I/O

	ENTRLO	BOTLCT,OTBSIZ*2		;LAST BUFFER CHARACTER COUNTER
	ENTRLO	OTSTAT,BFREE*400+BFREE	;OUTPUT BUFFER STATUS
	ENTRLO	OCHRPT,.-.		;OUTPUT CHARACTER POINTER
	ENTRLO	BOTCTR,OTBSIZ*2		;OUTPUT COUNTER
	ENTRLO	BOTARG,11*400+0		;OUTPUT EMT ARG. LIST
	ENTRLO	BATOBK,0		;OUTPUT BLOCK #
	ENTRLO	BATOBP,.-.,OTBSIZ,0	;OUTPUT BUFFER ADDRESS,SIZE,WAIT I/O
;*********************************
	ENTRLO	STACK,.-.		;STACK POINTER SAVE AREA
	ENTRLO	ARGS			;ARGUMENTS EXCHANGED BETWEEN BATCH AND BA
	.CSECT	UNPURE
	.BLKW	ARGLST

;********* CSI BUFFER *************
	ENTRLO	SPC0,0,0,0,0,0	;ENTRIES ARE: DEVICE, FILE NAME,
	ENTRLO	SPC1,0,0,0,0,0	;FILE EXTENSION, AND REQUESTED SIZE.
	ENTRLO	SPC2,0,0,0,0,0
	ENTRLO	SPC3,0,0,0,0
	ENTRLO	SPC4,0,0,0,0
	ENTRLO	SPC5,0,0,0,0
	ENTRLO	SPC6,0,0,0,0
	ENTRLO	SPC7,0,0,0,0
	ENTRLO	SPC8,0,0,0,0
;**********************************

	ENTRLO	LINIMP,0		;POINTER TO COMMAND LINE BUFFER
	ENTRLO	LINIMM			;LINIMM IS LINBAD
	.CSECT	UNPURE
.NLIST	BIN
LINBAD:	.REPT	LINSZ			;INPUT LINE BUFFER
	.BYTE	0
	.ENDR
	.BYTE	-1			;FLAG
	.EVEN
	ENTRLO	LINIMS
	.CSECT	UNPURE
	.REPT	LINSZ			;INPUT LINE BUFFER SAVE AREA
	.BYTE	0
	.ENDR
	.EVEN
	ENTRLO	LIBLST
	.CSECT	UNPURE
	.ASCIZ	/FORLIB/
	.REPT	LINSZ-7
	.BYTE	0
	.ENDR
.LIST	BIN
	.EVEN
BATIBF:	.BLKW	INBSIZ*2		;INPUT BUFFERS
BATOBF:	.BLKW	OTBSIZ*2		;OUTPUT BUFFERS
	ENTRLO	QSET
	.CSECT	UNPURE
	.BLKW	7*QSIZE			;ROOM FOR I/O QUEUE ELEMENTS
	.SBTTL	HIGH SEGMENT SECTION DEFINITIONS
;******* HIGH SEG SECTIONS *******

	.CSECT TABEL1
	.GLOBL	KEYTAB
KEYTAB:
	.CSECT TABEL2
	.GLOBL	KEYWRD
KEYWRD:	.BYTE 0
	.CSECT TABEL3
	.GLOBL	SWIT
SWIT:	.BYTE 0
	.CSECT TABEL4
	.GLOBL	SWTADD
SWTADD:
	.CSECT ERRLST
	.GLOBL	ERRADD
ERRADD:
	.CSECT	PROGRM

	.SBTTL	MACRO DEFINITIONS
.MACRO ADDR,ADDRESS,REG
	.IF EQ PIC
	MOV	#ADDRESS,REG
	.IFF
	MOV	PC,REG
	ADD	#ADDRESS-.,REG
	.ENDC
	.ENDM

.MACRO	ADDRLO,ADDRESS,REG	;FOR LOW SEG ADDRESSES
	.IF IDN ADDRESS,LINIMM
	MOV	LINIMP(R4),REG
	.IFF
	MOV	#ADDRESS,REG
	ADD	R4,REG
	.ENDC
	.ENDM

	SWTNUM=-1
.MACRO SWTDEF,SWITCH
	SN$'SWITCH=SWTNUM
	SWTNUM=SWTNUM-1
	.CSECT	TABEL3
	.=.-1
	C=0
	.IRPC	X,SWITCH
	.IIF EQ C, .BYTE -''X
	.IIF NE C, .BYTE ''X
	C=C+1
	.ENDM
	.BYTE 0
	.CSECT	TABEL4
	.IF EQ PIC
	.WORD	SA$'SWITCH
	.IFF
	.WORD	SA$'SWITCH'-SWTJMP-2
	.ENDC
	.CSECT	PROGRM
	.ENDM

.MACRO	SAVE,REG0,REG1,REG2,REG3,REG4,REG5
	.IRP X,<REG0,REG1,REG2,REG3,REG4,REG5>
	.IIF NB <X>,MOV X,-(SP)
	.ENDR
	.ENDM

.MACRO	RESTOR,REG0,REG1,REG2,REG3,REG4,REG5
	.IRP X,<REG5,REG4,REG3,REG2,REG1,REG0>
	.IIF NB <X>,MOV (SP)+,X
	.ENDR
	.ENDM

BITNUL=100000		;NO SWITCHES SPECIFIED FOR COMMAND

; COMMAND IS USED TO DFINE A BATCH COMMAND AND ITS LEGAL SWITCHES

.MACRO COMMAND,NAME,S,S1,S2,S3,S4,S5,S6,S7,S8,S9,SA,SB,SC,SD,SE,SF
	.SBTTL     $'NAME PROCESSOR
	.CSECT	TABEL1
DSW'NAME:	.WORD	0
	.IF EQ PIC
	.WORD	C$$'NAME
	.IFF
	.WORD	C$$'NAME'-FNDJMP-2
	.ENDC
	.CSECT	TABEL2
	.=.-1
CN$'NAME:	.ASCII	/NAME/
	.BYTE	SN$NUL			;DUMMY END OF LINE
	C=40000
	.IRP X,<S1,S2,S3,S4,S5,S6,S7,S8,S9,SA,SB,SC,SD,SE,SF>
	.IF NB <X>
	.BYTE SN$'X
	BIT'X=C
	.ENDC
	C=C/2
	.ENDR
	.BYTE 0
	.CSECT	PROGRM
.LIST	MEB
C$$'NAME:
.NLIST	MEB
	.ENDM

.MACRO	DEFAULT	SWITCH	A,B,C,D,E,F,G,H,I,J,K,L,M,N,O
	BIT=0
	.CSECT	TABEL1
	.=.-4
X=BIT'A!BIT'B!BIT'C!BIT'D!BIT'E!BIT'F!BIT'G!BIT'H!BIT'I!BIT'J
.WORD	BITNUL!X!BIT'K!BIT'L!BIT'M!BIT'N!BIT'O
	.=.+2
	.CSECT	PROGRM
	.ENDM
.MACRO	SWITCH	NAME
	.SBTTL	SWITCH	NAME
SA$'NAME:
	.ENDM

.MACRO LABEL A,B			;CREATE A LABEL
A'B:
	.ENDM

.MACRO INCLBL A,B			;AN INCREMENTAL LABEL
	B=B+1				;INC B FIRST
	LABEL A,\B			;MAKE LABEL A1,A2,....
	.ENDM

	ERRNUM=0
	SERRNM=0
	CERRNM=0

; ENTMES ENTERS AN ERROR MESSAGE IN THE ERRLST CSECT
.MACRO	ENTMES,LABEL,MESSAGE,CR
	.IF NB <MESSAGE>
	.CSECT	ERRLST
LABEL:	.ASCII	%MESSAGE%
	.IF NB CR
	.BYTE 0
	.IFF
	.BYTE 200
	.ENDC
	.CSECT	PROGRM
	.ENDC
	.ENDM

.MACRO	STRING	ADDRESS,LABEL,MESSAGE,CR
	ENTMES	LABEL,MESSAGE,CR
	.IF	EQ	PIC
	JSR	R5,ADDRESS
	.IF	NB	LABEL
	.WORD	LABEL
	.IFF
	.WORD	NULINE
	.ENDC
	.IFF
	.=.+2
	.IF	NB	LABEL
	TST	LABEL
	.IFF
	TST	NULINE
	.ENDC
	.=.-6
	JSR	R5,ADDRESS
	.=.+2
	.ENDC
	.ENDM
.MACRO	AERROR A,B
	STRING	ERRLOG,A'B
	.ENDM

	.CSECT	ERRLST
NULINE:	.BYTE	200			;NULL LINE

;	*** ADDED 9/29/78  D.SHEPPERD ATARI,INC
.MACRO	AOUT	LABEL,TEXT,CR
	STRING	AOUX,LABEL,TEXT,CR
.ENDM
; *** END OF ADD

.MACRO	OUTLOW	LABEL
	ADDRLO	LABEL,R2
	JSR	PC,OUTPUL
	.ENDM

.MACRO COMOUT	LABEL,TEXT,CR
	STRING	COMOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	COMLOW	LABEL
	COMOUT	NULINE
	OUTLOW	LABEL
	.ENDM

.MACRO	LOGOUT	LABEL,TEXT,CR
	STRING	LOGOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	LOGLOW	LABEL
	LOGOUT	NULINE
	OUTLOW	LABEL
	.ENDM

.MACRO	DATOUT,LABEL,TEXT,CR
	STRING	DATOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	DATLOW	LABEL
	DATOUT	NULINE
	OUTLOW	LABEL
	.ENDM

.MACRO	MESOUT,LABEL,TEXT,CR
	STRING	MESOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	MESLOW	LABEL
	MESOUT	NULINE
	OUTLOW	LABEL
	.ENDM
.MACRO	OUTPUT,LABEL,TEXT,CR
	STRING	OUTSTR,LABEL,TEXT,CR
	.ENDM
.MACRO	FOUT,LABEL,TEXT,CR
	STRING	FOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	FOUTLO,LABEL
	FOUT
	OUTLOW	LABEL
	.ENDM


.MACRO	GOUT,LABEL,TEXT,CR
	STRING	GOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	GOUTLO,LABEL
	GOUT
	OUTLOW	LABEL
	.ENDM


.MACRO	HOUT,LABEL,TEXT,CR
	STRING	HOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	HOUTLO,LABEL
	HOUT
	OUTLOW	LABEL
	.ENDM


.MACRO	IOUT,LABEL,TEXT,CR
	STRING	IOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	IOUTLO,LABEL
	IOUT
	OUTLOW	LABEL
	.ENDM


.MACRO	JOUT,LABEL,TEXT,CR
	STRING	JOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	JOUTLO,LABEL
	JOUT
	OUTLOW	LABEL
	.ENDM

.MACRO	KOUT,LABEL,TEXT,CR
	STRING	KOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	KOUTLO,LABEL
	KOUT
	OUTLOW	LABEL
	.ENDM


.MACRO	LABOUT,LABEL,TEXT,CR
	STRING	LABOUX,LABEL,TEXT,CR
	.ENDM

.MACRO	LABLOW,LABEL
	LABOUT
	OUTLOW	LABEL
	.ENDM
.MACRO	CHROUT,X
	.IF NB <X>
	.IF IDN X,<#',>
	JSR PC,.COMMA
	.MEXIT
	.ENDC
	.IF IDN X,#32
	JSR	PC,.CTRLZ
	.MEXIT
	.ENDC
	.IF IDN X,#'0
	JSR	PC,.ASCI0
	.MEXIT
	.ENDC
	.IF IDN X,#12
	JSR	PC,.LF
	.MEXIT
	.ENDC
	.IF IDN X,#'=
	JSR PC,.EQUAL
	.MEXIT
	.ENDC
	.IF IDN X,#'2
	JSR PC,.ASCI2
	.MEXIT
	.ENDC
	.IF IDN X,#40
	JSR PC,.SPACE
	.MEXIT
	.ENDC
	.IF IDN X,R2
	JSR PC,.R2
	.MEXIT
	.ENDC
	.IF IDN X,(SP)+
	JSR PC,.SPPOP
	.MEXIT
	.ENDC
	.IF IDN X,#'A
	JSR PC,.ASCIA
	.MEXIT
	.ENDC
	MOVB	X,R3
	.ENDC
	JSR	PC,PUTCHR
	.ENDM

.MACRO	INCVAR,X
	.IF NB <X>
	MOVB	X,R3
	.ENDC
	JSR	PC,INCVAX
	.ENDM

.MACRO	CR.LF
	JSR	PC,CROUTP
	.ENDM
.MACRO	INTVAR,V,X
	KOUT	NULINE
	CHROUT	V
	CHROUT	#'1
	CHROUT	X
	.ENDM

.MACRO	GETVAR,V
	KOUT	NULINE
	CHROUT	V
	CHROUT	#'2
	.ENDM

.MACRO	IFOUT	V,X,LABEL,TEXT,CR
	IOUT
	CHROUT	V
	CHROUT	X
	OUTPUT	LABEL,TEXT,CR
	.ENDM

.MACRO	SCAN,LABEL,TEXT
	.IF	NB	LABEL
	ENTMES	LABEL,TEXT
	ADDR	LABEL,R1
	.ENDC
	JSR	R5,SCANX
	.ENDM

.MACRO ERROR MESSAGE
	.CSECT ERRLST
	INCLBL	ERR,ERRNUM
	.ASCIZ	/MESSAGE/
	.CSECT PROGRM
	AERROR	ERR,\ERRNUM
	.ENDM

.MACRO	SPRINT	A,B
	ADDR	A'B,R0
	.PRINT
	.ENDM

.MACRO	CERROR	MESSAGE
	.CSECT	ERRLST
	INCLBL	CERR,CERRNM
	.ASCIZ	/MESSAGE/
	.CSECT	PROGRM
	SPRINT	CERR,\CERRNM
	.ENDM

.MACRO	SERROR	MESSAGE
	.CSECT	SERRLST
	INCLBL	SERR,SERRNM
	.ASCIZ	/MESSAGE/
	.CSECT	PROGRM
	SPRINT	SERR,\SERRNM
	.ENDM
.MACRO	GETFD	NAME,S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15
	.CSECT	ERRLST
NAME:
	C=40000
	.BYTE	SN$NUL
	NAME'NUL=100000
	.IF NB S1
	.IRP	X,<S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15>
	.IF NB <X>
	.BYTE SN$'X
	NAME''X=C
	.ENDC
	C=C/2
	.ENDR
	.BYTE 0
	.ENDC
	.CSECT	PROGRM
	.IF EQ PIC
	JSR	R5,GETFD$
	.WORD	NAME
	.IFF
	.=.+2
	TST	NAME+2
	.=.-6
	JSR	R5,GETFD$
	.=.+2
	.ENDC
	.WORD	0
	.ENDM

.MACRO	EXCLUSIVE	NAME,S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15
	.=.-2
	C=0
	.IRP	X,<S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15>
	.IF NB <X>
	C=C+NAME''X
	.ENDC
	.ENDR
	.WORD ^C<C>
	.WORD	0
	.ENDM
.MACRO	FINDFD	NAME,S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15
	JSR	R5,FDFIND
	.IF NB S1
	C=0
	.IRP	X,<S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,S14,S15>
	.IF NB <X>
	C=C+NAME''X
	.ENDC
	.ENDR
	.WORD C
	.IFF
	.WORD	NAME'NULL
	.ENDC
	.ENDM

.MACRO	OUTFD.
	JSR	PC,OTFD.$
	.ENDM

.MACRO	OUTFD
	JSR	PC,OUTFD$
	.ENDM

.MACRO	OUTFDC
	JSR	PC,OTFDC$
	.ENDM

.MACRO	UNHOOK	NAME,NUMBER
	.IF NE NUMBER
	MOV	@NAME(R4),NUMBER*2(R0)
	ADD	NAME(R4),NUMBER*2(R0)
	SUB	R0,NUMBER*2(R0)
	.IFF
	MOV	@NAME(R4),(R0)
	ADD	NAME(R4),(R0)
	SUB	R0,(R0)
	.ENDC
.ENDM

.MACRO	SPACES
	JSR	PC,SPACE$
	.ENDM

.MACRO	DMPOBJ	X
	JSR	R5,OBJDMP
	.WORD	X
	.ENDM
.MACRO	GETSAV
	ADDR	SAVTMP,R2
	.ENDM

.MACRO	LSTSOU
	ADDRLO	SOUTMP,R2
	.ENDM

.CSECT	ERRLST
SAVTMP:	.ASCIZ	"000000.SAV"
	ENTRLO	SOUTMP,"00,"00,"00,".S,"OU,0

.MACRO	GETOBJ
	JSR	R5,OBJSOU
	.WORD	OBJTMP
	.ENDM

.MACRO	LSTOBJ
	ADDRLO	OBJTMP,R2
	.ENDM

.MACRO	GETLST
	JSR	PC,LSTLST
	.ENDM

ENTRLO OBJTMP,"00,"00,"0/,".O,"BJ,0
.MACRO	ISIT	LABEL,ADDRESS,ARGS
	.IF NB <ARGS>
	.CSECT	ERRLST
LABEL:	.ASCIZ	ARGS
	.CSECT	PROGRM
	.ENDC
	.IF EQ PIC
	JSR	R5,ISIT$
	.WORD	LABEL
	.WORD	ADDRESS
	.IFF
	.=.+4
	TST	ADDRESS+2
	.=.-6
	TST	LABEL
	.=.-6
	JSR	R5,ISIT$
	.=.+4
	.ENDC
	.ENDM

.MACRO	CHECK	ARG
	.IF	NB	ARG
	 .NTYPE	SYM,ARG
	 .IF NZ SYM-13
	 MOVB	ARG,R2
	 JSR	PC,CHRCK
	 .IFF
	 JSR	PC,CHRCHK
	.ENDC
	.IFF
	JSR	PC,CHRCK
	.ENDC
	.ENDM

.SBTTL	SWITCH DEFINITIONS
	.IRP	X,<NULL,DOLLARS,WAIT,RUN,DATA,MAP,PHYSICAL,DELETE>
	SWTDEF	X
	.ENDR

	.IRP	X,<BASIC,CREF,FORTRAN,MACRO,INPUT,TIME,LOGICAL,SOURCE,EXECUTE>
	SWTDEF	X
	.ENDR
	.IRP	X,<WRITE,VID,LIST,OBJECT,OUTPUT,RT11,BANNER,UNIQUE,LIBRARY>
	SWTDEF X
	.ENDR
	.SBTTL	COMPILER ENTRY POINT
	.CSECT	PROGRM

; BATCH STARTS BY INITIALIZING ITS BUFFER POINTERS AND THEN DOING
; A .DSTAT ON THE BA HANDLER. THIS SERVES TWO PURPOSES: IT TESTS
; FOR BA HANDLER RESIDENCY AND  SUPPLIES THE BA ENTRY POINT
; FOR USE IN THE START2 CODE. IN ADDITION, A TEST IS MADE FOR
; THE LOG HANDLER, WHICH MUST ALSO BE RESIDENT AND ASSIGNED TO LOG:

	.GLOBL	START
START:	ADDR	LOWSEG,R4		;PUT ADDRESS OF IMPURE AREA IN R4
	MOV	SP,STACK(R4)		;SAVE STACK PTR FOR RESET
	MOV	#LINIMM,LINIMP(R4)	;LINIMP->COMMAND LINE BUFFER
	ADD	R4,LINIMP(R4)		;DON'T DO ADDRLO LINIMM,LINIMP(R4)
	.RCTRLO				;RESET CTRL/O
	MOV	#QSET,-(SP)
	ADD	R4,(SP)
	MOV	#QSIZE,R0
	EMT	^O353			;.QSET
	ADDRLO	BATIBF-LOWSEG+INBSIZ+INBSIZ,R0
	MOV	R0,BATIBP(R4)		;INITIALIZE I/O BUFFER POINTERS
	ADDRLO	BATOBF-LOWSEG,R0
	MOV	R0,OCHRPT(R4)
	ADD	#OTBSIZ*2,R0
	MOV	R0,BATOBP(R4)
	MOV	#WDBLK5,-(SP)		;ONLY NEED 4 OF THE 5
	ADD	R4,(SP)			;USE WDBLK5 FOR .DSTAT ON BA
	ADDR	LOGNAM,R0		;R0->LOG: (RAD50)
	EMT	16*20+2			;.DSTATUS
.ENABL	LSB
	BCS	1$			;BR IF LOG: NOT ASSIGNED
	TST	WDBLK5+4(R4)		;IS IT RESIDENT?
	BNE	2$			;BR IF HANDLER IN MEMORY
	SERROR	<PLEASE LOAD LOG HANDLER>
	.EXIT
1$:	SERROR	<PLEASE ASSIGN LOG,LST>
	.EXIT
2$:	MOV	WDBLK5(R4),LOGTYP(R4) ;SAVE DEVICE STATUS OF LOG
	BIT	#SPECL$+RONLY$,LOGTYP(R4) ;CAN IT BE USED FOR LOG?
	BEQ	3$			;IT'S OKAY
	SERROR	<ILLEGAL LOG DEVICE>
	.EXIT
3$:	ADDR	BATHND,R0
	MOV	#WDBLK5,-(SP)
	ADD	R4,(SP)
.DSABL	LSB
	EMT	16*20+2			;DSTATUS
	MOV	WDBLK5+4(R4),-(SP)
	BNE	START1
NOTRES:	SERROR	<BATCH HANDLER NOT RESIDENT>
	.EXIT

BATHND:	.RAD50	/BA /
	ENTRLO	LOGTYP,0		;LOG DEVICE STATUS SAVE AREA



; TEST FOR BA HANDLER. IF BA IS RESIDENT, DO A NULL READ TO BA
; TO INITIALIZE IT. BA WILL RETURN A LIST OF ITS LOCATIONS
; WHICH MUST BE PRESERVED ON A RECURSION.

START1:	ADDR	BATHND,R3	;R3 -> BATCH HANDLER NAME
	ADDRLO	WDBLK2+2,R0	;DO A .LOOKUP ON CH. 16
	MOV	R3,(R0)		;FOR BA .SYS
	MOV	#1*400+16,-(R0)
	EMT	375
; AN ERROR SHOULDN'T OCCUR HERE BECAUSE BA IS NOT FILE-STRUCTURED.
	BCS	NOTRES		;BRANCH IF BA.SYS NOT RESIDENT
	ADDRLO	ARGS,R3		;O.K., DO A NULL READ TO BA.SYS
	ADDRLO	ARGARG,R0
	MOV	R3,4(R0)
	EMT	375		;READW BATHND (INITIALIZE THE HANDLER)
	BCC	START2
	SERROR	<BAD COPY OF HANDLER>
	.EXIT


; RELOCATE POINTERS PASSED FROM BA HANDLER, INITIALIZE BATCH
; STACK BLOCK ON SY:, THEN PROCESS THE COMPILER COMMAND LINE.

START2:	ADD	(SP),(R3)+	;RELOCATE THE POINTER OFFSETS
	BCC	START2		;UNTIL NEGATIVE OFFSET FOUND.
	TST	@BATSW1(R4)	;TEST FOR $CALL
	BNE	GETCOM		;BR IF THIS IS A $CALL
	JSR	PC,RDSTK	;ELSE READ IN BATCH STACK
	MOV	#-<SAVNUM*2-2>,@BATOBP(R4) ;SET 1ST WORD TO INITIALIZE
	JSR	PC,START3	;AND WRITE IT BACK OUT.
GETCOM:	CLR	INSTAT(R4)	;RESET INSTAT IN CASE OF ERROR
	CLR	BINCTR(R4)	;ZERO INPUT COUNTER
	CLR	BATIBK(R4)	;AND INPUT BLOCK NUMBER
	CLR	(R4)		;CLEAR BATSWT
	CLR	BATSW2(R4)	;AND BATSW2
	ADDRLO	SPC0,R0
	MOV	R0,-(SP)
	ADDR	DEFEXT,R0	;R0 -> DEFAULT EXTENSIONS
	MOV	R0,-(SP)
	CLR	-(SP)
2$:	BIT	#CHAIN,@#JSW
	BEQ	1$			;DID WE COME FROM CHAIN??
	BIC	#CHAIN,@#JSW		;YES
	MOV	#CHNTXT,(SP)		;PICK UP CHAIN TEXT
1$:	EMT	16*20+5			;.CSISPC
	BCC	CSIOK			;BR IF LEGAL COMMAND
	TSTB	@#ERRWRD		;WHAT WAS THE ERROR?
	BNE	ILLDEV			;BR IF ILLEGAL DEVICE
	SERROR	<ILLEGAL COMMAND LINE>
	BR	GETCOM
ILLDEV:	SERROR	<ILLEGAL DEVICE>
	BR	GETCOM
; EMT ARGUMENT LIST FOR BATCH HANDLER INITIALIZATION
	ENTRLO	ARGARG,10*400+16,0,.-.,0,0

DEFEXT:	.RAD50	/BAT/		;INPUT DEFAULT
	.WORD	0		;SPC0, CTL OR MAKE FILE, NO DEFAULT
LOGNAM:	.RAD50	/LOG/		;SPC1, BATCH LOG PUTPUT
	.WORD	0		;NO SPC2 YET

CSIOK:	TST	SPC2(R4)
	BEQ	START4
	SERROR	<TOO MANY OUTPUT FILES>
.SBTTL COMPILER SWITCH PROCESSING:
START4:	MOV	(SP)+,R0	;# OF SWITCHES TO R0
	BNE	2$		;BR IF ANY SWITCHES TO PROCESS
	JMP	ENTSPC		;NO, GO DO THE ENTERS
2$:	ADDR	SWTLST,R1	;R1->LIST OF SWITCH NAMES
	ADDR	JMPSWT,R2	;R2->TABLE OF OFFSETS TO SWITCH ROUTINES
	DEC	R0		;DECREMENT SWITCH COUNT
	MOV	(SP)+,R3	;PICK UP A SWITCH
	SAVE	R0		;PUT SWITCH COUNT BACK ON STACK
1$:	TST	(R2)+		;BUMP OFFSET TABLE PTR.
	CMPB	(R1)+,R3	;COMPARE SWITCH WITH LIST
	BGT	1$		;FIND THE SWITCH
	BNE	BDSWT		;CAN'T FIND IT
	MOV	@R2,-(SP)	;GET OFFSET TO SWITCH
	ADD	PC,@SP		;MAKE IT ABSOLUTE
	ASL	R3		;CARRYSET => SWITCH VALUE
JMPSWT:	JMP	@(SP)+		;JUMP TO PROPER SWITCH
	SWTX-JMPSWT+2		;X, MISTRY SWITCH. (DEBUG ONLY)
	SWTV-JMPSWT+2
	SWTU-JMPSWT+2
	SWTT-JMPSWT+2
	SWTS-JMPSWT+2
	SWTR-JMPSWT+2
	SWTN-JMPSWT+2
	SWTM-JMPSWT+2
	SWTD-JMPSWT+2
	SWTB-JMPSWT+2		;***** REVERSE ALPHABETIC ORDER *****
SWTLST:	.ASCIZ	"XVUTSRNMDB"
	.EVEN

; TEST FOR SWITCH BEING ENTERED FROM CTY, WITH BA.SYS IDLE. THAT IS
; ILLEGAL FOR /B,/D,/M,/S,/R.

TSTSWT:	TST	@BATSW1(R4)	;IS BA ACTIVE?
	BEQ	BDSWT		;BR IF BA INACTIVE
	RTS	PC		;O.K.
BDSWT:	SERROR	<BAD SWITCH>
BRGTCM:	BR	GETCOM

	.SBTTL	/X COMPILER SWITCH
; INPUT FILE IS ASSUMED TO BE PRE-COMPILED.
SWTX:	BCS	BDSWT
	BIS	#XSWT,BATSW2(R4)	;INPUT ALREADY COMPILED
	BR	START4

	.SBTTL	/V COMPILER SWITCH
; PRINT VERSION I.D. IF NO INPUT FILE SKIP ANY MORE PROCESSING.
SWTV:	BCS	BDSWT
	.PRINT	#VERID		;PRINT VERSION I.D. MESSAGE
	TST	SPC3(R4)	;WAS THERE AN INPUT FILE?
	BEQ	GETCOM		;BRANCH IF NOT
	BR	START4		;CONTINUE
	.GLOBL	VERID
VERID:	.ASCIZ	/BATCH V01-04 /
.EVEN
	.SBTTL	/U COMPILER SWITCH
; THIS SWITCH PERMITS THE BATCH HANDLER TO BE UNLOADED AFTER
; EXITING FROM THE COMPILER.

SWTU:	BCS	BDSWT
	MOV	@#SYSPTR,R0	;MAKE R0 POINT TO
	MOV	EMT16(R0),-(SP)	;LIST OF EMT 16 FUNCTIONS
	ADD	(SP)+,R0
	UNHOOK	O$TIN,0		;REMOVE BATCH HANDLER
	UNHOOK	O$TOT,1		;HOOKS FROM MONITOR.
	UNHOOK	O$EXT,10
	UNHOOK	O$PRN,11
	CLR	@BATSW1(R4)
	SERROR	<!UNLOAD BA!> ;PRINT PROMPTING MESSAGE
	.EXIT

	.SBTTL	/T COMPILER SWITCH
SWTT:	BCC	BDSWT		;/T:N N=0=NO TIME N<>0=TIME, MUST HAVE N
	MOV	2(SP),R2	;SWITCH VALUE TO R2
	MOV	(SP)+,(SP)	;REPLACE WITH SWITCH COUNT
	TST	R2		;TEST VALUE FOR ZERONESS
	BEQ	1$
	BIS	#TIME,(R4)	;PRINT TIME OF DAY
	BR	START4
1$:	BIC	#TIME,(R4)	;DON'T PRINT TIME OF DAY
ST4LNK:	BR	START4
	.SBTTL	/S COMPILER SWITCH
; THE /S SWITCH IS USED BY BATCH TO CALL ANOTHER BATCH STREAM.
; IT CAUSES THE CURRENT BA HANDLER STACK TO BE PUSHED DOWN
; SO IT CAN CONTINUE WHERE IT LEFT OFF WHEN THE NEW BATCH STREAM
; DECLARES END OF JOB.

SWTS:	BCS	SWTU		;BR IF ILLEGAL VALUE
	JSR	PC,TSTSWT	;TEST IF BA ACTIVE
	BIS	#SBIT,BATSW2(R4) ;FLAG FOR LATER ACTION
	BR	ST4LNK		;CONTINUE PROCESSING

; EOJSUB -- SUBROUTINE SHARED BY /S,/R SWITCHES. EOJSUB PUSHES THE
; CURRENT BATCH  HANDLER PARAMETERS ONTO THE BATCH "STACK", WHICH
; IS STORED IN PHYSICAL BLOCK 5 OF THE SYSTEM DEVICE. IT 
; DECREMENTS THE BLOCK # OF THE CURRENT INPUT FILE BEFORE STORING
; IT SO THAT THE BLOCK MAY BE RE-READ WHEN BATCH RETURNS FROM A CALL.

EOJSUB:	JSR	PC,RDSTK	;READ BATCH STACK INTO MEMORY
	MOV	BATOBP(R4),R0	;R0->CURRENT PLACE IN STACK
	ADD	#SAVNUM*2,(R0)	;MOVE FOREWARD # OF BYTES TO SAVE
	CMP	#360,(R0)	;TEST FOR STACK  FULL
	BLT	BSOUFL		;BATCH STACK OVERFLOW
	ADD	(R0),R0
	MOV	BATICT(R4),R1	;R1 -> INPUT CHARACTER COUNT
	MOV	(R1),(R0)+	;BATICT
	MOV	-(R1),(R0)+	;BATIPT
	MOV	INDATA(R4),R1
	TST	(R1)+
	DEC	(R1)		;SUBTRACT 1 FROM THE BLOCK NUMBER
	MOV	(R1)+,(R0)+	;INBLOK
	ADD	#6,R1
	JSR	PC,WRTSTK	;WRITE OUT BATCH STACK
	RTS	PC

	.SBTTL	WRTSTK,START3,RDSTK SUBROUTINES
; WRTSTK -- COMMON SUBROUTINE USED BY /R AND /S CODE TO WRITE OUT
; 		THE BATCH STACK. USES R0,R2,R5.
;
; RDSTK -- SUBROUTINE TO READ INTO MEMORY THE BATCH STACK(BLK 5 OF SY:BA.SYS)
;		USES R0,R1

WRTSTK:	JSR	PC,BLT10		;INSAV,INSAV+2,INSAV+4,INSAV+6,INSAV+10
START3:	ADDRLO	STKBLK,R0
	MOV	#11*400+16,(R0)		;.WRITW CHAN. 16
	EMT	375
	BCS	WTBSER			;WRITE BATCH STACK ERROR
	.CLOSE	16
CALRTP:	RTS	PC

WTBSER:	MOV	PC,R0			;SAVE OFFENDING PC
	BR	FTLNK			;TAKE FATAL EXIT

RDSTK:	.CLOSE	16			;MAKE SURE ITS CLOSED
	ADDRLO	WDBLK2+2,R0		;WDBLK2 IS ARG. LIST
	MOV	BATOBP(R4),STKBLK+4(R4)
	ADDR	BATSTK,R1		;R1 -> BATCH STACK F.D.
	MOV	R1,(R0)			;PUT IN ARG. LIST
	MOV	#1*400+16,-(R0)		;PUT IN EMT CODE
	EMT	375			;.LOOKUP
	BCS	1$			;FATAL ERROR!
	ADDRLO	STKBLK,R0
	MOV	#10*400+16,(R0)
	EMT	375			;.READW
	BCC	CALRTP			;BR IF READ O.K.
	MOV	PC,R0			;SAVE OFFENDING PC
	BR	FTLNK			;TAKE FATAL EXIT


1$:	MOV	PC,R0			;SAVE PC FOR ANALYSIS
FTLNK:	JMP	BATFTL			;GO TO FATAL EXIT
BSOUFL:	ERROR	<BATCH STACK OVERFLOW>
	.EXIT
	.SBTTL	/R COMPILER SWITCH
SWTR:	BCS	SWTS
	JSR	PC,TSTSWT	;TEST FOR BA ACTIVE
SWTR1:	JSR	PC,RDSTK	;READ BATCH STACK INTO BATOBF
	MOV	BATOBP(R4),R1	;R1 -> STACK
	TST	(R1)		;IS IT EMPTY?
	BMI	BATFIN		;BR IF SO, WE'RE DONE!
	ADD	(R1),R1		;R1 -> CURRENT PLACE IN STACK
	SUB	#SAVNUM*2,@BATOBP(R4) ;REDUCE COUNT
	MOV	BATICT(R4),R0	;R0 -> INPUT CHAR. COUNT
	MOV	(R1)+,(R0)	;RESTORE INPUT COUNT
	MOV	(R1)+,-(R0)	;AND INPUT POINTER
	MOV	INDATA(R4),R0	;R0 -> INPUT EMT BLOCK IN BA
	TST	(R0)+		;R0 -> INPUT BLOCK #
	SAVE	(R1)		;SAVE THE BLOCK NUMBER
	INC	(R1)		;BUMP THE BLOCK # IN BA
	MOV	(R1)+,(R0)+	;AND PLACE IN EMT BLOCK
	SAVE	R0		;POINTER TO INBUF POINTER
	ADD	#6,R0		;R0 -> INPUT SAVE STATUS AREA IN BA
	SAVE	R1		;SAVE PTR TO BATCH STACK
	JSR	PC,WRTSTK	;WRITE OUT THE STACK
	TST	4(SP)
	BPL	2$
	BIC	#ABORT,(R4)
	JMP	SWTR3
2$:	ADDRLO	WDBLK2+2,R0
	RESTOR	(R0)		;R0 -> BATCH STACK
; REOPEN THE INPUT FILE THAT WAS PREVIOUSLY SAVED WHEN A
; NEW BATCH STREAM WAS $CALLED.
	MOV	#6*400,-(R0)	;.REOPEN
	EMT	375
	BCS	REOPER		;REOPEN ERROR
	ADDRLO	STKBLK,R0
	MOV	@(SP)+,STKBLK+4(R4) ;GET POINTER TO BA INPUT BUFFER
	RESTOR	STKBLK+2(R4)	;THEN THE BLOCK #
	MOV	@#SYSPTR,R5
	BIT	#FBMON$,CONFIG(R5)
	BEQ	1$		;DON'T MESS WITH BIT 1 IN SJ MON
	BIS	#2,@CONTXT(R5)

; NOW READ IN THE BLOCK THAT WAS IN THE BA HANDLER'S BUFFER WHEN THE
; $CALL WAS MADE. SINCE POINTER AND CHARACTER COUNT WERE PRESERVED,
; BATCH STREAM SHOULD CONTINUE WHERE IT LEFT OFF AT $CALL.

1$:	MOV	#10*400,(R0)		;READW
	EMT	375
	BCS	REOPER
	BIT	#FBMON$,CONFIG(R5)
	BEQ	3$		;IF S/J, SKIP RESTORE
	BIC	#2,@CONTXT(R5)
3$:	JMP	SWTR2

REOPER:	SERROR	<RETURN FROM CALL ERROR>
BATFIN:	MOV	#SOURCE+DESTON,@BATSW1(R4)
	SERROR	</<15><12>/END BATCH>
	CLR	R0		;SETUP TO FLUSH LOG BUFFER
	MOV	#400,R1		;WITH 400 NULLS
	MOV	#SOURCE+DESTON+BSOURC+BDESTN,@BATSW1(R4)
1$:	.TTYOUT
	DEC	R1
	BNE	1$
	CLR	@BATSW1(R4)	;CLEAR BATSW1 TO MAKE BA IDLE
	.EXIT
BATSTK:	.RAD50 "SY BA    SYS"

; ARGUMENT LIST FOR READ/WRITE OF BATCH STACK BLOCK (#5 OF BA.SYS FILE)
	ENTRLO	STKBLK,10*400+16,BATBLK,.-.,400,0
	.SBTTL	/N COMPILER SWITCH
SWTN:	BCS	SWTR
	BIS	#ABORT,(R4)		;DON'T RUN AFTER COMPILE
JMSTR4:	JMP	START4


	.SBTTL	/M COMPILER SWITCH
; THW /M SWITCH IS USED ONLY BY THE BATCH COMPILER TO CREATE (MAKE)
; SOURCE FILES FOR ITS OWN USE.

SWTM:	BCS	SWTN
	JSR	PC,TSTSWT	;TEST FOR BA ACTIVE
	ADDRLO	DEFCHN,R2	;ADDRESS OF THE DEFAULT CHANNEL NUMBERS
	JSR	R5,ENTER	;ENTER SPECIFIED FILE
	SPC0
	.WORD	0
	.RAD50	/DK /
	BR	2$

;GET DATA UNTIL CTRL/Z ENCOUNTERED, THEN CLOSE FILE.
; DATA IS FED TO THIS CODE FROM THE CTL FILE VIA THE .TTYIN
; REQUEST. THE BA HANDLER THINKS THE TEXT FOLLOWING THE $CREATE
; COMMAND IS JUST PROGRAM DATA FOR SOME STRANGE PROGRAM CALLED BATCH.

1$:	CHROUT	R0
2$:	.TTYIN
	CMP	#CTRL.Z,R0		;^Z?
	BNE	1$
	JSR	PC,CLOSE0
	.EXIT
	.SBTTL	/B COMPILER SWITCH

; THE /B SWITCH ON A COMMAND TO THE BATCH COMPILER IS USED TO CONTINUE
; THE BATCH STREAM WHEN A NEW JOB IN A CARD STREAM IS ENCOUNTERED OR
; WHEN A $JOB OR $SEQ CARD IS ENCOUNTERED WITHOUT A PRECEDING $EOJ
; COMMAND. WHAT HAS HAPPENED IS THE BATCH COMPILER HAS CREATED A 
; TEMPORARY FILE THAT CONTAINS THE COMMAND:
;	.R BATCH
;	*/B
;
; FOLLOWED BY SOME BINARY DATA THAT IT WISHES TO PRESERVE THROUGH 
; ANOTHER CALL OF  THE BATCH COMPILER.THIS IS NECESSARY BECAUSE BATCH
; REALLY ISN'T REENTRANT. THE DATA THAT FOLLOWS IN THE CTT FILE IS FED
; TO THE COMPILER A BYTE AT A TIME THROUGH THE .TTYIN REQUEST  AND USED
; TO RESTORE INPUT AND OUTPUT BUFFER POINTERS AND THE NAME OF THE .BAT
; FILE BEING EXECUTED.
;
; AN EXAMPLE OF THIS HAPPENING IS WHEN THE COMPILER DISCOVERS A $JOB CARD
; THAT WASN'T PRECEDED BY AN $EOJ CARD. BATCH ASSUMES THIS IS THE 
; START OF A NEW JOB AND THE PREVIOUS JOB IS FLUSHED BY ZEROING THE OUTPUT
; BUFFER AND BLOCK #, EFFECTIVELY FLUSHING ANY OUTPUT DONE UP TO NOW.
; BATCH THEN CREATES A  CTT FILE WITH THE /B COMMAND TO ITSELF, AND
; SAVES THE OUTPUT FILE POINTERS AND ITS CURRENT PLACE IN THE INPUT
; .BAT FILE, WHICH IS POINTING AT THE $JOB COMMAND. IT THEN PASSES
; THIS CTT FILE TO THE BA HANDLER WHICH EXECUTES IT, RE-RUNNING BATCH.
; THE /B SWITCH CAUSES BATCH TO PICK UP THE INPUT AND OUTPUT FILE
; POINTERS, EFFECTIVELY STARTING BATCH UP AT THE POINT OF THE
; NEW $JOB COMMAND.

SWTB:	BCS	SWTM		;A VALUE IS ILLEGAL
	JSR	PC,TSTSWT	;TEST FOR BA ACTIVE
	BIS	#MAKEB,(R4)	;SET MAKEB SWITCH
	.TTYIN			;GET A CHARACTER
	MOVB	R0,BINARG(R4)	;REPLACE CHAN. # IN INPUT EMT BLK
	.TTYIN
	MOVB	R0,BATIBK(R4)	;THEN THE INPUT BLOCK #
	.TTYIN
	MOVB	R0,BATIBK+1(R4)
	ADDRLO	SPC0,R1	;POINT TO CTL FILE DESCR.
	MOV	#^D39*2,R2	;TRANSFER 39. BYTES
1$:	.TTYIN
	MOVB	R0,(R1)+
	DEC	R2
	BNE	1$
	JMP	ENTSPC		;THEN CONTINUE LIKE NOTHING HAPPENED
				;BUT REMEMBER MAKEB BIT IS SET!

.SBTTL	DEFCHN - DEFAULT CHANNEL NUMBERS
;IN THE EVENT THAT YOU WISH TO CHANGE THE CHANNEL ASSIGNMENTS
;FOR THE SPC'S, HERE IS A HANDY-DANDY LIST.
;( DEFCHN: .BYTE SPC0#,...,SPC8# )

	ENTRLO	DEFCHN
	.CSECT	UNPURE
	.BYTE 0,1,2,3,4,5,6,7,10
	.EVEN
	.CSECT	PROGRM
NOCH3:	SERROR	<INPUT FILE?>
	JMP	GETCOM
	.SBTTL	/D COMPILER SWITCH
; THE /D SWITCH IS USED BY $MOUNT AND $DISMOUNT TO PRINT THE PHYSICAL
; DEVICE NAME ASSOCIATED WITH A LOGICAL NAME ON THE CTY. IT DOES
; THIS BY FETCHING THE HANDLER, DOING A .LOOKUP, AND THEN A .DSTATUS
; AND .SAVESTATUS TO EXTRACT DEVICE NAME AND UNIT NUMBER.
; NOTE: DEVLST BELOW MUST BE ORDERED IDENTICALLY WITH THE DEVICE
; IDENTIFICATION CODES USED BY THE RT-11 MONITOR.

SWTD:	BCS	SWTM
	JSR	PC,TSTSWT	;TEST FOR BA ACTIVE
	SAVE	@BATSW1(R4)
	CLR	@BATSW1(R4)
	ADDRLO	SPC3,R3
	CLR	2(R3)		;MAKE SURE IT'S NULL NAME
	MOV	R3,R0
	SAVE	DEVSPC(R4)
	EMT	343			;FETCH HANDLER
	BCS	DSMTER
	ADDRLO	WDBLK2+2,R0
	MOV	R3,(R0)
	MOV	#1*400+0,-(R0)		;CHANNEL 0
	EMT	375			;LOOKUP
	BCS	DSMTER
	MOV	#WDBLK5,-(SP)
	ADD	R4,(SP)
	MOV	R3,R0
	EMT	16*20+2			;.DSTATUS
	BCS	DSMTER
	MOVB	WDBLK5(R4),R1
	ASL	R1
	ADDR	DEVLST,R2
	ADD	R2,R1
	.TTYOUT	(R1)+
	.TTYOUT	(R1)+

; TO GET UNIT # WITHOUT DOING A SAVESTAUS (ILLEGAL FOR MT AND CT)
; GO DIRECTLY TO CHANNEL 0, WHICH STARTS 4 BYTES BEYOND FRONT OF
; RMON AND EXTRACT THE HIGH BYTE OF THE FIFTH WORD.

	MOV	@#SYSPTR,R2	;R2 -> RMON
	MOVB	$CSW+11(R2),R0	;GET UNIT # FROM CH 0
	ADD	#60,R0
	.TTYOUT
DSMTDN:	MOV	R3,R0		;POINT TO DEVICE NAME AGAIN
	CLR	-(SP)		;SET UP TO DO A
	EMT	343		;.RELEAS
	RESTOR	@BATSW1(R4)
1$:	.TTYIN
	BR	1$

	.SBTTL	RT-11 DEVICE LIST
DEVLST:	.ASCII	/RKDT  LPTT    PRPPMTRFCTCR  DS  MMDPDX/
	.EVEN
DSMTER:	SERROR	<DISMOUNT ERROR>
	BR	DSMTDN
.ENABL	LSB
; ENTSPC TESTS FOR AN INPUT FILE WHICH MUST BE SPECIFIED. IT THEN
; OPENS OUTPUT FILES FOR THE CTL AND LOG OUTPUT.

ENTSPC:	ADDRLO	DEFCHN,R2		;ADDRESS OF THE DEF. CHAN NUM.
	TST	SPC3(R4)
	BEQ	NOCH3
	BIT	#XSWT,BATSW2(R4)
	BEQ	2$			;BRANCH IF NOT /X
	CMP	SPC3+6(R4),(PC)+	 ;DID CSI PUT IN BAT EXT?
	.RAD50	/BAT/
	BNE	1$			;NO, O.K.
	MOV	RADCTL,SPC3+6(R4)	 ;YES, MAKE IT CTL
	BR	1$
2$:	CMP	SPC3+6(R4),(PC)+
RADCTL:	.RAD50	/CTL/
	BEQ	1$
	JSR	R5,ENTER		;ENTER SPC0
	SPC0				;DEFAULT COMPILER NAME
	.RAD50	/CTL/
	.RAD50	/DK /
1$:	INC	R2			;NEXT CHANNEL

; IF LOG FILE SPECIFICATION DIDN'T INCLUDE A FILE SIZE, USE
; DEFAULT SIZE DEFLOG TO MAKE SURE FILE IS BIG ENOUGH.

	BIT	#SBIT,BATSW2(R4)	;SKIP LOG FILE IF /S SWITCH
	BNE	4$			;BRANCH IF /S SET
	BIT	#MAKEB,(R4)		;DITTO FOR /B
	BNE	4$
	TST	SPC1+10(R4)		;SIZE SPECIFIED?
	BNE	3$			;YES, USE THAT SIZE
	MOV	#DEFLOG,SPC1+10(R4)	;USE DEFAULT SIZE
3$:	JSR	R5,ENTER
	SPC1
	.RAD50	/LOG/
	.RAD50	/LOG/
4$:	MOV	#6,R5			;COUNTER
	ADDRLO	SPC3,R3
	CMPB	(R2)+,(R2)+
.DSABL	LSB

; LOOKUP TESTS THE 6 POSSIBLE INPUT CHANNELS FOR FILE SPECIFIERS
; AND OPENS AS MANY CHANNELS AS ARE SPECIFIED. AT LEAST CHANNEL 3
; MUST BE SPECIFIED. LOOKUP FETCHES A HANDLER FOR EACH INPUT FILE,
; WHERE REQUIRED.

LOOKUP:	TST	(R3)
	BEQ	LUKUPN			;NO FILE
	MOV	R3,R0			;POINTER TO DEVBLK
	MOV	DEVSPC(R4),-(SP)	;HANDLER SPACE
	EMT	343			;FETCH HANDLER
	BCC	LUKUPF			;LOOKUP THE INPUT CHANNELS
	SERROR	<ILLEGAL DEVICE>
	BR	LUKXIT

	ENTRLO	DEVSPC,BATEND

 ; LUKUPF DOES LOOKUPS ON ALL CHANNELS
LUKUPF:	MOV	R0,DEVSPC(R4)		;UPDATE THE HANDLER SPACE POINTER
	ADDRLO	WDBLK2+2,R0
	MOV	R3,(R0)
	MOV	#1*400,-(R0)		;LOOKUP
	MOVB	(R2),(R0)		;SET IN THE CHANNEL NUMBER
	EMT	375
	BCC	LUKUPN
	SERROR	<FILE NOT FOUND>
LUKXIT:	JSR	PC,CLOSE	;CLOSE INPUT FILES, IF OPEN
	.EXIT
LUKUPN:	INC	R2
	ADD	#10,R3
	DEC	R5
	BGT	LOOKUP

; AT THIS POINT MUST TEST FOR /S SWITCH AND CALL EOJSUB TO PUSH
; THE BATCH STACK BEFORE CONTINUING.
	BIT	#SBIT,BATSW2(R4)	 ;WAS /S SWITCH USED?
	BEQ	1$			;NO, SKIP THIS
	JSR	PC,EOJSUB		;YES, PUSH DOWN A LEVEL
2$:	JMP	STRT8A			;SKIP LOG SETUP ON /S
1$:	BIT	#MAKEB,(R4)		;COMING FROM /B?
	BNE	2$			;BR IF SO, SKIP LOG SETUP

;**** KEEP TOGETHER ****
	ENTRLO	WDBLK2,0,0,0	;EXTRA 0 FOR LOOKUPS
	ENTRLO	WDBLK5,0,0,0,0,0
;***********************

; IF LOG DEVICE IS FILE-STRUCTURED, A FIXED LENGTH FILE WAS ENTERED.
; TO MAKE THIS PERMANENT UNDER CURRENT RT-11 FILE PRACTICES, BATCH
; MUST INITIALIZE THE FILE BY WRITING ZEROES IN ALL BLOCKS. THIS
; CAN BE ELIMINATED IF RT-11 SUPPORTS CTRL/Z AS EOF.

	TST	LOGTYP(R4)
	BPL	STRT8B			;NON FILE STRUCTURED
	ADDRLO	WDBLK5+12,R2
	ADDRLO	BATOBF-LOWSEG,R1	;R1 -> OUTPUT BUFFER
	CLR	-(R2)			;WRITW
	MOV	#1000,-(R2)		;WC
	MOV	R1,-(R2)		;BUFFER
	MOV	#1000,R3		;SET TO CLEAR OUTPUT BUFFER
1$:	CLR	(R1)+
	DEC	R3
	BNE	1$
	CLR	-(R2)			;START AT BLOCK 0
	MOV	R2,R1			;COPY PTR TO BLOCK #
	MOV	#11*400,-(R2)		;WRITE CHANNEL
	MOVB	DEFCHN+1(R4),(R2)	;SET IN THE CHANNEL NUMBER
2$:	MOV	R2,R0			;COPY ARG. LIST POINTER
	EMT	375			;.WRITE WITH WAIT
	INC	@R1			;BUMP BLOCK #
	INC	@R1
	BCC	2$			;KEEP WRITING UNTIL EOF
	TSTB	@#ERRWRD		;ERROR OR EOF?
	BNE	LOGERR			;ERROR ON WRITE
	BR	START8			;EOF, WE'RE DONE
	ENTRLO	FTLPC,0			;SAVE AREA FOR PC OF FATAL ERROR
BATFTL:	MOV	R0,FTLPC(R4)
	SERROR	<BATCH FATAL ERROR>
	.EXIT
.SBTTL	ENTER OUTPUT FILES

; ENTER IS A SUBROUTINE CALLED TO ENTER  OUTPUT FILES
; FOR THE BATCH COMPILER. CALLING SEQUENCE AND ARG. LIST IS:
;	JSR	R5,ENTER
;	OFFSET TO FILE NAME
;	DEFAULT EXTENSION
;	DEFAULT DEVICE
;
; R0,R1 ARE DESTROYED.

.ENABL	LSB
ENTER:	MOV	(R5)+,R1		;GET OFFSET
	ADD	R4,R1			;R1 -> FILE NAME
	MOV	(R5)+,R3		;R3 = DEFAULT EXTENSION
	MOV	(R5)+,R0		;R0 = DEFAULT DEVICE
	TST	(R1)+			;BRANCH IF DEVICE WAS SPECIFIED
	BNE	1$
	MOV	R0,-2(R1)		;NO, SO USE DEFAULT DEVICE
1$:	TST	@R1			;WAS FILE NAME SPECIFIED?
	BEQ	2$			;BR IF NOT, USE INPUT FILE NAME
	CMP	(R1)+,(R1)+		;POINT TO EXTENSION
	BR	4$
2$:	ADDRLO	SPC3+2,R0		;R0 -> INPUT FILE NAME
	TST	(R0)			;BRANCH IF INPUT FILE EXISTS
	BNE	3$			;AND USE THAT AS OUTPUT NAME,
	ADDR	TMPSPC,R0		;ELSE USE THE TEMPORARY NAME.
3$:	MOV	(R0)+,(R1)+		;TRANSFER NAME
	MOV	(R0)+,(R1)+
4$:	TST	(R1)+			;WAS EXT SPECIFIED?
	BNE	5$			;YES, USE IT
	MOV	R3,-2(R1)		;NO, USE DEFAULT
5$:	ADDRLO	WDBLK5+6,R0
	CLR	(R0)			;LAST WD IS 0(CT,MT ONLY)
	MOV	(R1),-(R0)		;SIZE
	SUB	#10,R1			;FIX IT UP
	MOV	R1,-(R0)		;POINTER TO DEVBLK
	MOV	#2*400,-(R0)		;ENTER
	MOVB	(R2),(R0)		;SET IN THE CHANNEL NUMBER
	EMT	375			;.ENTER
	BCS	6$
	RTS	R5

6$:	TSTB	@#52
	BEQ	7$			;CHANNEL IN USE
	SERROR	<OUTPUT DEVICE FULL>
	.EXIT

7$:	SERROR	<CHANNEL BUSY>
.DSABL	LSB
	.EXIT
CRLF:	.WORD	0

TMPSPC:	.RAD50	/TEMP/
LOGERR:	SERROR	<LOG DEVICE ERROR>
	.EXIT

; THE LOG FILE MUST NOW BE CLOSED SO IT MAY BE LOOKED UP AND
; THEN .SAVESTATUSED FOR PASSING TO THE BA HANDLER.

STRT8B:	CLR	SPC1+10(R4)		;NON FILE STRUCTURED
START8:	MOV	#6*400,R0		;CLOSE
	BISB	DEFCHN+1(R4),R0		;PUT IN LOG CHANNEL #
	EMT	374			;DO THE CLOSE
	ADDRLO	SPC1,R1			;R1 -> LOG FILE DESCRIPTOR
	ADDRLO	WDBLK2+2,R3
	MOV	R3,R0			;COPY PTR TO EMT BLOCK
	MOV	R1,(R0)
	MOV	#1*400,-(R0)		;LOOKUP SPC1
	MOVB	DEFCHN+1(R4),(R0)	;PUT IN THE CHANNEL NUMBER
	EMT	375
	ADDRLO	WDBLK5,R1		;OF LOG FILE IN WDBLK5.
	MOV	R3,R0			;COPY POINTER AGAIN
	MOV	R1,(R0)
	MOV	#5*400,-(R0)
	MOVB	DEFCHN+1(R4),(R0)	;SET IN THE CHANNEL NUMBER FOR SPC1
	EMT	375			;SAVESTATUS FOR LOG
	BCS	LOGERR
	MOV	ODATA(R4),R0	;R0 -> OUTPUT SAVE STATUS AREA IN BA
	JSR	PC,BEGSUB		;XFR SAVESTATUS DATA
STRT8A:	CMP	SPC3+6(R4),(PC)+
	.RAD50	/CTL/
	BEQ	1$
	BIT	#XSWT,BATSW2(R4)	;IS X SWITCH ON?
	BNE	1$
	JMP	STCMPL			;NO, MUST COMPIL FIRST

; ONCE THE BATCH STREAM IS COMPILED, OR IF IT WAS PRE-COMPILED,
; CONTROL COMES HERE FOR FINAL PROCESSING BEFORE EXIT. IF THE ABORT
; BIT WAS SET DURING COMPILE, THE JOB IS NOT EXECUTED. ASSUMING ALL
; IS O.K., THE FOLLOWING CODE PASSES THE NECESSARY DATA TO THE
; BATCH HANDLER.

1$:	MOVB	DEFCHN+3(R4),-(SP)	;SPC3 IS A COMPILED INPUT
BEGIN:	ADDRLO	WDBLK2+2,R0
	ADDRLO	WDBLK5,R1
	MOV	R1,(R0)			;COPY POINTER
	MOV	#5*400,-(R0)
	MOVB	(SP)+,(R0)		;SET IN THE CHANNEL NUMBER
	EMT	375			;SAVE STATUS
	BCC	2$
	JMP	OUTERR

2$:	MOV	INDATA(R4),R0		;R0 -> INSAV-12 IN BA
	JSR	PC,BEGSUB		;MOVE INPUT CTL SAVESTATUS TO BA
	MOV	ODATA(R4),R0		;R0 -> LOG EMT BLOCK IN BA
	TST	(R0)+			;POINT TO OBLOK
	BIT	#SBIT+MAKEB,BATSW2(R4)	;IF THIS IS A $CALL (/S)
	BNE	SWTR3			;LEAVE LOG ALONE
	CLR	(R0)			;START AT BLOCK 0
	MOV	OUTBUF(R4),@BATOPT(R4)	;RESET BA OUT BUFFER PTR & CNT
	MOV	#OUBSIZ*2,@BATOCT(R4)
SWTR3:	MOV	INDATA(R4),R0
	TST	(R0)+			;POINT TO INBLOK
	CLR	(R0)			;START AT BLOCK 0
	CLR	@BATICT(R4)		;CLEAR INPUT CHAR. COUNT
	BIT	#EOJ,BATSW2(R4)
	BEQ	SWTR2
	JSR	PC,EOJSUB		;PUSH DOWN THE BATCH STACK
	RESTOR	SPC0+6(R4)
	BIC	#EOJ,BATSW2(R4)
	JMP	EOJEOJ

; INITIALIZE BA HANDLER SWITCH WORD TO INDICATE:
;	CHARACTERS ARE COMING IN THRU BA
;	CHARACTERS GOING OUT TO BA
;	TTY INPUT COMING FROM BA, NOT CTY
;	TTY OUTPUT GOING TO LOG, NOT CTY

SWTR2:	MOV	#SOURCE+DESTON+BSOURC+BDESTN,@BATSW1(R4)
	BIT	#ABORT,(R4)
	BNE	ABORTT
ABORTX:	.EXIT

ELROER:	MOV	PC,R0			;SAVE PC OF ERROR
	JMP	BATFTL			;TAKE FATAL EXIT
ABORTT:	BIT	#ABORT,BATSW2(R4)
	BEQ	1$
	TST	@BATSW1(R4)
	BEQ	ABORTX

; THIS CODE FLUSHES THE LOG BUFFER BEFORE JOB ABORT.
	CLR	R0
	MOV	#1000,R1
7$:	.TTYOUT
	DEC	R1
	BNE	7$
	JMP	SWTR1

; THE JOB BEING COMPILED HAD AN ERROR, SO IT IS BEING ABORTED.
; FOLLOWING CODE LOGS THE ABORT MESSAGE, THEN REOPENS THE CTL
; FILE AND SEARCHES IT FOR LOG COMMENT LINES (BEGINNING WITH \C)
; WHICH REPRESENT THE COMMANDS IN THE ORIGINAL .BAT FILE. THESE
; LINES ARE LOGGED OUT TO GIVE THE OPERATOR INFORMATION ON COMPILE
; ERRORS, SINCE THEY WILL INCLUDE COMPILER DIAGNOSTIC COMMENTS.

1$:	JSR	PC,CLOSE		;CLOSE ALL INPUT CHANNELS
	MOV	#ABORT,BATSW2(R4)
	ADDRLO	WDBLK2,R0
	MOV	#6*400+3,(R0)
	EMT	375
	BCS	ELROER			;ERROR LOG REOPEN ERROR(FATAL)
	ADDRLO	BINLCT,R0
	CLR	(R0)+
	CLR	(R0)+
	CLR	(R0)+
	CLR	(R0)+
	MOV	#10*400+3,(R0)+
	CLR	(R0)+
	ADDRLO	BATIBF-LOWSEG+INBSIZ+INBSIZ,(R0)
	CLR	(R4)
	SERROR	<ABORT JOB>
; NOW LOG OUT ALL \C COMMENTS IN THE CTL FILE
2$:	JSR	PC,GETCHR
	CMP	#'\,R3
	BNE	2$
3$:	JSR	PC,GETCHR
	CMP	#'C,R3
	BNE	2$
; FOUND A \C LINE, SO OUTPUT TO LOG UNTIL ANOTHER \ FOUND.
4$:	JSR	PC,GETCHR
5$:	CMP	#'\,R3
	BEQ	3$
	.TTYOUT	R3
6$:	CMP	#12,R3
	BNE	4$
	JSR	PC,GETCHR
	CMP	#15,R3
	BNE	5$
	JSR	PC,GETCHR
	BR	6$
BEGSUB:	ADD	#12,R0			;POINT TO OUTSAV
BLT10:	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	RTS	PC
	COMMAND	EOJ
	LABOUT	$ABORT,<<<$$$$$$>>>	;A GOTO OR IF TRANSFER CANNOT PASS THIS LABEL
	FOUT				;DUMP THE LAST BUFFER
	COMOUT	RBATCH
	DATOUT	SLASHR,</R>,CR
	COMOUT				;IN CASE OF A SUPRIOUS .EXIT
	FOUT	CRLF			;FINI
	JSR	PC,CLOSE0		;CLOSE CTL FILE
	BIS	#EOJ,BATSW2(R4)		;FLAG END OF JOB PROCESSED
	TSTB	(R4)			;IS MAKEB ON? I.E., /B SWITCH USED
	BPL	1$			;BR IF NOT
	BIS	#MAKEB,BATSW2(R4)	;YES, SET IN BATSW2
1$:	BIT	#BNOEOJ,BATSW2(R4)	;UNEXPECTED $JOB OR $SEQ?
	BNE	13$			;BR IF SO
12$:	JSR	PC,GETCHR
	BNE	11$
	BIC	#EOJ,BATSW2(R4)
	TSTB	BATSW2(R4)		;DID THIS COME FROM A MAKEB?
	BPL	EOJEOJ			;BRANCH IF NOT
	BIS	#EOJ,BATSW2(R4)		;YES, FLAG $EOJ IN BATSW2
	MOV	#CTRL.Z,R3		;EOF
11$:	TST	R3
	BEQ	12$
	CMP	#NL,R3
	BEQ	12$
	CMP	#FORM,R3
	BEQ	12$

; COME HERE IF BNOEOJ BIT SET, INDICATING A $JOB OR $SEQ FOUND 
; WITHOUT A PRECEDING $EOJ COMMAND. THE COMPILER ASSUMES THE MISSING
; $EOJ COMMAND IS AN ERROR OF THE PREVIOUS JOB AND THE NEW $JOB OR $SEQ
;  IS THE START OF A NEW JOB. IT FLUSHES THE PRECEDING JOB AND 
; STARTS FROM SCRATCH. TO DO THIS IT CREATES A FILE CALLED JOB.CTT USING
;  THE NAME OF THE CTL FILE UNDER CONSTRUCTION. IN THIS FILE IT SAVES
; THE INPUT FILE CHANNEL #, CURRENT INPUT BLOCK # AND CHARACTER 
; POINTER, THE CTL AND LOG FILE DESCRIPTORS.THE FILE IS THEN GIVEN TO
; BA HANDLER FOR EXECUTION.

13$:	ADDRLO	BOTLCT,R0	;R0 -> OUTPUT BUFFER DATA
	MOV	#OTBSIZ*2,R1	;INITIALIZE OUTPUT BUFFER
	MOV	R1,(R0)+
	MOV	#BFREE*400+BFREE,(R0)+
	MOV	#BATOBF-LOWSEG,(R0)
	ADD	R4,(R0)
	MOV	(R0)+,R2
	MOV	R1,(R0)+
	TST	(R0)+
	CLR	(R0)+
	MOV	R2,(R0)
	ADD	R1,(R0)
	ADDRLO	DEFCHN,R2	;R2 -> CTL CHAN. #
	SAVE	SPC0+6(R4)	;SAVE CTL EXTENSION
	MOV	DOTS,SPC0+6(R4)	;PUT IN CTT EXT TEMP.
	SAVE	R3
	JSR	R5,ENTER	;ENTER FILE.CTT
	SPC0
DOTS:	.RAD50	/CTT/
	.RAD50	/DK /
	COMOUT	RBATCH		;IN IT PUT .R BATCH
	DATOUT	SLASHB,<<</B>>>,CR ;/B
	ADDRLO	BINARG,R0	;R0 -> INPUT FILE EMT ARG LIST
	JSR	PC,BINOUT	;WRITE OUT INPUT FILE CHAN #
	ADDRLO	BATIBK,R0	;R0 -> INPUT BLOCK #
	JSR	PC,BINOUT	;WRITE IT OUT
	JSR	PC,BINOUT
	ADDRLO	SPC0,R0		;R0 -> CTL FILE DESC.
	MOV	2(SP),SPC0+6(R4)
	MOV	#^D39*2,R1	;RESTORE CTL EXT
25$:	JSR	PC,BINOUT	;WRITE OUT CTL AND LOG FD'S
	DEC	R1
	BNE	25$
	MOV	DOTS,SPC0+6(R4)	;RESTORE CTT EXT AGAIN
	RESTOR	R3
	BIT	#BNOEOJ,BATSW2(R4)
	BEQ	4$
	BIC	#BNOEOJ,BATSW2(R4)
	OUTLOW	LINIMM
	CLR	R3
4$:	TST	R3
	BEQ	5$
	CHROUT	R3
5$:	JSR	PC,GETCHR
	BNE	4$
	CHROUT	#CTRL.Z		;TERMINATE CTT FILE WITH EOF
	JSR	PC,CLOSE0
EOJEOJ:	MOVB	DEFCHN+0(R4),-(SP)
	ADDRLO	SPC0,R1
	ADDRLO	WDBLK2+2,R0
	MOV	R1,(R0)
	MOV	#1*400,-(R0)		;LOOKUP SPC0
	MOVB	(SP),(R0)
	EMT	375			;DO THE LOOKUP
	BCS	CTLERR			;NO CTL FILE; SENT TO NON-DIR. DEVICE?
	JSR	PC,CLOSE		;CLOSE ALL INPUT CHANNELS
	JMP	BEGIN			;AND WE'RE OFF AND RUNNING

CTLERR:	SERROR	<NO CONTROL FILE>
	.EXIT


; FLUSH OUTPUT BUFFER, WAIT FOR I/O TO FINISH, THEN CLOSE CTL FILE.

CLOSE0:	CLR	R3
2$:	BIT	#OTBSIZ*2-1,BOTCTR(R4)
	BEQ	1$
	CHROUT
	BR	2$
1$:	BIT	#BWAIT*400+BWAIT,OTSTAT(R4)
	BNE	1$			;WAIT FOR COMPLETION
	MOV	#6*400,R0		;SETUP .CLOSE
	BISB	DEFCHN+0(R4),R0		;OUTPUT CHANNEL NUMBER
	EMT	374			;.CLOSE
	RTS	PC

BINOUT:	MOVB	(R0)+,R3
	CMPB	#'\,R3
	BNE	1$
	CHROUT	R3
1$:	CHROUT	R3
	RTS	PC

; CLOSE ALL INPUT FILES ON CHANNELS 3-8

CLOSE:	MOV	#6*400+3,R1	;START AT CHAN 3
1$:	MOV	R1,R0		;COPY EMT ARG
	EMT	374		;CLOSE A CHANNEL
	INCB	R1		;BUMP CHAN # BYTE
	CMPB	R1,#9.		;DONE ALL 6?
	BLT	1$		;NO, CONTINUE
	RTS	PC
.SBTTL	START TO COMPILE
.ENABL LSB
COMPIL:	BIS	#FIRST,BATSW2(R4)	;FIRST CARD PROCESSED
STCMPL:	COMMAND	EOD			;END OF DATA
LINE:	MOV	STACK(R4),SP
	CLR	-(SP)
	BIT	#MAKE,(R4)
	BEQ	LINE1			;NO TEMP.SOURCE NEED BE CREATED
	BIC	#MAKE,(R4)
	ADDRLO	LINIMM,R0
	ADDRLO	LINIMS,R1
	MOV	#LINSZ/2,R2
100$:	MOV	(R1)+,(R0)+
	DEC	R2
	BNE	100$
	SUB	#LINSZ,R0
	HOUT
	CHROUT	#'0
	BR	LINE2B

NOTUNI:	TST	(SP)+
	TST	(SP)+
	ERROR	<COMMAND NOT UNIQUE>
LINE1:	JSR	PC,GETIMM		;GET A LINE OF CODE
LINE2B:	CMPB	#'$,(R0)		;SEE IF FIRST CHARACTER IS A DOLLAR
	BNE	NODOLR
	LOGOUT	CRLF
	LOGLOW	LINIMM			;OUTPUT THE LINE IMAGE
	BIT	#TIME,(R4)
	BEQ	NOTIME
	COMOUT	CTIME,<TIME>,CR		;PRINT TIME OF DAY
NOTIME:	JSR	PC,EDIT			;REMOVE COMMENTS AND COMPRESS SPACES AND TABS
	INC	R0			;MOVE PAST THE DOLLAR
	TSTB	(R0)
	BEQ	LINE1			;'$ !COMMENT LINE'
	ADDR	KEYWRD,R1		;ADDRESS OF KEY WORD TABLE IN R1
	ADDR	KEYTAB-4,R5		;DISPATCH ADDRESS IN R5
	CLR	-(SP)			;INCASE OF UNIQUE SWITCH
1$:	ADD	#4,R5			;POINT TO NEXT COMMAND POINTER
	JSR	R5,SCANX		;TRY TO MATCH
	BR	FOUND			;FOUND A MATCH
2$:	TSTB	(R1)			;END OF TABLE?
	BEQ	NFOUND			;YES
	INC	R1
	TSTB	(R1)			;SKIP OVER THE SWITCHES
	BGT	1$
	BR	2$
LINE2:	MOV	STACK(R4),SP
	CLR	-(SP)
	BR	LINE2B

FOUND:	BGE	NFOUND			;EXTRA CHARACTER AT END OF KEY
	TST	(SP)			;SHOULD BE 0
	BNE	NOTUNI			;NOT UNIQUE?
	MOV	R5,(SP)
	MOV	R3,-(SP)
	MOV	R1,-(SP)
	BIT	#UNIQUE,(R4)
	BNE	2$
NFOUND:	MOV	(SP)+,R1
	BEQ	UNKCOM
	MOV	(SP)+,R0		;UPDATE CURSOR
	MOV	(SP)+,R5
	MOV	(R5)+,TMPSWT(R4)	;PICK UP DEFAULT SWITCH SETTINGS
	BIS	#COMSWB,BATSW2(R4)
	JSR	PC,SWTCHK		;CHECK FOR VALID SWITCHES
	TST	(SP)+			;REMOVE ERROR FLAG
FNDJMP:	.IF EQ PIC
	JMP	@(R5)
	.IFF
	ADD	(R5),PC			;JUMP TO PROPER ADDRESS
	.ENDC

NODOLR:	BIT	#RT11,(R4)
	BEQ	4$			;DON'T DEFAULT TO RT11 MODE
	JMP	DEFRT1
4$:	TST	(SP)			;SEE IF PREVIOUS ERROR
	BNE	LINE1
	INC	(SP)			;FLAG ERROR
	ERROR	<'$' MISSING>
	BR	LINE1
	.DSABL LSB

UNKCOM:	ERROR	<UNKNOWN COMMAND>
	BR	LINE
	.SBTTL	SCAN SUBROUTINE
;SCAN COMPARES A STRING POINTED TO BY R0
;WITH A STRING POINTED TO BY R1. R0'S STRING IS TERMINATED BY
;A CHARACTER THAT IS NOT IN THE RANGE A-Z, OR 0-9.
;R1'S STRING IS ENDED WITH A BYTE < 0.
;CALL:	JSR	R5,SCANX		;(WITH R0 AND R1 SET UP)
;	(RETURN IF MATCH)
;	(RETURN IF NO MATCH)
;SCAN ALSO SETS CONDITION CODES; 0 IF TERMINATED IN 0-9
;+ IF TERMINATED IN A-Z; - IF ANYTHING ELSE
;SCAN LEAVES R0 ALONE, R3 POINTS TO CHARACTER AFTER MATCH IN R0
;SCAN USES REGISTERS (R0),R1,R2,R3,R5

SCANX:	MOV	R0,R3			;USE R3 AS TEMPORARY CURSOR FOR LINE
SCAN2:	TSTB	(R1)			;ARE WE AT THE END OF A MATCH?
	BGT	3$			;NO
2$:	JSR	PC,CHRCHK		;YES, GET TYPE OF CHARACTER AT END OF MATCH
	RTS	R5
3$:	JSR	PC,CHRCHK
	BGE	7$			;A-Z OR 0-9
	SUB	R0,R3			;SEE HOW MANY MATCHED
	BIT	#UNIQUE,(R4)
	BNE	4$		;IF UNIQUE SWITCH SET LET WHOEVER CHECK FOR UNIQUENESS
	CMP	#3,R3
	BEQ	4$			;3 MATCHED, OK
8$:	TST	(R5)+			;NOT THERE, NOT OK
4$:	ADD	R0,R3			;RESTORE R3
5$:	TSTB	(R1)+			;MOVE R1 TO END OF STRING
	BGT	5$
	DEC	R1
6$:	SEN				;SET "-" CONDITION
	RTS	R5

7$:	CMPB	(R1)+,(R3)+		;COMPARE THE TWO STRINGS
	BEQ	SCAN2			;STILL MATCHING
	DEC	R3
	BR	8$			;***** R3 GETS DESTROYED ON MISS MATCH
	.SBTTL	GETCHR SUBROUTINE
;GETCHR GETS A CHARACTER FROM THE BATCH INPUT DEVICE AND PUTS IT IN R3
;IF IT RUNS OUT OF CHARACTERS IT GOES TO BATEOF
;THIS USES R3

.ENABL	LSB
1$:	JSR	R5,BATIO
	.WORD	BINARG
	TST	BINCTR(R4)
	BEQ	2$
GETCHR:	TSTB	(R4)
	BMI	3$
	DEC	BINCTR(R4)
	BLT	1$			;BUFFER EMPTY
	MOVB	@ICHRPT(R4),R3		;PUT CHARACTER IN R3
	INC	ICHRPT(R4)		;BUMP POINTER
2$:	RTS	PC

3$:	SAVE	R0
	.TTYIN
	MOV	R0,R3
	RESTOR	R0
	CMP	#CTRL.Z,R3
	BNE	2$
	BIC	#MAKEB,(R4)
	BR	GETCHR
.DSABL	LSB
.SBTTL	BATIO, DOUBLE BUFFERED I/O
;PROGRAMMED WITH .READC AND .WRITEC RATHER THAN USING THE .WAIT CONSTRUCTION
;CALL:	JSR	R5,BATIO
;	.WORD	ARGPTR		(POINTER OFF OF R4 TO ARGUMENTS FOR READ OR WRITE)
;	(RETURN)
;
;THE ARGUMENT LIST MUST RESIDE IN THE IMPURE AREA AND THE "ARGPTR"
;MUST POINT TO THE FUNCTION WORD IN THE ARGUMENT BLOCK. THE LIST IS
;LAYED OUT AS FOLLOWS:
;	STATUS
;	CHARACTER POINTER
;	CHARACTER COUNTER
;	FUNCTION
;	BLOCK #
;	BUFFER POINTER
;	BUFFER SIZE
;	RESERVED FOR COMPLETION ADDRESS
;THERE IS A RESTRICTION THAT THE TWO INPUT AND THE TWO OUTPUT BUFFERS
;MUST BE ADJACENT. ALL REGISTERS ARE PRESERVED IF NO SYSTEM ERRORS.
BATIO:	SAVE	R0,R1,R2
	MOV	(R5)+,R0
	ADD	R4,R0			;POINTER TO FUNCTION WORD
BATIO2:	ADDR	COMPLE,R1		;COMPLETION ADDRESS IN R1
	MOV	4(R0),-4(R0)		;SET CHAR POINTER TO LAST BUFFER TRANSFERED
	MOV	#BWAIT+BFREE,R2		;STATUS BITS TO SET
	MOV	6(R0),-(SP)		;WORD COUNT ON STACK
	ASL	(SP)			;CHARACTER COUNT
	TST	-6(R0)			;WHICH BUFFER
	BPL	1$			;BUFFER 0
	TST	(R1)+			;BUFFER 1, BUMP COMPLETION ADDRESS
	SWAB	R2			;BUFFER 1 STATUS BITS
	NEG	(SP)			;MOVE FOREWARD ONE BUFFER
1$:	SUB	(SP)+,4(R0)		;MOVE BACKWARD ONE BUFFER
	BIS	R2,-6(R0)		;SET IN THE WAIT BIT (AND NOT FREE)
	MOV	R1,10(R0)		;SET IN THE COMPLETION ADDRESS
BATIO3:	BIT	#EOJ,BATSW2(R4)
	BEQ	1$
	CMPB	#11,1(R0)		;WRITE?
	BEQ	1$
	BIC	R2,-6(R0)
	CLR	R2
	BR	BATIO4
1$:	SAVE	R0
	EMT	375			;DO .READC OR .WRITEC
	MOV	R0,R2			;SAVE WORD COUNT
	RESTOR	R0
	BCS	RWERR			;ERROR IN TRANSFER?
BATIO4:	ADD	R2,R2			;CHARACTER COUNT THAT IS
	MOV	-10(R0),-2(R0)		;MOVE IN OLD CHARACTER COUNT
	MOV	R2,-10(R0)		;RESET CHARACTER COUNT
	ASR	R2			;BACK TO WORD COUNT
	SWAB	R2			;TO BLOCK COUNT
	ADD	R2,2(R0)		;UPDATE BLOCK COUNT
	ADD	#100000,-6(R0)		;SWITCH BUFFERS (C WAS CLEAR)
	MOV	#BFREE,R2
	SAVE	#BEOF
	BCS	1$			;C=1 BUFF 0,C=0 BUFF 1
	SWAB	(SP)
	SWAB	R2			;BUFFER 1
1$:	BIT	(SP)+,-6(R0)
	BEQ	3$
	BIS	#BEOF,BATSW2(R4)
	BIT	#EOJ,BATSW2(R4)
	BEQ	BATEOF
	BR	4$
3$:	BIT	#EOJ,BATSW2(R4)
	BNE	5$
	BIT	R2,-6(R0)		;IS BUFFER FREE (ONLY FIRST TIME ON INPUT)
	BEQ	BATIO2			;YES, GO FILL THE SECOND BUFFER
5$:	ASL	R2			;BFREE*2=BWAIT
2$:	BIT	R2,-6(R0)		;WAITING FOR I/O ?
	BNE	2$			;YES (OR BR TO NULL JOB OR SOMETHING BETTER)
4$:	RESTOR	R0,R1,R2
	RTS	R5
BATEOF:	BIT	#JOB,(R4)
	BNE	1$
	BIT	#ABORT,BATSW2(R4)
	BNE	JMPABO
	JMP	SWTR1
1$:	SERROR <EOF WITH NO EOJ>
	BR	JMPABO
RWERR:	DECB	@#ERRWRD
	BEQ	3$			;HARD ERROR
	BGT	1$			;FILE NOT OPEN. MAYBE EOF CONDITION
	BIT	#400,(R0)		;EOF, READ OR WRITE?
	BNE	WBEOF			;WRITE BEYOND END OF FILE
	INC	(R0)			;TRY NEXT CHANNEL NUMBER (INPUT)
	BIT	#17,(R0)		;DID WE PASS CHANNEL 17
	BEQ	4$			;YES, GIVE EOF
	CLR	2(R0)			;NEW CHANNEL, START AT BLOCK 0
	BR	BATIO3

1$:	BIT	#400,(R0)
	BNE	OFNO			;OUTPUT FILE NOT OPEN
4$:	MOV	#BEOF,R1
	TST	-6(R0)
	BGE	2$
	SWAB	R1
2$:	BIS	R1,-6(R0)
	BR	BATIO4

3$:	BIT	#400,(R0)
	BNE	OUTERR
INERR:	CERROR	<INPUT ERROR>
JMPABO:	JMP	ABORTT

COMPLE:	COM	R1			;BUFFER 0 COMPLETION
	SAVE	R2,R4			;BUFFER 1 COMPLETION
	MOV	#BWAIT*400,R2
	TST	R1			;0 OR 1 COMPLETION?
	BGE	1$
	SWAB	R2			;BUFFER 0
	COM	R1
1$:	ADDR	LOWSEG,R4
	ADD	#AREA0,R4		;POINT TO AREA0(AREA0)
	MOV	R1,-(SP)
	ASR	(SP)
	ASR	(SP)
	ASR	(SP)			;AREA DISPLACEMENT
	BIC	#177741,(SP)
	ADD	(SP)+,R4
	MOV	(R4),R4			;POINT TO IMPURE AREA
	BIT	#17,R1
	BEQ	2$			;OUTPUT (CHANNEL 0 MOD 20)
	BIC	R2,INSTAT(R4)
	BR	3$

2$:	BIC	R2,OTSTAT(R4)
3$:	ROR	R0			;WAS THERE AN ERROR TOO?
	BCS	RWERRC			;ERROR IN COMPLETION
	RESTOR	R2,R4
	RTS	PC
	ENTRLO	AREA0,1000	;ONLY ONE UNPURE AREA AT THE MOMENT

RWERRC:	TST	R1			;INPUT OR OUTPUT
	BNE	INERR
OUTERR:	CERROR	<OUTPUT ERROR>
	BR	JMPABO
WBEOF:	CERROR	<OUTPUT DEVICE FULL>
	BR	JMPABO
OFNO:	CERROR	<OUTPUT FILE NOT OPEN>
	BR	JMPABO

.CTRLZ:	MOV	#CTRL.Z,R3
	BR	PUTCHR

.LF:	MOV	#NL,R3
	BR	PUTCHR

.EQUAL:	MOV	#'=,R3
	BR	PUTCHR

.ASCI2:	MOV	#'2,R3
	BR	PUTCHR
.SPACE:	MOV	#SPC,R3
	BR	PUTCHR

.R2:	MOV	R2,R3
	BR	PUTCHR

.SPPOP:	MOV	2(SP),R3
	MOV	(SP)+,(SP)
	BR	PUTCHR

.COMMA:	MOV	#',,R3
	BR	PUTCHR

.ASCIA:	MOV	#'A,R3
	BR	PUTCHR


INCVAX:	KOUT	NULINE
	CHROUT
.ASCI0:	MOV	#'0,R3
PUTCHR:	MOVB	R3,@OCHRPT(R4)
	INC	OCHRPT(R4)
	DEC	BOTCTR(R4)
	BNE	PUTDON
	JSR	R5,BATIO
	.WORD	BOTARG
PUTDON:	RTS	PC

PUTSTR:	MOVB	(R2)+,R3
	BLE	PUTDON
	CHROUT
	BR	PUTSTR
MESOUX:	JSR	R2,OUTPUX
	CTYOUB
	.ASCII	"\@"

AOUX:	JSR	R2,OUTPUX
	.WORD	0
	.ASCII	"\A"

LOGOUX:	JSR	R2,OUTPUX
	LOGOUB
	.ASCII	"\C"

DATOUX:	JSR	R2,OUTPUX
	DATOUB
	.ASCII	"\D"

COMOUX:	JSR	R2,OUTPUX
	COMOUB
	.ASCII	"\E"

FOUX:	JSR	R2,OUTPUX
	.WORD	0
	.ASCII	"\F"

GOUX:	JSR	R2,OUTPUX
	.WORD	0
	.ASCII	"\G"

HOUX:	JSR	R2,OUTPUX
	.WORD	0
	.ASCII	"\H"

IOUX:	JSR	R2,OUTPUX
	.WORD	0
	.ASCII	"\I"

JOUX:	JSR	R2,OUTPUX
	.WORD	0
	.ASCII	"\J"

KOUX:	JSR	R2,OUTPUX
	.WORD	0
	.ASCII	"\K"

LABOUX:	JSR	R2,OUTPUX
	.WORD	0
	.ASCII	"\L"
	.SBTTL	OUTPUX,OUTPU5,OUTPUL,CROUTP,OUTSTR SUBROUTINES
OUTPUX:	SAVE	R3			;R2 ALREADY ON THE STACK
	BIT	(R2),(R4)		;JUST USED IT TO CALCULATE ADDRESS
	BNE	1$
	BIC	#CTYOUB+LOGOUB+DATOUB+COMOUB,(R4)
	BIS	(R2)+,(R4)
	CHROUT	(R2)+
	CHROUT	(R2)
1$:	JSR	PC,OUTPU5
	RESTOR	R2,R3
	RTS	R5

OUTPU5:	MOV	(R5)+,R2
	.IF NE PIC
	ADD	R5,R2
	.ENDC
OUTPUL:	JSR	PC,PUTSTR
	TSTB	R3
	BMI	OUTRTS		;NO C.R. ON 200
CROUTP:	CHROUT	#15
	CHROUT	#12
OUTRTS:	RTS	PC

OUTSTR:	JSR	PC,OUTPU5
	RTS	R5
	COMMAND	SEQUENCE
	SPACES
	BIT	#JOB,(R4)	;$JOB ALREADY PROCESSED?
	BNE	NOEOJ		;YES, BRANCH ON ERROR
	BIT	#SEQ!FIRST,BATSW2(R4) ;$SEQ OR OTHER ALREADY PROCESSED?
	BNE	NOEOJ		;YES, AN ERROR
	BIS	#SEQ,BATSW2(R4)	;NO, FLAG FOR LATER REFERENCE
	CLR	R5
1$:	INC	R5		;COUNT # OF DIGITS IN SEQ. #
	CHECK	(R0)+		;CHECK FOR NUMERIC CHARACTER
	BEQ	1$		;NUMBERS ARE OK
	TST	R2		;END OF SEQUENCE NUMBER?
	BNE	BADSEQ		;NO EOL,ERROR
	ADDRLO	OBJTMP+3,R3
	ADDRLO	LSTTMP+7,R2
	ADDRLO	SOUTMP+3,R1
	DEC	R0
	DEC	R5		;ACTUALLY ONE LESS
	CMP	#3,R5		;MORE THAN 3 DIGITS?
	BGE	5$		;NO, USE THE COUNT
	MOV	#3,R5		;YES, USE JUST 3.
5$:	MOVB	-(R0),-(R3)
	MOVB	(R0),-(R2)
	MOVB	(R0),-(R1)
	DEC	R5
	BNE	5$
	JMP	STCMPL			;DON'T SET FIRST CARD BIT

	ENTRLO	LSTTMP,"LS,"T:,"00,200*400+'0

BADSEQ:	ERROR	<BAD SEQUENCE ARGUMENT>
	COMMAND	JOB	SWITCH,TIME,RT11,BANNER,UNIQUE,LIST
	BIT	#BITLIS,COMSWT(R4)
	BEQ	2$
	BIS	#LSTDAT,BATSW2(R4)
	BR	3$
2$:	BIC	#LSTDAT,BATSW2(R4)
3$:	BIT	#JOB,(R4)
	BNE	NOEOJ
	BIS	#JOB,(R4)
	BIT	#FIRST,BATSW2(R4)	;FIRST CARD ALREADY PROCESSED?
	BNE	NOEOJ			;YES, AN ERROR
	BIT	#BANNER,(R4)
	BEQ	JMPCOM
	INTVAR	#'A,#1			;SET VARIABLE A TO 1
	LABOUT	DUMMY$,<<<!DUMMY>>>		;OUTPUT DUMMY LABEL
	LOGLOW	LINIMM			;OUTPUT TO LOG THE LINE IMAGE
	INCVAR	#'A
	IFOUT	#'A,#60,IF$JOB,<<<!DUMMY0!DUMMY0!DUMMY1>>>
	LABOUT	DUMMY$
JMPCOM:	JMP	COMPIL			;MORE TO COMPILE

; $JOB OR $SEQ CARD WAS ENCOUNTERED BEFORE AN $EOJ. THIS IS ASSUMED
; TO BE THE START OF A NEW JOB (I.E., PREVIOUS JOB OMITTED THE $EOJ
; ERRONEOUSLY). THE COMPILER FLUSHES INPUT UP TO THIS POINT
; AND STARTS A NEW JOB.

NOEOJ:	ERROR	<NO $EOJ>
	BIS	#BNOEOJ,BATSW2(R4)
	JMP	C$$EOJ
	COMMAND	RUN
	GETFD	RUN
	COMOUT	CRUN,<<<RUN >>>
	FINDFD	RUN
	BEQ	NOFILE
	OUTFD
	BNE	1$
	JSR	PC,BADPLU
	BR	JMPCOM
1$:	CR.LF			;INSERT A CR/LF
	BR	JMPCOM

NOFILE:	ERROR	<NO FILE>
BJMCOM:	BR	JMPCOM

BADPLU:	ERROR	<ILLEGAL '+'>
	RTS	PC
.ENABL	LSB
	COMMAND	DIRECTORY
	BIS	#200,COMSWT(R4)
	COMMAND	COPY	SWITCH,DELETE
	JSR	PC,SVRPIP
COPLUP:	TSTB	COMSWT(R4)
	BPL	COPFD
	GETFD	DIR	OUTPUT,INPUT,LIST
	EXCLUSIVE	DIR	OUTPUT,LIST
	FINDFD	DIR	OUTPUT,LIST
	BR	COPDIR
COPFD:	GETFD	COP	OUTPUT,INPUT
	FINDFD	COP	OUTPUT
COPDIR:	BNE	1$
	TSTB	COMSWT(R4)
	BPL	NOFILE
	JSR	PC,DIRDIR
	BR	COPLUP
1$:	BIC	#STARFD,BATSW2(R4)
	OUTFDC
	BIT	#STARFD,BATSW2(R4)
	BEQ	2$
	DATOUT	SLASHX,<<</X>>>
2$:	JSR	PC,COPPRI
	BR	COPLUP

	COMMAND	PRINT	SWITCH,DELETE
	JSR	PC,SVRPIP
3$:	GETFD	PRI	NULL,INPUT
	DATOUT	LSTIT,<<<LST:>>>
	DATOUT	STARX,<<<*.*/X>>>
	JSR	PC,COPPRI
	BR	3$

	COMMAND	DELETE
	JSR	PC,SVRPIP
4$:	GETFD	DEL	NULL
	JSR	PC,COPRDE
	BR	4$

.DSABL	LSB

SVRPIP:	BIS	#STAROK,BATSW2(R4)
	COMOUT	RPIP
RTSPC:	RTS	PC
.ENABL	LSB
COPPRI:	CHROUT	#'=
DIRDIR:	FINDFD	COP	NULL,INPUT
	BNE	1$
	TSTB	COMSWT(R4)	;$DIR?
	BPL	NOFILE		;NO, GENERATE AN ERROR
1$:	OUTFDC
	TSTB	COMSWT(R4)
	BPL	25$
	DATOUT	SLASHL,<<</L>>>
25$:	CR.LF
	FOUT
	DATOUT
	BIT	#BITDEL,COMSWT(R4)
	BEQ	COMCHK
COPRDE:	FINDFD	COP	NULL,INPUT
	CLR	R5
3$:	OUTFD
	BEQ	4$
	COM	R5
4$:	DATOUT	SLASHD
	TST	R5
	BEQ	3$
COMCHK:	BIT	#COMMA,(R4)
	BNE	RTSPC
	BIC	#STAROK,BATSW2(R4)
	JMP	COMPIL
.DSABL	LSB
NXTRT1:	CR.LF
	COMMAND	RT11
	JSR	PC,GETIMM
	CMPB	#'$,(R0)		;IS FIRST CHARACTER A DOLLAR?
	BNE	DEFRT1
	JMP	LINE2
DEFRT1:	CMPB	#'*,(R0)
	BNE	TRYDOT
	DATOUT	NULINE
DOTGOT:	INC	R0
DATGOT:	MOVB	(R0)+,R3
	BEQ	NXTRT11
	CMP	#'',R3
	BEQ	2$
3$:	CHROUT
	BR	DATGOT

2$:	MOVB	(R0)+,R3
	BEQ	RTERR
	CMP	#'',R3
	BEQ	3$			;DOUBLE "'"
	CMP	#'",R3
	BEQ	QOTMES
	DEC	R0
	SCAN	CTY,<CTY>
	BR	QCTY
	SCAN	TTY,<TTY>		;*** ADDED 9/29/78 D.SHEPPERD ATARI,INC
	BR	QTTY			;***
	SCAN	FF,<FF>
	BR	QFF
	SCAN	LF,<NL>
	BR	QLF
	CHECK	(R0)
	BLE	RTERR
	KOUT	NULINE
;	JSR	R5,QERRQ
;	BR	QERROR
	CHROUT	(R0)+
QERROR:	CHROUT	#'2
CLOSQT:	CMPB	#'',(R0)+
	BEQ	DATGOT
RTERR:	JSR	PC,BADIF
BC$RT1:	BR	C$$RT1

QTTY:	SAVE	R3			;*** ADDED 9/29/78 D.SHEPPERD ATARI,INC
	AOUT		;OUTPUT '\A'	;***
	RESTOR	R3			;***
	BR	SKIPQT	;SKIP OVER QUOTE;***

QCTY:	SAVE	R3
	JSR	PC,QMBEL	;OUTPUT A ?,BELL,\G
	RESTOR	R3
	BR	SKIPQT		;SKIP OVER TO THE QUOTE

QLF:	MOV	R3,R0		;CHROUT DESTROYS R3
	CHROUT	#NL
	BR	CLOSQT

QFF:	FOUT
	DATOUT
SKIPQT:	MOV	R3,R0		;SCAN LEFT R3 POINTING JUST RIGHT
	BR	CLOSQT		;MUST BE FOLLOWED BY A CLOSE '
QOTMES:	MESOUT
	BR	2$
1$:	CHROUT
2$:	MOVB	(R0)+,R3
	BEQ	RTERR
	CMP	#'",R3
	BNE	1$
	LOGOUT
	DATOUT
	BR	CLOSQT

TRYDOT:	CMPB	#'.,(R0)
	BNE	NOTDOT
	COMOUT	NULINE
	BR	DOTGOT

NOTDOT:	JSR	PC,ALPNUM
	BEQ	NOLABL
	CMP	#':,R2
BNRTER:	BNE	RTERR
	MOVB	#200,-(R0)
	LABLOW	LINIMM
	MOVB	#':,(R0)+
1$:	CMP	#6,R1
	BLE	NOLABL
	CHROUT	#SPC
	INC	R1
	BR	1$
NOLABL:	LOGLOW	LINIMM
	JSR	PC,EDIT
NOLAB:	TSTB	(R0)
	BEQ	BC$RT1
	CMPB	#40,(R0)+
	BEQ	1$
	DEC	R0
1$:	MOV	#'0,-(SP)
	SCAN	NOTTY,<NOTTY>
	BR	CNOTTY
	SCAN	TTYIO,<TTYIO>
	BR	CTTYIO
	SCAN	TTYIN,<TTYIN>
	BR	CTTYIN
	SCAN	TTYOUT,<TTYOUT>
	BR	CTTOUT
	TST	(SP)+
	SCAN	IF,<IF>
	BR	CIF
	SCAN	GOTO,<GOTO>
	BR	CGOTO
	SCAN	LET,<LET>
	BR	CLET
	CMPB	#'%,(R0)
	BNE	BNRTERR		;IMPLIED LET IS AN ERROR
BMPVAR:	INC	R0
	JSR	R5,LETINC
	.WORD	'0
	BR	NOLAB

CLET:	MOV	R3,R0
CLETIM:	JSR	R5,LETINC
	.WORD	'1
	SPACES
	CMPB	#'=,(R0)+
	BNE	BNRTERR
	JSR	PC,ARGOUT
	BR	NOLAB

CGOTO:	MOV	R3,R0
	JOUT
	JSR	PC,GETLAB
	BR	NOLAB

LETINC:	SPACES
	KOUT
;	JSR	R5,QERRQ
;	BR	1$
	CHECK	(R0)+
	BLE	BADVAR
	CHROUT	R2
1$:	CHROUT (R5)
R5POP:	TST	(R5)+
	RTS	R5
;QERRQ:	SCAN	IFERROR
;	BR	2$
;	BR	R5POP
;2$:	MOV	R3,R0
;	CHROUT	<#'@>
;	RTS	R5

BADVAR:	ERROR	<BAD VARIABLE>
	TST	(R5)+
	RTS	R5

CTTYIN:	INC	(SP)
CNOTTY:	INC	(SP)
CTTYIO:	INC	(SP)
CTTOUT:	MOV	R3,R0
	HOUT
	CHROUT	(SP)+
BRNOLA:	BR	NOLAB
CIF:	MOV	R3,R0
	JSR	PC,IF$
JC$RT1:	JMP	C$$RT1
.ENABL	LSB
IF$:	SPACES
	CMPB	(R0)+,#'(
	BNE	BADIF
	SPACES
;	SCAN	IFERROR,<ERROR>
;	BR	IF.AT
	CHECK	(R0)+
	BGT	1$		;A-Z
BADIF:	ERROR	<BAD CONSTRUCTION>
	RTS	PC
BADIF2:	TST	(SP)+
	BR	BADIF
;IF.AT:	MOV	#'@,R2
;	MOV	R3,R0
1$:	SAVE	R2
	IOUT
	CHROUT	(SP)+
	SPACES
	CMPB	#'-,(R0)+
	BNE	3$		;NO MINUS SIGN?
	JSR	PC,ARGOUT
	BR	4$

3$:	CLR	R3
	CHROUT	R3		;COMPAIR WITH 0
	DEC	R0
4$:	SPACES
	CMPB	#'),(R0)+
	BNE	BADIF
	JSR	PC,GETLAB
	BEQ	6$
	CMPB	#',,(R0)+
	BNE	BADIF
6$:	JSR	PC,GETLAB
	BEQ	7$
	CMPB	#',,(R0)+
	BNE	BADIF2
7$:	JSR	PC,GETLAB
	LABOUT SPACE6
	BR	BRNOLAB
.DSABL	LSB
.CSECT	ERRLST
SPACE6:	.ASCII	"      "<200>
.CSECT	PROGRM
ARGOUT:	SPACES
	CHECK	(R0)+
	BNE	5$
	CLR	-(SP)
2$:	SUB	#60,R2
	CMP	#10,R2
	BLE	BADIF2
	ASL	(SP)
	ASL	(SP)
	ASL	(SP)
	ADD	R2,(SP)
	CHECK	(R0)+
	BEQ	2$
3$:	DEC	R0
4$:	CHROUT	(SP)+
	RTS	PC

5$:	CMP	#'",R2
	BNE	BADIF
	MOVB	(R0)+,-(SP)
	BR	4$
	.DSABL	LSB

GETLAB:	SPACES
	MOV	#'0,-(SP)
	CMPB	#'-,(R0)
	BEQ	1$
	INC	(SP)
	CMPB	#'+,(R0)
	BNE	2$
1$:	INC	R0
2$:	MOV	#6,-(SP)
3$:	CHECK	(R0)+
	BLT	5$
	CHROUT	R2
	DEC	(SP)
	BGT	3$
4$:	CHECK	(R0)+
	BGE	4$
45$:	TST	(SP)+
	CHROUT	(SP)+
	MOVB	-(R0),R2
	RTS	PC

5$:	CHROUT	#40
	DEC	(SP)
	BGT	5$
	BR	45$

SPACE$:	CMPB	#40,(R0)
	BNE	1$
	INC	R0
1$:	RTS	PC
	COMMAND	MOUNT	SWITCH,WAIT,WRITE
	DEFAULT	SWITCH	WAIT
	COMOUT			;IN CASE OF UNEXPECTED .EXIT
	MESLOW	LINIMM
	GETFD	MOU	LOGICAL,PHYSICAL,VID
	EXCLUSIVE	MOU	NULL,PHYSICAL
	FINDFD	MOU	LOGICAL
	BEQ	MOUQUS
	COMOUT	ASSPAC,<<<ASS >>>
	FINDFD	MOU	NULL,PHYSICAL,VID
	JSR	R5,MOUSUB
	BR	NOPHDV
	JSR	PC,QUSBEL
	CHROUT	#40
	FINDFD	MOU	LOGICAL
	JSR	R5,MOUSUB
	BR	NOLODV
	CR.LF
	BR	JMCOMP

	COMMAND	DISMOUNT	SWITCH,WAIT
	DEFAULT SWITCH	WAIT
	COMOUT			;IN CASE OF UNEXPECTED .EXIT
	MESLOW	LINIMM
	GETFD	DIS	LOGICAL
	EXCLUSIVE	DIS	NULL,LOGICAL
	COMOUT	RBATCH
	FINDFD	DIS	NULL,LOGICAL
	SAVE	R2		;(SAVE FOR DE-ASSIGN)
	JSR	R5,MOUSUB
	BR	NOLODV
	CHROUT	R2
	DATOUT	SLASHD
	COMOUT	ASSPAC
	CHROUT	#':
	RESTOR	R2
	JSR	R5,MOUSUB
	BR	NOLODV		;THIS SHOULD NEVER HAPPEN (BUT IT IS BETTER THAN A HALT)
	CR.LF
	BR	MOUQUS

MOUSUB:	BEQ	3$
	MOV	R2,R0
1$:	CHECK	(R0)+
	BMI	2$
	CHROUT	R2
	BR	1$
2$:	CMP	#':,R2
	BNE	3$
	TST	(R5)+
3$:	RTS	R5

NOPHDV:	ERROR	<NO PHYSICAL DEVICE>
	BR	JMCOMP
NOLODV:	ERROR	<NO LOGICAL DEVICE>
	BR	JMCOMP
	COMMAND	MESSAGE	SWITCHES,WAIT
	MESOUT
	MOV	R0,R2
	JSR	PC,OUTPUL
MOUQUS:	JSR	PC,QUSBEL
JMCOMP:	JMP	COMPIL

QUSBEL:	BIT	#BITWAI,COMSWT(R4)
	BEQ	OTFDRT
QMBEL:	MESOUT
	CHROUT	#'?
	CHROUT	#7
	GOUT
OTFDRT:	RTS	PC

	COMMAND	CHAIN
	JSR	PC,CHNCAL
	CR.LF
	JSR	PC,COMCHK
	BR	C$$CHA

	COMMAND	CALL
	JSR	PC,CHNCAL
	DATOUT	SLASHS,</S>,CR
	JSR	PC,COMCHK
	BR	C$$CAL

CHNCAL:	FOUT
	COMOUT	RBATCH,<<<R BATCH>>>,CR
	GETFD	CHA	INPUT
	FINDFD	CHA	NULL,INPUT
OTFDC$:	OUTFD
	BNE	OTFDRT
	CHROUT	<<#',>>
	BR	OTFDC$
; THESE SWITCHES MAY APPEAR ONLY ON THE $JOB CARD, HENCE
; THEY APPLY TO THE ENTIRE JOB. SETCLR SETS OR CLEARS THE
; BIT AS SPECIFIED BY THE $JOB CARD.

	SWITCH	UNIQUE
	JSR	R5,SETCLR
	.WORD	BITUNI
	.WORD	UNIQUE

	SWITCH	TIME
	JSR	R5,SETCLR
	.WORD	BITTIM
	.WORD	TIME

	SWITCH	RT11
	JSR	R5,SETCLR
	.WORD	BITRT1
	.WORD	RT11

	SWITCH	BANNER
	JSR	R5,SETCLR
	.WORD	BITBAN
	.WORD	BANNER

SETCLR:	BIT	(R5)+,TMPSWT(R4)
	BEQ	1$
	BIS	(R5),(R4)
	BR	2$
1$:	BIC	(R5),(R4)
2$:	RESTOR	R5
	BR	NXTSWT
.SBTTL	CHRCHK SUBROUTINE
; TESTS A CHARACTER POINTED TO BY R3
;TO SEE IF IT IS IN THE RANGE A-Z,0-9, OR OTHER
;RETURNS CONDITIONS + IF A-Z, 0 IF 0-9, - IF OTHER
;CHRCK COMPARE CHARACTER IN R2 FOR THE ABOVE
;CALL:	JSR	PC,CHRCHK (OR CHRCK)
;	(RETURN WITH CONDITIONS SET)
;USES R2

CHRCHK:	MOVB	(R3),R2
CHRCK:	CMPB	#'Z,R2
	BLT	1$			;NOT A-Z OR 0-9 RETURN LT
	CMPB	R2,#'@-1	;(*** MODIFIED TO ACCOMODATE 'MONCOM' D.SHEPPERD ATARI,INC 9/29/78
	BGT	1$			;A-Z RETURN GT
	CMPB	#'9,R2
	BLT	1$			;NOT A-Z,0-9 LT
	CMPB	R2,#'0
	BLT	1$			;DITTO
	SEZ				;0-9 RETURN 0
1$:	RTS	PC

	.ENABL LSB
	SWITCH	VID
	CMPB	#'=,(R0)+
	BNE	2$
	CMPB	#'",(R0)+
	BNE	3$
1$:	MOVB	(R0)+,R2
	BEQ	2$
	CMP	#'",R2
	BNE	1$
	BR	NXTSWT

3$:	JSR	PC,ALPNUM
	BNE	4$
2$:	ERROR	<BAD VID>
4$:	DEC	R0
	BR	NXTSWT
	.DSABL LSB

	SWITCH	LIST
	BIT	#NO,(R4)
	BEQ	NXTSWT
	BIS	#LSTBIT,BATSW2(R4)
	BR	NXTSWT
.SBTTL	SWTCHK SUBROUTINE
; RETURNS A BIT MAP OF SWITCHES IN TMPSWT
.ENABL LSB
;ENTER WITH R0 POINTING AT POSSIBLE SWITCH, AND R1 POINTING TO ACCEPTABEL SWITCHES
;CALL:	JSR	PC,SWTCHK

SWTCHK:	SAVE	R3,R5,R1		;R1 POINTS TO LIST OF SWITCH NUMBERS
	BIC	#NO,(R4)	;SOME SWITCHES CAN'T TAKE ON A NO VALUE
	SWITCH	BASIC
	SWITCH	CREATE
	SWITCH	FORTRAN
	SWITCH	INPUT
	SWITCH	LIBRARY
	SWITCH	LOGICAL
	SWITCH	MACRO
	SWITCH	NULL
	SWITCH	PHYSICAL
	SWITCH	SOURCE
	BIT	#NO,(R4)
	BNE	BADSW1		;THESE SWITCHES CANNOT HAVE 'NO' VALUES
	SWITCH	DATA
	SWITCH	DELETE
	SWITCH	DOLLAR
	SWITCH	EXECUTE
	SWITCH	MAP
	SWITCH	OBJECT
	SWITCH	OUTPUT
	SWITCH	RUN
	SWITCH	WAIT
	SWITCH	WRITE
NXTSWT:	CMPB	#'/,(R0)
	BNE	NOSWT			;NONE OR NO MORE SWITCHES
NXTSW2:	INC	R0			;POINT TO FIRST CHARACTER OF SWITCH
	MOV	R0,R3			;R3 AS TEMPORARY CURSOR
	BIC	#NO,(R4)
	CMPB	#'N,(R3)+
	BNE	6$
	CMPB	#'O,(R3)+
	BNE	6$			;NO "NO"SWITCH
	BIT	#COMSWB,BATSW2(R4)
	BEQ	BADSW1			;'NO' ONLY IN COMMAND FIELDS
	MOV	R3,R0
	BIS	#NO,(R4)		;SET THE "NO"SWITCH
6$:	ADDR	SWIT,R1
	CLR	R5			;COUNTER OF VALID SWITCH NUMBER
	CLR	-(SP)			;UNIQUENESS FLAG
1$:	DEC	R5			;SWITCH NUMBERS ARE NEGATIVE
2$:	MOVB	(R1)+,R2		;FIRST CHARACTER OF SWITCH IS MINUS
	BGT	2$			;NOT FIRST CHARACTER
	BEQ	UNKSWT			;UNKNOWN SWITCH OR END OF TABLE
	NEG	R2
	MOV	R0,R3
	CMPB	(R3)+,R2
	BNE	1$
	JSR	R5,SCAN2		;LET SCAN DO THE REST
	BR	3$			;MADE SOME KIND OF MATCH
	BR	1$			;NO MATCH
3$:	BGE	BADSWT			;EXTRA CHARACTERS AT END OF MATCH
	TST	(SP)			;UNIQUE?
	BNE	NOUNIQ
	MOV	R5,(SP)
	SAVE	R3
	BR	1$

NOUNIQ:	MOV	(SP)+,R0
	TST	(SP)+			;PRUNE STACK
	ERROR	<SWITCH NOT UNIQUE>
	BR	NXTSWT

4$:	CLC
	ROR	R3			;NEXT
5$:	MOVB	(R1)+,R2		;ANOTHER VALID SWITCH?
	BGE	BADSW1			;NO, BAD SWITCH
	CMP	R2,R5
	BNE	4$			;NOT THIS ONE
	BIT	#NO,(R4)
	BEQ	10$
	BIC	R3,TMPSWT(R4)
	BR	11$
10$:	BIS	R3,TMPSWT(R4)		;FOUND IT, SET IN THE CORESPONDING BIT
11$:	ADDR	SWTADD,R3		;ADDRESS OF SWITCH JUMP TABLE
	COM	R5
	ASL	R5
	ADD	R3,R5			;POINT TO SWITCH JUMP DISPLACEMENT TABLE
	.IF NE PIC
	MOV	(R5),R5		;WHEN GLOBAL ARITHMETIC COMES IN DO A ADD	(R5),R5
SWTJMP:	ADD	PC,R5		;JUMP ADDRESS IN R5
	JMP	@R5
	.IFF
	JMP	@(R5)
	.ENDC
;*********************************
UNKSWT:	MOV	(SP)+,R3
	BEQ	BADSW1
8$:	MOV	R3,R0			;UPDATE THE CURSOR
	MOV	(SP)+,R5
	MOV	#100000,R3		;SET UP SWITCH BIT
	MOV	(SP),R1			;ACCEPTABLE SWITCH TABLE
	BR	5$
BADSWT:	TST	(SP)+
BADSW1:	ERROR	<ILLEGAL SWITCH>
BADSW2:	CMPB	#'/,(R0)
	BEQ	NXTSW2
	TSTB	(R0)
	BEQ	NOSWT2			;EOL
	CMPB	#40,(R0)
	BEQ	NOSWT2
	INC	R0		;POINT TO NEXT SWITCH
	BR	BADSW2

NOSWT:	TST	TMPSWT(R4)
	BNE	9$
	MOV	#100000,TMPSWT(R4)
9$:	MOVB	(R0),R3
	ISIT	SPCCR,NOSWT2,<" ,+">
	ERROR	<SEPARATOR MISSING>
NOSWT2:	BIT	#COMSWB,BATSW2(R4)
	BEQ	7$
	MOV	TMPSWT(R4),COMSWT(R4)
7$:	RESTOR	R3,R5,R1
	RTS	PC
.DSABL LSB
ERRLOG:	SAVE	R0,R3
	BIS	#ABORT,(R4)		;SET ABORT SWITCH
	LOGOUT	CRLF
	LOGLOW	LINIMM
	ADDRLO	LINIMM,R2
	SUB	R2,R0			;CHARACTER NUMBER AT ERROR
1$:	DEC	R0
	BMI	2$
	CHROUT	#40
	BR	1$

2$:	CHROUT	#'^
	CR.LF
	JSR	PC,OUTPU5		;OUT PUT THE MESSAGE
	RESTOR	R0,R3
	RTS	R5

.SBTTL	ISIT SUBROUTINE
; TEST FOR ONE OF A LIST
ISIT$:	SAVE	R1
	MOV	(R5)+,R1
	.IF NE PIC
	ADD	R5,R1		;POINTER TO LIST
	.ENDC
1$:	CMPB	(R1),R3		;R3 IS CHARACTER IN QUESTION
	BEQ	3$		;FOUND A MATCH
	TSTB	(R1)+		;CHECK FOR EOL
	BNE	1$
	TST	(R5)+		;BUMP OVER FOUND ADDRESS
2$:	RESTOR	R1
	RTS	R5

3$:	.IF EQ PIC
	MOV	(R5),R5
	.IFF
	ADD	(R5),R5		;SET TO FOUND TRANSFER ADDRESS
	.ENDC
	BR	2$
.ENABL	LSB
	COMMAND	DATA	SWITCH,DOLLAR,LIST
	JSR	PC,TSTDOL	;TEST FOR /DOLLAR
	SAVE	BATSW2(R4)	;SAVE SWITCH WORD
	JSR	PC,TSTLST	;WAS /LIST REQUESTED?
	JSR	PC,DATMAK
	BR	1$
	COMMAND	CREATE	SWITCH,DOLLAR,LIST
	GETFD	CRE	OUTPUT
	EXCLUSIVE	CRE	NULL,OUTPUT
	COMOUT	RBATCH
	FINDFD	CRE	NULL,OUTPUT
	BEQ	CREERR
	JSR	PC,TSTDOL	;TEST FOR /DOLLAR
	SAVE	BATSW2(R4)	;PRESERVE SWITCH VALUE
	JSR	PC,TSTLST	;WAS /LIST REQUESTED?
	JSR	PC,SOUMAK
	COMOUT
1$:	RESTOR	BATSW2(R4)	;RESTORE PREVIOUS SWITCH VALUE
	CLR	-(SP)		;COUNTER (CHECK COMPIL:)
	JMP	LINE2B
.DSABL	LSB

ERRCRE:	JSR	PC,MAKBA2		;SWITCH LINIMS WITH LINIMM
CREERR:	JMP	NOFILE

.ENABL	LSB
SOUMAK:	OUTFD
	DATOUT	BATCRE,<<</M=>>>,CR
DATMAK:	MOV	PC,-(SP)	;NON ZERO SWITCH ON STACK
	BIT	#LSTDAT,BATSW2(R4)
	BEQ	1$
5$:	HOUT
	CHROUT	#'1		;TTYIO
1$:	JSR	PC,GETIMM
	CMPB	#'$,(R0)
	BEQ	2$
10$:	DATLOW	LINIMM
	CLR	(SP)		;CLEAR OUTPUT FLAG
	BR	1$

2$:	BIT	#DATDOL,(R4)
	BEQ	4$
	INC	R0
	SCAN	CN$EOD
	BR	3$
	SCAN	CN$EOJ
	BR	3$
	SCAN	CN$JOB
	BR	3$
	SCAN	CN$SEQ
	BR	3$
	BR	10$
3$:	ADDRLO	LINIMM,R0
4$:	CHROUT	#CTRL.Z
	BIT	#LSTDAT,BATSW2(R4)
	BEQ	7$
	HOUT
	CHROUT	#'0
7$:	BIC	#DATDOL,(R4)
	TST	(SP)+
	BNE	ERRCRE		;NO DATA FOLLOWED??
	RTS	PC
	.DSABL	LSB
MAKSOU:	JSR	PC,MAKMAK
	COMOUT	RBATCH
	LSTSOU
	JSR	PC,SOUMAK
MAKBA2:	ADDRLO	LINIMS,R1
	MOV	#LINSZ/2,R2
2$:	MOV	(R0),R3
	MOV	(R1),(R0)+
	MOV	R3,(R1)+
	DEC	R2
	BNE	2$
	RTS	PC

MAKMAK:	BIS	#MAKE,(R4)
	ADDRLO	LINIMM,R0
	ADDRLO	LINIMS,R1
	MOV	#LINSZ/2,R2
1$:	MOV	(R0)+,(R1)+
	DEC	R2
	BNE	1$
	RTS	PC

MAKBAS:	JSR	PC,MAKMAK
	JSR	PC,DATMAK
	BR	MAKBA2

TSTDOL:	BIT	#BITDOL,COMSWT(R4) ;A /DOLLAR SW. ON THIS CMD?
	BEQ	1$		;BRANCH IF NOT
	BIS	#DATDOL,(R4)	;YES, SET IN BATSWT
1$:	RTS	PC

TSTLST:	BIT	#BITLIS,COMSWT(R4) ;WAS /LIST SET ON COMMAND
	BEQ	1$
	BIS	#LSTDAT,BATSW2(R4);SET IN BATSW2
1$:	RTS	PC
;$LINK, $MACRO & $FORTRAN ARE SO SIMILAR THAT A COMMON ROUTINE IS USED.
;IT IS VERY IMPORTANT THAT THE ORDER OF THEIR SWITCHES BE IDENTICAL
;WITH EXCEPTION OF THE MACRO SWITCH

	COMMAND	MACRO	SWITCHES,RUN,MAP,OBJECT,LIBRARY,DATA,DOLLARS,LIST,CREF
	SAVE	COMSWT(R4)
	BIT	#BITLIB,(SP)
	BEQ	C$MACR
	BIS	#BFORLIB,(R4)
C$MACR:	BIS	#1,(SP)			;SET IN $MACRO FLAG
	GETFD	MAC	INPUT,EXECUTE,OBJECT,OUTPUT,MAP,LIBRARY,LIST,MACRO,SOURCE
	EXCLUSIVE	MAC	INPUT,MACRO,SOURCE
	EXCLUSIVE	MAC	OUTPUT,OBJECT
	BR	FORMAC

	COMMAND	LINK	SWITCHES,RUN,MAP,OBJECT,LIBRARY
	DEFAULT	SWITCH,OBJECT
	SAVE	COMSWT(R4)
	BIT	#BITLIB,(SP)
	BEQ	1$
	BIS	#BFORLIB,(R4)
1$:	BIS	#2,(SP)
C$LINK:	GETFD	LIN	INPUT,EXECUTE,OBJECT,OUTPUT,MAP,LIBRARY
	EXCLUSIVE	LIN	INPUT,OBJECT
	EXCLUSIVE	LIN	EXECUTE,OUTPUT
	BR	C$LNK

;NOTE SECOND OBJECT IS A DUMMY FILL FOR LIBRARY IN $LINK AND $MACRO
	COMMAND	FORTRAN	SWITCHES,RUN,MAP,OBJECT,LIBRARY,DATA,DOLLARS,LIST
	SAVE	COMSWT(R4)
C$FORT:	GETFD	FOR	INPUT,EXECUTE,OBJECT,OUTPUT,MAP,LIBRARY,LIST,FORTRAN,SOURCE
	EXCLUSIVE	FOR	INPUT,FORTRAN,SOURCE
	EXCLUSIVE	FOR	OUTPUT,OBJECT
FORMAC:	FINDFD	FOR	NULL,INPUT,SOURCE,FORTRAN
	BIT	#BITDOL,COMSWT(R4) ;A /DOLLAR SW. ON THIS CMD?
	BEQ	1$		;BRANCH IF NOT
	BIS	#DATDOL,(R4)	;YES, SET IN BATSWT
1$:	MOV	R2,COMSWT(R4)	;TEMPORARY POINTER TO INPUT FD
	BNE	4$
	JSR	PC,MAKSOU
4$:	BIT	#1,(SP)
.ENABL LSB
	BEQ	6$				;IF $FORTRAN
	COMOUT	RMACRO,<<<R MACRO>>>,CR
	BR	8$
6$:	COMOUT	RFORT,<<<R FORTRAN>>>,CR
8$:	FINDFD	FOR	OBJECT,OUTPUT
	BNE	12$
	BIT	#BITRUN+BITOBJ+BITMAP,(SP)
	BNE	10$
	FINDFD	FOR	EXE,MAP
	BEQ	16$				;NO OBJECT
10$:	GETOBJ					;GET A TEMPORARY OBJECT FILE
	OUTFD.
	BR	14$

12$:	OUTFD
	BEQ	BBDFOR				;'+' IN OBJECT LIST?
14$:	BIT	#1,(SP)
	BNE	16$				;IF $MACRO DON'T SET FORLIB REQUEST
	BIS	#BFORLIB,(R4)
16$:	FINDFD	FOR	LIST
	BNE	18$
	BIT	#BITLIS+BITCRE,(SP)		;IS LIST SWITCH ON?
	BEQ	20$
	GETLST
	BR	20$
18$:	JSR	PC,COUTFD
	BEQ	BBDFOR
20$:	DATOUT	EQUALS,<<<=>>>
.DSABL	LSB
.ENABL	LSB
	MOV	COMSWT(R4),R2	;FINDFD	FOR	FORTRAN,NULL,SOURCE,INPUT
	BNE	22$
	LSTSOU			;GET A SOURCE TEMPORARY
22$:	OUTFDC
	BIT	#BITCRE,(SP)
	BEQ	24$
	DATOUT	SLSHC,<<</C>>>
24$:	CR.LF
	BIT	#1,(SP)		;IF $MACRO
	BNE	25$		;FLUSH BUFFER OF MACRO MESG.
	BIT	#BITLIS+BITCRE,(SP) ;DO FOR $FOR ONLY IF LISTING
	BEQ	26$
25$:	FOUT			;FLUSH LOG BUFFER
	DATOUT			;KEEP FROM ABORTING
26$:	BIT	#MAKE,(R4)
	BEQ	28$
	COMOUT	RPIP
	LSTSOU
	OUTFD
	DATOUT	SLASHD
28$:	FINDFD	FOR	EXECUTE,MAP
	BNE	C$LNK
	BIT	#BITRUN+BITMAP,(SP)
	BNE	C$LNK
	JMP	FOREND

C$LNK:	COMOUT	RLINK,<<<R LINK>>>,CR
	FINDFD	FOR	EXECUTE
	BNE	32$
	BIT	#2,(SP)
	BEQ	30$
	FINDFD	LIN	OUTPUT,EXECUTE
	BNE	32$
30$:	BIT	#BITRUN,(SP)
	BEQ	33$
	GETSAV
	OUTFD.
	BR	33$

32$:	DATOUT
	OUTFD
	BEQ	BBDFOR
33$:	FINDFD	FOR	MAP
.DSABL	LSB
.ENABL	LSB
	BNE	34$
	BIT	#BITMAP,(SP)
	BEQ	36$
	GETLST
	BR	36$
34$:	JSR	PC,COUTFD
	BNE	36$
BBDFOR:	JMP	BADFLK
36$:	CHROUT	#'=
	BIT	#2,(SP)		;IS THIS A $LINK?
	BEQ	37$		;NO, THEN DON'T TEST /OBJ
	BIT	#BITOBJ,(SP)	;LINK IN TEMP OBJS?
	BEQ	40$		;NO,DON'T LINK THEM
37$:	JSR	PC,OBJCHK
	BEQ	40$
38$:	DMPOBJ	<'C+100000>
	TST	R3		;SEE IF CR.LF WAS LAST
	BEQ	40$		;YES
	BIT	#2,(SP)
	BEQ	39$		;BRANCH IF NOT $LINK
	FINDFD	LIN	NULL,INPUT,OBJECT
	BR	.39$
39$:	FINDFD	FOR	OBJ,OUT
.39$:	BEQ	40$
	CHROUT	<<#',>>
40$:	BIT	#2,(SP)
	BEQ	42$
	FINDFD	LIN	NULL,INPUT,OBJECT
	BEQ	46$
	OUTFDC			;OUPUT MULTIPLE FD'S
	BR	46$		;THEN PROCESS LIBRARIES.

42$:	FINDFD	FOR	OBJ,OUT
	BEQ	46$
44$:	OUTFD
46$:	FINDFD	FOR	LIBRARY
	JSR	PC,NOUTFD
	BIT	#BFORLIB,(R4)
	BEQ	56$
	ADDRLO	LIBLST,R2
	TSTB	(R2)
	BEQ	56$
	CLR	R5
	BR	52$

NOUTFD:	BEQ	48$
COUTFD:	CHROUT	<<#',>>
	OUTFD
48$:	RTS	PC
50$:	DATOUT	SLASHC,<<</C>>>,CR
	MOV	#5,R5
	BR	54$
52$:	CHROUT	<<#',>>
54$:	OUTFD
	BNE	56$
	DEC	R5
	BLE	50$
	BR	52$
56$:	CR.LF
	BIT	#2,(SP)		;SKIP TEST OF BITOBJ IF
	BEQ	57$		; THIS IS A $LINK
	BIT	#BITOBJ,(SP)	;TEST FOR /NOOBJ SWITCH
	BEQ	60$		;DON'T DELETE TEMP. OBJ'S IF SET
57$:	JSR	PC,OBJCHK
	BEQ	60$
	COMOUT	RPIP,<<<R PIP>>>,CR
	DMPOBJ	<'D>
	TST	R3			;SEE IF CR.LF WAS LAST
	BEQ	58$			;YES
	DATOUT	SLASHD,</D>,CR
58$:	MOV	#"0/,OBJTMP+4(R4)
	MOVB	#'0,OBJTMP+3(R4)
60$:	BIC	#BFORLIB,(R4)
	BIT	#BITRUN,(SP)
.DSABL	LSB
BEFREN:	BEQ	FOREND
.ENABL	LSB
	COMOUT	RSPACE,<<<R >>>
	FINDFD	FOR	EXE
	BNE	62$
	GETSAV
	OUTFD.
	BR	64$

62$:	OUTFD
BADFLK:	BEQ	BADFOR
64$:	CR.LF
	FINDFD	FOR	EXE
	BNE	FOREND
	COMOUT	RPIP
	GETSAV
	OUTFD
	DATOUT	SLASHD
	BR	FOREND
.DSABL	LSB
BADFOR:	JSR	PC,BADPLU
FOREND:	JSR	PC,COMCHK
	BIT	#1,(SP)
	BEQ	2$
	JMP	C$MACR
2$:	BIT	#2,(SP)
	BEQ	3$
	JMP	C$LINK
3$:	JMP	C$FORT

;*** YOU WILL NOTE THAT THE LIST SWITCH IS IN POSITION #2
;*** IT MUST BE IN THE SAME POSITION AS THE LIST SWITCH IN $DATA...

	COMMAND	BASIC	SWITCHES,RUN,LIST
MORBAS:	GETFD	BAS	BASIC,SOURCE,INPUT
	EXCLUSIVE	BAS	NULL,BASIC,SOURCE,INPUT
	COMOUT	RBASIC,<<<R BASIC>>>,CR
	CR.LF
	FINDFD	BAS	NULL,BASIC,SOURCE,INPUT
	BNE	GOTBAS
	DATOUT	SCRATCH,<<<SCRATCH>>>,CR
	SAVE	BATSW2(R4)
	JSR	PC,TSTLST	;WAS /LIST REQUESTED?
1$:	JSR	PC,MAKBAS
	RESTOR	BATSW2(R4)
	BR	RUNBAS

GOTBAS:	DATOUT	OLD,<<<OLD>>>,CR
	OUTFD
	BEQ	BASERR
	CR.LF
RUNBAS:	BIT	#BITRUN,COMSWT(R4)
	BEQ	NORUNB
	DATOUT	RUNCR,<<<RUN>>>,CR
NORUNB:	JSR	PC,COMCHK
	BR	MORBAS

BASERR:	JSR	PC,BADPLU
	BR	NORUNB
	.ENABL	LSB
	COMMAND	LIBRARY
	GETFD	LIB
	ADDRLO	LIBLST,R5
	CLRB	(R5)
	FINDFD	LIB	NULL
	BEQ	2$
1$:	MOVB	(R2)+,(R5)+
	BNE	1$
2$:	JSR	PC,COMCHK
	ERROR	<NO ',' IN $LIB!>
	JMP	COMPIL

FDFIND:	ADDRLO	FD0,R3
3$:	MOV	(R3)+,R2
	BEQ	4$
	BIT	(R3)+,(R5)
	BEQ	3$
4$:	TST	(R5)+
	TST	R2
	RTS	R5

;I COULD PUT IN A CHECK TO BE SURE THAT WE DON'T GO OVER NNN999.OBJ?
OBJSOU:	MOV	(R5),R2
	ADD	R4,R2			;POINT TO NAME TO BUMP
	ADD	#5,R2			;LAST CHAR
5$:	INCB	(R2)
	CMPB	#'9,(R2)
	BGE	6$
	MOVB	#'0,(R2)
	DEC	R2
	BR	5$

6$:	MOV	(R5)+,R2
	ADD	R4,R2			;LEAVE WITH R2 POINTING TO NAME
	RTS	R5

LSTLST:	CHROUT	<<#',>>
	SAVE	R0
	DATLOW	LSTTMP
	MOV	#';-1,R0		;EXTRA VARIABLES ARE ';','<','=','>','?'
7$:	INC	R0
	GETVAR	R0
	CMP	#'=,R0
	BNE	7$
8$:	INCVAR	R0
	IFOUT	R0,#'9,IF$LST,<<<!DUMMY1!DUMMY1!LSTNO1>>>
	LABOUT	IF$LST+16
	INTVAR	R0,#'0
	DEC	R0
	CMP	#';-1,R0
	BNE	8$
	LABOUT	DUMMY$
	DATOUT
	RESTOR	R0
	RTS	PC
	.DSABL	LSB
OBJDMP:	ADDRLO	OBJTMP+2,R2
	SAVE	(R2)+,(R2)
	MOV	#"0/,(R2)
	MOVB	#'0,-(R2)
	CLR	-(SP)
1$:	GETOBJ
	TST	(SP)
	BEQ	2$
	CHROUT	<<#',>>
2$:	INC	(SP)
	TST	(R5)
	BPL	5$
	OUTFD.
	BR	6$
5$:	OUTFD
6$:	CMP	#5,(SP)
	BGT	3$
	CHROUT	#'/
	CHROUT	(R5)
	CR.LF
	CLR	(SP)
3$:	ADDRLO	OBJTMP+2,R2
	CMP	(R2)+,4(SP)
	BNE	1$
	CMP	(R2),2(SP)
	BNE	1$
	MOV	(SP)+,R3			;IF 0 CR.LF WAS LAST
	RESTOR	-(R2),(R2)
	TST	(R5)+
	RTS	R5

OBJCHK:	ADDRLO	OBJTMP+3,R2
	MOVB	(R2)+,R1
	ADD	(R2),R1
	CMP	#"0/+'0,R1
	RTS	PC

GETFD$:	BIC	#COMMA,(R4)
	BIC	#COMSWB,BATSW2(R4)
	CLR	SWTMSK(R4)
	SAVE	#5		;HIGHEST FD NUMBER
	ADDRLO	FD0,R3
GETFD0:	TSTB	(R0)		;CHECK FOR NO ARGUMENTS
	BNE	GETFD4
GTFD15:	CLR	(R3)		;INDICATE NO FD
1$:	TST	(R5)+
	BNE	1$
	TST	(SP)+
	RTS	R5
GTFD13:	TST	(R3)+
	DEC	(SP)
	BMI	TMFD		;TOO MANY FILE DESCRIPTORS
GETFD4:	SPACES
	MOV	R0,(R3)+	;POINTER TO FD GOES IN (R3)
	CLR	(R3)		;CLEAR OUT SWITCHES
	JSR	PC,NAMEXT
GETFD5:	CMP	#':,R2		;CHECK FOR DEVICE
	BNE	GETFD7		;NOT A DEVICE
	JSR	PC,NAMEXT	;SPAN FILE NAME
GETFD7:	CMP	#'.,R2		;NAME ENDING WITH .?
	BNE	GETFD8
	TST	R1
	BNE	GETFD9
	ERROR	<NO FILE NAME BEFORE ".">
GETFD9:	JSR	PC,NAMEXT
GETFD8:	DEC	R0

; PROCESS THE FILE DESCRIPTOR FIELD FOR SWITCHES.

	MOV	(R5),R1
.IIF NE PIC,	ADD	R5,R1
	CLR	TMPSWT(R4)
	JSR	PC,SWTCHK	;CHECK FOR SWITCHES, RETURNED IN TMPSWT
	BIC	#BITNUL,SWTMSK(R4)
	BIS	TMPSWT(R4),(R3)	;AND SWITCH INTO FD SLOT,
	BIT	(R3),SWTMSK(R4)	;THEN SEE IF ALREADY DEFINED.
	BEQ	GETFD1		;BRANCH IF O.K.
	ERROR	<MULTIPLE SWITCH>
GETFD1:	BIS	(R3),SWTMSK(R4)	;AND INTO SWTMSK
	SAVE	R5
	TST	(R5)+

; TEST TO SEE IF TWO EXCLUSIVE SWITCHES, AS DEFINED BY THE EXCLUSIVE
; MACRO WHICH MUST FOLLOW THE MACRO (GETFD) WHICH INVOKES THIS CODE,
; HAVE BEEN SPECIFIED. THAT IS A SYNTAX ERROR.

1$:	MOV	(R5)+,R1
	BEQ	GETFD2
	MOV	SWTMSK(R4),R2
	BIC	R1,R2
	BEQ	1$
2$:	ASL	R2
	BCC	2$
	BEQ	1$
	ERROR	<ILLEGAL SWITCH COMBINATION>
	BIC	(R3),SWTMSK(R4)
GETFD2:	RESTOR	R5

; CHECK FOR MULTIPLE FILE DESCRIPTIONS, I.E., USE OF '+' TO
; SPECIFY MULTIPLE INPUT FILES. IF MORE IS TO COME, THE NULL
; SWITCH MUST BE CLEARED TO AVOID A MULTIPLE SWITCH ERROR.

GTFD11:	MOVB	(R0)+,R2	;END OF COMMAND?
	BEQ	GTFD14		;BRANCH IF SO.
	CMPB	#'+,R2		;CHECK TERMINATING CHAR
	BNE	GTFD12		;BRANCH IF NOT '+'
	BIC	#BITNUL,SWTMSK(R4) ;CLEAR NULL SWITCH
	JSR	PC,ALPNUM	;GET FD AFTER +
	BNE	GETFD5		;BRANCH IF ANOTHER FD EXISTS
	JSR	PC,BADPLU	;ELSE IT'S AN ERROR!
	BR	GTFD11
GTFD12:	CMP	#40,R2		;SPACE?
	BEQ	GTFD13
	CMP	#',,R2			;COMMA?
	BNE	GTFD16
	BIS	#COMMA,(R4)
GTFD14:	TST	(R3)+
	BR	GTFD15		;ALL FD'S IN ORDER

GTFD19:	TST	(SP)+
GTFD16:	ERROR	<ILLEGAL CHARACTER>
	BR	GETFD0

TMFD:	ERROR	<TOO MANY FILE DESCRIPTORS>
	BR	GTFD15

NAMEXT:	JSR	PC,ALPNUM	;SPAN DEVICE OR FILE NAME
	BNE	1$
	CMP	#'*,R2
	BNE	1$
	BIT	#STAROK,BATSW2(R4)
	BEQ	GTFD19
	CHECK	(R0)+
	BPL	GTFD19
	CMP	#':,R2
	BEQ	GTFD19
	INC	R1
1$:	RTS	PC

	ENTRLO	SWTMSK,0
	ENTRLO	FD0,0,0
	ENTRLO	FD1,0,0
	ENTRLO	FD2,0,0
	ENTRLO	FD3,0,0
	ENTRLO	FD4,0,0
	ENTRLO	FD5,0,0,0		;EXTRA WORD FOR END FLAG
.ENABL	LSB
OTFD.$:	MOV	#'.,-(SP)
	BR	1$

OUTFD$:	MOV	PC,-(SP)
1$:	DATOUT
	BR	2$

OUTFDC:	CHROUT
2$:	MOVB	(R2)+,R3
	ISIT	CMSPCR,OUTFDE,<", ">
	CMP	(SP),R3
	BEQ	5$
	CMP	#'*,R3
	BNE	3$
	BIS	#STARFD,BATSW2(R4)
3$:	CMP	#'+,R3
	BEQ	5$
	CMP	#'/,R3
	BNE	OUTFDC
4$:	ISIT	CMSPCR,OUTFDE
	MOVB	(R2)+,R3
	BR	4$

5$:	CLR	(SP)
OUTFDE:	TST	(SP)+
	RTS	PC
.DSABL	LSB
; GETIMM GETS AN IMMAGE LINE

GETIM0:	TSTB	LINIMM(R4)
	BNE	GETIM3
GETIMM:	ADDRLO	LINIMM,R0
GETIM1:	CLRB	(R0)
GETIM2:	JSR	PC,GETCHR
	ISIT	LFFF,GETIM2,<<12><14>>
	ISIT	CR,GETIM0,<<15>>
	MOVB	R3,(R0)+
	TSTB	(R0)		;SEE IF LINE TOO LONG
	BPL	GETIM1
	CLRB	-(R0)
	JSR	PC,GETIM3		;LOG THE LINE IMMAGE BUFFER
	ERROR	<LINE TOO LONG>
	BR	GETIMM

GETIM3:	ADDRLO	LINIMM,R0
	RTS	PC

ALPNUM:	CLR	R1		;CLEAR COUNTER
1$:	MOVB	(R0)+,R2
	INC	R1
	JSR	PC,CHRCK
	BGE	1$
	DEC	R1
	RTS	PC
EDIT:	SAVE	R1,R2,R0	;REMOVE COMMENTS
EDIT1:	CLR	R1
1$:	MOVB	(R0)+,R2
	BEQ	COMPRS
	CMP	#'",R2
	BNE	2$
	INC	R1		;BUMP QUOTE COUNTER
2$:	CMP	#'!,R2
	BNE	1$
	BIT	#1,R1
	BNE	1$
	CLRB	-(R0)
COMPRS:	MOV	(SP),R0		;COMPRESS SPACES AND TABS
	MOV	R0,R1
1$:	MOVB	(R1)+,R2
	BEQ	4$
	CMP	#40,R2
	BEQ	2$
	CMP	#11,R2
	BNE	3$
2$:	CMPB	#40,-1(R0)	;SPACE BEFORE
	BEQ	1$
	MOV	#40,R2
3$:	MOVB	R2,(R0)+
	BR	1$

4$:	CMPB	#'-,-(R0)
	BNE	5$
	CMPB	#'$,@LINIMP(R4)		;ONLY ON $ LINES
	BNE	5$
	SAVE	R0
	JSR	PC,GETIM1
	RESTOR	R0
	LOGOUT				;MUST BE IN LOGOUT MODE
	MOV	R0,R2
	JSR	PC,OUTPUL
	BR	EDIT1

5$:	CMPB	#40,(R0)	;TRAILING SPACE MUST GO
	BEQ	6$
	INC	R0
6$:	CLRB	(R0)
	RESTOR	R1,R2,R0
	RTS	PC

	.GLOBL	PATCH
PATCH:	.REPT	100.
	.WORD	0
	.ENDR
	.CSECT	SERRLS	;MUST BE END OF LAST .CSECT
	.EVEN
BATEND:
	.END	START
                                              