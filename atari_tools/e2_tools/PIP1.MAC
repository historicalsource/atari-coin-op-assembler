	.IF DF	MBUILD
	.TITLE	MBUILD	OVERLAY V02-03
	.IFF
	.TITLE	PIP1 OVERLAY V04-06
	.ENDC
; RT-11 PIP  (PERIPHERAL INTERCHANGE PROGRAM)
;      AND
; RT-11 MBUILD   (MAGTAPE BUILD PROGRAM
;
; DEC-11-ORPPA-E
;
; COPYRIGHT (C) 1973,1974,1975
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE,
; OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE MADE
; AVAILABLE TO ANY OTHER PERSON EXCEPT FOR USE ON SUCH SYSTEM AND TO
; ONE WHO AGREES TO THESE LICENSE TERMS. TITLE TO AND OWNERSHIP OF THE 
; SOFTWARE SHALL AT ALL TIMES REMAIN IN DIGITAL.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE
; OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DIGITAL.
;
;	MAY 2, 1973
;
;	HANK MAURER
;	LOUISE GERHART
;	ANTON CHERNOFF

;	JUNE 25, 1974
;
;	BOB FRIEDENTHAL
;
;	NOVEMBER 1974,JANUARY 1975,AUGUST 1975
;
;	BOB BEAN
;
;
	.SBTTL	MACRO DEFINITIONS

	.MCALL	..V1..
	.MCALL	.CLOSE,	.CSISPC,.DELETE,.DSTATU,.FETCH,	.HRESET
	.MCALL	.LOOKUP,.PRINT,	.RCTRLO,.RENAME,.REOPEN,.SAVEST
	.MCALL	.SETTOP,.SRESET,.TTYIN,	.TTYOUT,.UNLOCK,.LOCK
	.MCALL	.READW,	.WAIT,	.DATE,  .WRITW,	.EXIT,	.REGDEF
	.MCALL	.CSIGEN,.SERR  ,.TRPSET,...CM1,...CM2,...CM3

	..V1..	;USE V1 MACRO FORMAT
	.REGDEF	;DEFINE REGISTERS

.MACRO	MESSAGE	TEXT
	.CSECT	MSGS1
..CH	=.
	.ASCIZ	%TEXT%
	.CSECT
	.PRINT	#..CH
.ENDM	MESSAGE

.MACRO	ERROR	TEXT
	JSR	R0,MSG
	.ASCIZ	"?TEXT?"
	.EVEN
.ENDM	ERROR

.MACRO	SWITCH	CHAR,ADR,MODE,VALUE
	.BYTE	''CHAR,MODE
.IF B	VALUE
	.WORD	0
.IFF
VALUE:	.WORD	0
.ENDC
.IF EQ	MODE
	.WORD	ADR-COPY
.IFF
ADR:	.WORD	0
.ENDC
.ENDM	SWITCH

;THE FOLLOWING MONITOR FEATURES ARE USED IN NON-STANDARD CALLS
;	HENCE, THE USUAL MACROS ARE NOT USED

.MACRO	.ENTER	CH
	EMT	40+CH
.ENDM	.ENTER

.MACRO	.READ	CH
	EMT	200+CH
.ENDM	.READ

.MACRO	.WRITE	CH
	EMT	220+CH
.ENDM	.WRITE

;SYMBOL DEFINITIONS

NLIMIT	= 37			;MAX # OF DIRECTORY SEGMENTS ALLOWED
STRTAD	= 40			;USER PROGRAM START ADDRESS
JSW	= 44			;JOB STATUS WORD
EMTERR	= 52			;RT-11 ERROR RETURN WORD
SYSPTR	= 54			;POINTER TO RT-11 RESIDENT
DIRBLK	= 6			;STARTING BLOCK OF DIRECTORIES
OFFSET	= 256			;OFFSET TO VITAL RMON WORDS
				;OFFSET IS DIFF OF BLKEY AND $RMON
SYSUNT	= 275			;OFFSET TO SYSTEM DEVICE UNIT #
CONFIG	= 300			;OFFSET TO CONFIG WORD
R50STAR	= 132500		;* IN RADIZ 50 (FROM CSI)
DIREOB	= 4000			;DIRECTORY BIT SAYING END OF BLOCK
DIRPRM	= 2000			;BIT SAYING PERMANENT FILE
DIREMP	= 1000			;BIT SAYING EMPTY ENTRY
DIRESZ	= 16			;SIZE OF 1 ENTRY (+ XTRABY)
FGACTV	= 200			;BIT IN CONFIG SAYING FG ACTIVE
CSWEOF	= 20000			;EOF BIT IN CSW
HDR1	= 42110			;ASCII H,D
EOF1	= 47505			;ASCII E,O

RXCS	= 177170		;ADDRESS OF RX11 CONTROL/STATUS REGISTER
	.IF NDF	MBUSSC
RSCS2	= 172050		;ADDRESS OF RH11/RJS03/4 CONT REG 2
	.ENDC
	.IF DF	MBUSSC
RSCS2	= 176310		;ADDRESS OF RH11/RJS03/4 CR2
	.ENDC

				;DEVICE IDENTIFICATION CODES IN $STAT
RKIDEN=0			;RK11/RK05,RK03
DTIDEN=1			;TC11/TU56
TMIDEN=11			;TM11/TU10/TSO3
RFIDEN=12			;RF11/RS11
CTIDEN=13			;TA11/TU60
RJIDEN=16			;RJS03/4
TJIDEN=20			;TJU16
DPIDEN=21			;RP11/RP02,RP03
DXIDEN=22			;RX11/RX01

;ASCII CHARACTERS
RUBOUT=377			;RUBOUT
ASTRSK=52			;ASTERISK

	.GLOBL	ILLCMD,FGCHK,DEVINF,SSB,HANERR,REBOT,FILDES
	.SBTTL	REBOOT
;
;	THIS CODE REBOOTS THE SYSTEM FROM ANY OF THE DEVICES
;	SPECIFIED IN THE TABLE AT BOOTDV. THE COMMAND IS ANALYZED,THE
;	DEVICE IS LOOKED UP IN THE TABLE,AND IF FOUND,THE CORRESPONDING
;	ROUTINE IN THE TABLE AT BOOTAD IS ENTERED TO PEFORM THE BOOT
;
;BOOTDV-TABLE OF DEVICE CODES WHICH LISTS DEVICES FROM WHICH RT-11
;CAN BE BOOTED. THIS TABLE IS ORDERED TO CORRESPOND WITH THE
;TABLE BOOTAD,WHICH CONTAINS THE ADDRESSES OF THE CORRESPONDING
;BOOTSTRAP ROUTINE FOR EACH DEVICE.
BOOTDV:	.IF NDF	MBUILD
	.BYTE	DTIDEN		;TC11/TU56 DECTAPE
	.BYTE	DXIDEN		;RX11/RX01 FLOPPY DISK
	.ENDC
	.BYTE	RFIDEN		;RF11/RS11 FIXED HEAD DISK
	.BYTE	DPIDEN		;RP11/RP02,RP03 DISK CARTRIDGE
	.BYTE	RKIDEN		;RK11/RK05,RK03 DECPACK DISK
	.BYTE	RJIDEN		;RH11/RJSO3/4 FIXED HEAD DISK
BDVEND:	.EVEN			;END OF TABLE

;BOOTAD-TABLE OF ADDRESSES FOR BOOTSRAP ROUTINES FOR EACH OF THE
;DEVICES SPECIFIED IN BOOTDV. INDEX OF DEVICE IN BOOTDV IS
;USED AS INDEX INTO THIS JUMP TABLE.
BOOTAD:	.IF NDF	MBUILD
	DTBOOT			;TC11
	DXBOOT			;RX11
	.ENDC
	RFBOOT			;RF11
	DPBOOT			;RP11
	RKBOOT			;RK11
	RJBOOT			;RJSO3/4

;REBOOT ROUTINE
;ANALYZES /O COMMAND TO DETERMINE WHICH DEVICE WAS SPECIFED BY
;LOOKING FOR THE CODE OF THE SPECIFIED DEVICE IN BOOTDV. IF THE
;CODE IS FOUND,THE APPROPRIATE ROUTINE IS ENTERED

REBOT:	JSR	PC,FGCHK	;MAKE SURE FG IS NOT PRESENT
	MOV	#FILDES+36,R5	;POINT TO INPUT LIST
	TST	(R5)		;WAS A DEVICE SPECIFIED?
	BEQ	4$		;NO
	TST	(R4)		;ANY OUTPUT FILES SPECIFIED?
	BEQ	3$		;NO
4$:	JMP	ILLCMD		;BAD COMMAND
3$:	TST	2(R5)		;ANY INPUT FILES?
	BNE	4$		;YES-/O PROBABLY MISTAKE
	.DSTATU	#DEVINF,R5	;GET CODE FOR THE DEVICE
	.LOOKUP	1,R5		;NON-FILE STRUCTURED LOOKUP ON DEVICE,FOLLOWED
	.SAVEST 1,#SSB		;BY A SAVESTATUS WILL MAKE UNIT # AVAILABLE
	MOV	#BOOTDV,R0	;POINT TO LEGAL DEVICE CODE TABLE
1$:	CMPB	DEVINF,(R0)+	;LOOK FOR DECIE
	BEQ	DVFND		;FOUND THE DEVICE
	CMP	R0,#BDVEND	;END OF TABLE?
	BLO	1$		;NO-EXAMINE NEXT ENTRY
HANER1:	JMP	HANERR		;YES-DEVICE SPECIFIED MUST BE ILLEGAL

DVFND:	SUB	#BOOTDV+1,R0	;GET INDEX OF DEV IN BOOTDV
	ASL	R0		;ADDRESSES ARE EVEN
	JMP	@BOOTAD(R0)	;ENTER BOOT ROUTINE FOR DEVICE

;BM793-COMMON BOOTSTRAP ROUTINE FOR RP11,RK11,TC11,RF11
;ON ENTRY,R0 POINTS TO CONTROLLER WORD COUNT REGISTER
;R1 CONTAINS CONTROLLER COMMAND VALUE TO CAUSE A READ
;R2 CONTAINS APPROPRAITE UNIT VALUE TO PUT IN CONTROLLER
;R3 CONTAINS ADDRESS OF CONTOLLER REGISTER TO RECIEVE R2

BM793:	.HRESET			;NOW BEGINS THE BOOT
2$:	RESET
	MOV	R2,@R3		;PUT UNIT # IN REGISTER POINTED TO BY R3
	MOV	R0,R5		;WE CAN'T DESTROY R0
	MOV	#-256.,@R5	;SET WORD COUNT
	CMP	R5,#177344	;IS THIS DECTAPE?
	BNE	3$		;NO
	MOV	#4002,-(R5)	;YES-MUST SEARCH FOR BLOCK 0
	TST	@R5
	BPL	.-2
	TST	-(R5)
	BPL	2$
	CMP	(R5)+,(R5)+	;AT BLOCK 0-POINT R5 TO COMMAND REGISTER
3$:	MOV	R1,-(R5)	;STUFF COMMAND REGISTER WITH READ COMMAND
	TSTB	@R5		;WAIT TO FINISH
	BPL	.-2
	TST	@R5		;ERROR?
	BMI	2$		;YES-TRY AGAIN
	CLRB	@R5		;NO-STOP DEVICE
	JMP	@#0		;AND START SECONDARY BOOT CODE

	.IF NDF	MBUILD
;FLOPPY BOOT ROUTINE
PS:	RTI			;USED TO LOAD PS FROM STACK IN MACHINE
				;INDEPENDENT FASHION
DXBOOT:	.HRESET			;STOP ALL RT-11 I/O
	RESET			;STOP TERMINAL AND CLOCK
	DECB	SSB+11		;UNIT #-1 IN SAVED STATUS BLOCK
	BMI	UNIT0		;IF RESULT<0,UNIT WAS 0
	.IF	DF,$$DEC
	BNE	HANER1		;ANY UNIT BUT 0 OR 1 ILLEGAL
	MOV	#20,R2		;BOOT FROM UNIT 1
	BR	UNIT1
UNIT0:	CLR	R2
UNIT1:	BIS	#100247,R2	;R2=20 FOR UNIT 1 BOOT
	MOV	#340,-(SP)	;PUT DESIRED PRIORITY ON STACK
				;THS FOLLOWING INSTRUCTION IS MACHINE
				;INDEPENDENT WAY TO LOAD PS
	JSR	PC,PS		;LOAD PS FROM STACK WITH RTI INST
1$:	MOV	#RXCS,R1	;POINT R1 TO STATUS REGISTER FOR CONTROLLER
2$:	BITB	R2,@R1		;WAIT FOR FLOPPY DONE
	BEQ	2$
	MOVB	#7,R3		;SET SECTOR/TRACK/LOOP CONTROL
	MOV	R1,R0		;SET UP TO POINT TO RXDB
	MOV	R2,(R0)+	;LOAD READ AND GO FUNCTION
	BR	4$		;GO TO WAIT LOOP
3$:	MOV	#1,@R0		;1ST SECTOR 1, 2ND TRACK 1, 3RD JUNK
4$:	ASR	R3		;STEP THROUGH SECTOR/TRACK SEQ
	BCS	6$		;BRANCH TO WAIT,SIT CYCLE NOT DONE
	MOVB	(PC)+,@R1	;LOAD EMPTY BUFFER COMMAND
5$:	MOVB	@R0,(R3)+	;MOVE DATA BYTE TO MEMORY
6$:	BIT	R2,@R1		;WAIT FOR TR DONE OR ERROR
	BEQ	6$
	BMI	1$		;BRANCH TO RETRY IF ERROR
	BCS	3$		;BRANCH IF IN SECTOR/TRACK LOOP
	TSTB	@R1		;IS DATA TRANSFER DONE
	BMI	5$		;BRANCH TO TRANSFER MORE
	CLR	R0		;MAKE SURE LOC 0 IS 240
	CMP	#240,@R0
	BNE	1$		;BRANCH IF NOT TO RETRY
	CMPB	#247,R2		;SET C=1 IF UNIT 1 BOOT
	ADC	R0		;R0=0 IF UNIT0,1 IF UNIT 1
	CLR	PC		;GO TO SECONDARY BOOT
	.IFF
	BR	HANER1
UNIT0:	MOV	#512.,R4	;BYTE COUNT
	CLR	R1		;MEM POINTER
	MOV	#200,R0		;COMMAND
	MOV	#176002,R5	;SYKES CONTROL ADDRESS
	MOV	R0,(R5)		;RESET DRIVE
	INC	R0		;MAKE SELECT COMMAND
	MOV	R0,(R5)+	;SELECT DRIVE 0 (201)
	BIC	#200,R0		;MAKE TRACK/SECTOR READ COMMAND
	BIT	#2,(R5)		;DRIVE READY?
	BEQ	UNIT0		;NO
	MOV	R0,-(R5)	;TRACK SELECT (1)
	MOV	R0,(R5)		;SECTOR SELECT (1)
	TST	-(R5)		;ADJUST ADDRESS
2$:	TSTB	(R5)		;DO DATA XFER
	BPL	2$
	MOVB	6(R5),(R1)+
	DEC	R4
	BGT	2$
	TST	(R5)+
	MOV	#203,(R5)+	;TERMINATE I/O
	BIT	#110,(R5)	;ERRORS?
	BNE	UNIT0		;YEP
	CLR	PC
	.ENDC

;TC11 BOOT ROUTINE
DTBOOT:	MOV	#177344,R0	;ADDR OF WC REGISTER IN R0
	.ENDC
ONEONL:	TSTB	SSB+11		;ONLY UNIT 0 ALLOWED
	BNE	HANER1		;ILLEGAL DEVICE IF UNIT NOT 0
	CLR	R3		;DON'T NEED UNIT POINTER
READ5G:	MOV	#5,R1		;READ COMMAND IS READ (4)+GO (1)
	BR	BM793		;DO COMMON BOOT

;RK11 BOOT ROUTINE
RKBOOT:	MOVB	SSB+11,R2	;UNIT INTO R2
	CLC
	ROR	R2		;SLIDE UNIT TO BITS 15-13
	ROR	R2
	ROR	R2
	ROR	R2
	MOV	#177412,R3	;R3 POINTS TO UNIT REGISTER
	MOV	#177406,R0	;R0 POINTS TO WC
	BR	READ5G		;SET READ COMMAND AND GO TO BOOT

;RF11 ROUTINE
RFBOOT:	MOV	#177462,R0	;POINT R0 TO WC
	BR	ONEONL		;THE RESET IS SHARED WITH DECTAPE

;RP11 ROUTINE
DPBOOT:	MOV	#176716,R0	;POINT RO TO WC
	MOV	SSB+10,R1	;UNIT # INTO R1
	BIC	#174377,R1	;STRIP TO UNIT BITS
	ADD	#5,R1		;READ COMMAND IN R1
	CLR	R3		;DON'T NEED SEPERATE UNIT
	BR	BM793

;RJS03/4 ROUTINE
RJBOOT:	.HRESET			;STOP ALL RT-11 I/O,INCLUDING TTY
	RESET			;AND STOP ALL PDP-11 I/O
	MOV	#RSCS2,R5	;POINT R5 TO RH11 CONROL REG 2
	MOVB	SSB+11,(R5)	;SET UNIT
	CLR	-(R5)		;READ BLOCK 0
	CLR	-(R5)		;INTO  ADRRESS 0
	MOV	#177400,-(R5)	;READ ONE BLOCK
	MOV	#71,-(R5)	;GO
1$:	BIT	#100200,(R5)	;TEST FOR DONE OR ERROR
	BEQ	1$		;WAIT
	BMI	RJBOOT		;KEEP TRYING ON ERROR
	CLR	PC		;BOOT DONE-START SECONDARY
	.END			;END OF BOOTSRAP OVERLAY
                                                                                                                                                               