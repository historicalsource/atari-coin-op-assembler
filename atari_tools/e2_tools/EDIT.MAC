	.TITLE	EDIT	V02-13		
					;IF YOU CHANGE THIS,
					;DON'T FORGET TO CHANGE AT VMSG:



;	RT-11  AND CAPS-11 TEXT EDITOR
;
; COPYRIGHT (C) 1974,1975
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS
; SOFTWARE, OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED
; OR OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON EXCEPT
; FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE
; LICENSE TERMS. TITLE TO AND OWNERSHIP OF THE SOFTWARE
; SHALL AT ALL TIMES REMAIN IN DIGITAL.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
; DIGITAL ASSUMES NO RESPONSIBILITY FOR ANY ERRORS THAT
; MAY APPEAR IN THIS DOCUMENT
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE
; OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DIGITAL.

;	DEC-11-ORTEA-E			;FOR RT-11
;	DEC-11-OTEDA-B			;FOR CAPS-11

;	ROBERT BEAN

;	JANUARY 1973

;	REGISTER ASSIGNMENTS

	R0=%0			;USED FOR MONITOR COMMUNICATION
	R1=%1			;POINTS INTO COMMAND STRINGS
	R2=%2			;USED FOR COMMAND ARGUMENTS
	R3=%3			;GENERAL USAGE
	R4=%4			;GENERAL USAGE
	ISTACK=%5		;USED TO STACK ITERATION BRACKET COUNTS
	SP=%6
	PC=%7


;
; ASSEMBLY PARAMETER
;
;  THE ASSEMBLY PARAMETER '$CAPS11' MUST BE DEFINED
;   AT ASSEMBLY TIME TO PRODUCE A VERSION OF THE EDITOR
;   FOR THE CAPS11 SYSTEM
;
;  CAPS11 VERSION COURTESY OF ROY FOLK
;
; IF '$CAPS11' IS DEFINED THEN THE DISPLAY CODE WILL
; BE DISABLED. FOR RT-11 ASSEMBLY, THE DISPLAY SUPPORT IS INCLUDED
; BY DEFAULT. TO ASSEMBLE THE EDITOR WITHOUT THE DISPLAY FUNCTIONS,
; DEFINE THE ASSEMBLY PARAMETER 'NODISP'. REMOVING DISPLAY CODE, REDUCES
; THE SIZE OF THE EDITOR SIGNIFICANTLY.
;
	.IFDF $CAPS11		;>C>C>C>C>C>C>C>C>C>C
	NODISP=1		;DISABLE DISPLAY SUPPORT
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
;
;
; THE ASSEMBLY PARAMETER 'NODISP' MUST BE UNDEFINED
; AT ASSEMBLY TIME TO PRODUCE THE DISPLAY MONITOR VERSION
; OF THE EDITOR. THE EDITOR SOURCE MUST BE ASSEMBLED
; WITH VTMAC, THE GRAPHICS MACRO LIBRARY. LINKING
; IS DONE WITH VTCED1, VTCED4, AND VTBEDT,
; SMALLER VERSIONS OF THE DISPLAY FILE HANDLER
; MODULES VTCAL1, VTCAL4, AND VTBASE, RESPECTIVELY.
; LINK COMMAND STRING IS:

; EDIT=VTCED1,VTCED4,VTBEDT,EDIT
;
; DISPLAY EDITOR VERSION BY D. VELTEN

; ENHANCEMENTS TO DISPLAY EDITOR BY BRUCE LEAVITT

NODISP	=0			;DEFINE TO REMOVE ALL VT-40 JUNK


;	COMMONLY USED SYMBOLS FOR ASCII CHARACTERS

	LF=12
	FF=14
	CR=15
	MINUS=55
	PLUS=53
	SLASH=57
	SPACE=40
	ALTMDE=33
	LBRCKT=74
	RBRCKT=76
	QMARK=77
	ZERO=60
	NINE=71
	E=105
	M=115
	ASTRSK=52
	EQSIGN=75
	RUBOUT=177
	CTRLU=25
	CTRLX=30
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	CNTRLZ=32
;
	WAITR=3
	XWRITE=4
	TELEPR=2
	XREAD=5
	KEYBRD=3
	HIFREE=42
	KBLADR=50
	KBLRES=52
	PS=177776
	.ENDC			;<<<<<<<<<<<<<<<<<<<<


;	TRAP INSTRUCTION IS USED TO PRINT ERRORS

	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	ERROR=104000
	TRAPV=30
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	ERROR=104400
	TRAPV=34

;	MONITOR I/O MACROS

	.MCALL .FETCH,.LOOKUP,.ENTER,.CLOSE,.READ
	.MCALL .WRITE,.EXIT,.RENAME,.TTYIN,.TTYOUT
	.MCALL .CSISPC,.RELEAS,.SETTOP,.RCTRLO,.PRINT
	.MCALL .LOCK,.UNLOCK,.WAIT,.QSET,.SRESET
	.MCALL .DSTATUS
	.MCALL ..V1..
	..V1..




;	MONITOR COMMUNICATION AREA

	ERRWD=52
	HILOC=50
	R6INIT=42
	JOBSTAT=44
	RMONTP=54
	USRADD=46
	MONCOM=356	;OFFSET TO BATCH COMMUNICATION BYTE
	CONFIG=300	;OFFSET TO RT-11 CONFIGURATION WORD


;	MONITOR PARAMETERS

	UBOFF=266		;OFFSET TO BOTTOM OF USR/CSI
	ULCASE=40000		;UPPER/LOWER CASE BIT IN JSW (BIT 14)

	.ENDC			;<<<<<<<<<<<<<<<<<<<<
;ERROR TRAP VECTOR
;ERRORS CAUSE A TRAP TO THE ERROR ROUTINE WITH ERROR NUMBER
;IN RIGHTMOST BYTE OF TRAP INSTRUCTION. ERROR NUMBER IS USED
;AS AN INDEX INTO THE ERROR MESSAGE TABLE

	.ASECT

	.=TRAPV			;TRAP VECTOR
	ERRORT			;ADDRESS OF ERROR REPORTING ROUTINE
	0			;ERROR PRIORITY=0
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R

;MONITOR COMMUNICATION AREA

	.=JOBSTAT
	0			;JOB STATUS WORD
	.=USRADD
	0			;SWAP ADDRESS FOR FLOATING USR
	.ENDC			;<<<<<<<<<<<<<<<<<<<<


;ERROR REPORTING ROUTINE. TYPES OUT ERROR MESSAGE,THEN GETS NEW
;COMMAND STRING FROM USER

	.CSECT
	.GLOBL START		;MAKE STARTING ADDR SHOW UP IN MAP



ERRORT:	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	.UNLOCK			;UNLOCK THE USR IN CASE IT WAS LOCKED IN
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	IOT
	.BYTE	0,0		;CONTROL /O RESET
	.WORD	0
	CLR	@#PS		;DOWN TO ALLOW ERR.MESS. OUT
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	MOV @SP,R3		;ERROR TRAP ADDRESS INTO R3
	MOV -(R3),R4		;ERROR TRAP INST INTO R4
	BIC #177400,R4		;STRIP TO ARGUMENT BYTE
	ASL R4			;TIMES 2=ADDR OF MESSAGE
	JSR PC,CRLF		;ISSUE CR,LF TO TTY
	MOVB #QMARK,R0		;TYPE "?" ON TTY
	JSR PC,TYPCHAR
	JSR PC,ASTYP		;TYP "*" IF EXECUTUION TIME ERROR
	MOV ERRTAB(R4),R3	;R3 POINTS TO ASCIZ ERROR MESSAGE
	JSR PC,EPRINT		;TYPE IT
	TSTB MACFLG		;YES-ARE WE DOING A MACRO?
	BEQ E64$		;NO-FINISH ERROR MESSAGE
	MOV #MACMSG,R3		;YES-TELL THE USER SO
	JSR PC,EPRINT		;PRINT "IN MACRO" ERROR MESSAGE
E64$:	JSR PC,ASTYP		;TYP "*" IF EXECUTION TIME ERROR
	MOVB #QMARK,R0		;FOLLOW THE MESSAGE WITH "?"
	JSR PC,TYPCHAR
	JSR PC,CRLF		;AND A CRLF
POSTERR:CLRB MACFLG		;CLEAR MACRO FLAG (IN CASE ERROR
				;OCCURRED WHILE WE WERE EXECUTING A MACRO
	MOV	EDSTRT,SP	;RE-INITIALIZE THE STACK
	.IFNDF NODISP		;>G>G>G>G>G>G>G
	TSTB	DSFLG		;ARE WE USING DISPLAY?
	BEQ	1$		;NO DONT REFRESH DISPLAY
	CLRB	SCFLG		;CLEAR IMMEDIATE MODE FLAG
	JSR	PC,DUPDAT	;THEN UPDATE DISPLAY
1$:
	.ENDC			;<<<<<<<<<<<<<<
	JMP ASTER		;GET NEW COMMAND STRING


;EDITOR FLAGS
;FLAGS USED BY COMMAND STRING INTERPRETER LOOP
;ORDER CANNOT CHANGE WITHOUT CHANGING FLAG CLEARING
;INSTRUCTIONS IN THE COMMAND LOOP

NEGFLG:	.BYTE 0			;ARG IS NEGATIVE
SLSFLG:	.BYTE 0			;"/" HAS BEEN SEEN
SPCFLG:	.BYTE 0			;ANY SPECIAL CHARACTER HAS BEEN SEEN
NUMFLG:	.BYTE 0			;A DIGIT HAS BEEN SEEN
EQSFLG:	.BYTE 0			;"=" HAS BEEN SEEN
MACFLG:	.BYTE 0			;WE ARE CURRENTLY EXECUTING A MACRO
ALTFLG:	.BYTE 0			;ALTMODE SEEN ON INPUT
SRCFLG:	.BYTE 0			;SEARCH IN PROGRESS
EOFFLG:	.BYTE 0			;EOF HAS BEEN SEEN IN INPUT FILE
INOFLG:	.BYTE 0			;AN INPUT FILE IS OPEN
OTOFLG:	.BYTE 0			;AN OUTPUT FILE IS OPEN
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
EBFLG:	.BYTE 0			;EDIT BACKUP IN PROGRESS
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
EFFLG:	.BYTE 0			;LAST BLOCK OF FILE HAS BEEN READ
SRFLG:	.BYTE 0			;FLAG USED BY READ TO SIGNIFY AT LEAST ONE NON-NULL CHAR HAS BEEN READ
EXFLG:	.BYTE 0			;EXIT IN PROGRESS
EPFLG:	.BYTE 0			;SET TO 1 WHEN COMMAND PROCESSOR IS IN ERROR PASS
MINFLG:	.BYTE 0			;SET TO 1 WHEN PROCESSING A MACRO DURING ERROR PASS
DELIM:	.BYTE 0			;HOLDS CURRENT MACRO DELIMETER FOR ERROR PASS
	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
SCFLG:	.BYTE 0			;SET TO 1 FOR IMMEDIATE MODE
DSFLG:	.BYTE 0			;SET TO 1 IF DISPLAY IS ACTIVE
FTFLG:	.BYTE 0			;SET TO 1 WHEN 1ST COMMAND SEEN
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.EVEN

;EDITOR COUNTERS AND MISCELLANEOUS REGISTERS

HAND1N:	.WORD 0			;NAME OF DEVICE IN HANDLER AREA 1
HAND2N:	.WORD 0			;NAME OF DEVICE IN HANDLER AREA 2

MACCNT:	.WORD 0			;NUMBER OF TIMES TO EXECUTE CURRENT MACRO
PTR:	.WORD 0			;CURRENT CHARACTER POINTER
ARG:	.WORD 0			;CURRENT COMMAND ARGUMENT
MACR1:	.WORD 0			;SAVED CS POINTER WHILE MACRO BEING EXECUTED
OBLENG:	.WORD 0			;LENGTH OF TEXT OBJECT ***MUST BE FOLLOWED BY OBSTRT***
OBSTRT:	.WORD 0			;START OF TEXT OBJECT RELATIVE TO START OF CIB
TMP:	.WORD 0			;TEMPORARY
CBASE:	.WORD 0			;BASE ADDRESS OF CURRENT COMMAND STRING
CREL:	.WORD 0			;RELATIVE COMMAND POINTER WITHIN COMMAND LINE
EQLENG:	.WORD 0			;LENGTH OF LAST TEXT OBJECT FOR "="
BLOCKS:	.WORD			;LENGTH IN BLOCKS OF INPUT FILE


;PAGE BUFFER POINTERS
;DIVIDES TEXT AREA INTO FOUR BUFFERS

BEND:	0			;END OF MACRO BUFFER
MBSTRT:	0			;START OF MACRO BUFFER
SBSTRT:	0			;START OF SAVE BUFFER
CBEND:	0			;END OF COMMAND BUFFER
CBSTRT:	0			;START OF COMMAND BUFFER
PBSTRT:	0			;START OF PAGE BUFFER

;LOAD MODULE UPPER AND LOWER BOUNDS
;USED TO ESTABLISH STACK AND DYNAMIC AREA START

EDSTRT:	.LIMIT			;STACK START ADDR
EDTOP=EDSTRT+2			;DYNAMIC START ADDR


;ITERATION LOOP STACK AREA
ISTCKE:	.=.+120			;ITERATION STACK-20 2 WORD ENTRIES LONG
ISTCKA:				;START OF STACK

;I/O POINTERS

OBPTR:	0			;POINTER INTO OUTPUT BUFFER
OBLKNM:	0			;CURRENT BLOCK IN OUTPUT FILE
IBPTR:	0			;POINTER INTO INPUT BUFFER
IBLKNM:	0			;CURRENT BLOCK IN INPUT FILE
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R

;I/O QUEUE AREA

IOQ:	0
	.=.+42.			;RESERVE SPACE FOR 3 ENTRIES

;DSTATUS BLOCK FOR RELEAS SUBROUTINE

CORADD:	.WORD	0,0,0,0		;ARGUMENT BLOCK FOR .DSTATUS

;CSI DEFAULT EXTENSION LIST

DEFEXT:	.WORD	0,0		;NO DEFAULT EXTENSIONS, REALLY

; CSI WORKING AREA

CSIBLK:	.BLKW	39.			;CSI WORK AREA
CSISTR:	.BLKW	11.			;CSI INPUT STRING (19. CHARS
					;+ '<' PLUS NULL TERMINATOR).

;I/O FILE NAMES

FILENG:	.WORD	0		;LENGTH OF LAST FILE SPECIFIED
				;IN FNGET

INBLK:	.WORD 75250		;RAD50 DEV NAME FOR INPUT FILE (SY FOR DEFAULT DEV)
	.WORD 0
	.WORD 0			;RAD50 FILE NAME FOR CURRENT INPUT FILE
	.WORD 0

OUTBLK:	.WORD 75250		;RAD50 DEV NAME FOR OUTPUT FILE (SY FOR DEFAULT)
	.WORD 0
	.WORD 0			;RAD50 FILE NAME FOR CURRENT OUTPUT FILE
	.WORD 0

	.ENDC			;<<<<<<<<<<<<<<<<<<<<

	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
DEVPTR:	.WORD	0		;HOLDS I.O CHAN. BYTE
;I/O BUFFERS
IBUFF1:	0			;IN. BUFF. #1
	.=.+126.
IBUFF2:	0			;IN. BUFF. #2
	.=.+126.
IBEND:
OBUFF1:	0			;OUT. BUFF. #1
	.=.+126.
OBUFF2:	0			;OUT. BUFF #2
	.=.+126.
OBEND:
;I/O FILE NAMES
INBLK:	.WORD	0,0,0,0,0	;INPUT FILE NAME
OUTBLK:	.WORD	0,0,0,0		;NAME
	.BYTE	0
	.BYTE	1		;ASCII TYPE
	.BYTE	0,200		;LENGTH
	.BYTE	0,0		;SEQ/CONT
OBDATE:	.WORD	0,0,0		;DATE
	.WORD	0,0,0,0,0,0	;EXTRA
	.ENDC			;<<<<<<<<<<<<<<<<<<<<

;I/O BUFFERS

IBUFF1:	0			;INPUT BUFFER 1
	.=.+776
IBUFF2:	0			;INPUT BUFFER 2
	.=.+776
IBEND=.				;MARK END OF INPUT BUFFER 2

; USR WILL SWAP OVER THE NEXT 10000 BYTES:

USRSWP:

OBUFF1:	0			;OUTPUT BUFFER 1
	.=.+776
OBUFF2:	0			;OUTPUT BUFFER 2
	.=.+776
OBEND=.				;MARK END OF OUTPUT BUFFER 2
;SUBROUTINE CRLF-PUTS CR AND LF ON CONSOLE TTY

CRLF:	CMPB	LASTC,#12
	BEQ	CRLFOUT
	MOVB	#CR,R0		;TYPE A <CR>
	JSR	PC,TYPCHAR
LFOUT:	MOVB	#LF,R0
	JSR	PC,TYPCHAR
CRLFOUT:RTS	PC

;SUBROUTINE ASTYP
;TYPES AN "*" IF EPFLG=0

ASTYP:	TSTB EPFLG		;ARE WE ON ERROR PASS?
	BNE ASTYPR		;YES-RETURN
	MOVB #ASTRSK,R0		;NO-TYPE AN "*"
	JSR PC,TYPCHAR
ASTYPR:	RTS PC

;SUBROUTINE EPRINT
;PRINTS ASCII MESSAGE POINTED TO BY R3 ON TELETYPE
;DESTROYS R0

EPRINT:	MOVB (R3)+,R0		;PRINT MSG CHAR
	JSR PC,TYPCHAR
	TSTB (R3)		;DONE?
	BNE EPRINT		;NO-DO NEXT CHARACTER
	RTS PC			;YES-RETURN
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C
;
; SUBROUTINE TTYOUT - OUTPUT SINGLE CHAR. (UNFORM. ASCII)
;
TTYOUT:	IOT			;WAIT FOR TTY
	.BYTE	WAITR,TELEPR
	+	TTYOUT		;BUSY RETURN
	MOVB	R0,EDBUFF	;PLACE CHAR.
	IOT			;WRITE
	.BYTE	XWRITE
	.BYTE	TELEPR
	+	TTOUTB
	RTS	PC
;
TTOUTB=.-2			;BUFF. SIZE (IGN. ON WRITE)
	.BYTE	0		;MODE: FORM. ASCII
	.BYTE	200		;ST/ERR
	.WORD	1		;ONE BYTE BUFFER
EDBUFF:	.BYTE	0
	.EVEN
	.ENDC			;<<<<<<<<<<<<<<<<<<<<

;SUBROUTINE TYPCHAR
;OUTPUTS A CHARACTER TO THE TTY
;ALL TTY OUTPUT MUST GO THROUGH THIS ROUTINE BECAUSE IT HANDLES TABS,
;FORM FEEDS,ALTMODES ETC.

TYPCHAR:MOVB	R0,(PC)+	;SAVE THIS CHAR AS LAST CHAR TYP
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
LASTC:	12			;INIT. TO LF
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
LASTC:	0			;ST. W/ CR,LF
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	CMPB	R0,#12		;IS CHAR A LF?
	BNE	E121$		;NO
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
E122$:	JSR	PC,TTYOUT
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
E122$:	JSR	PC,TSTVF	;SEE IF WE'RE IN VERIFY MODE
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	RTS	PC		;RETURN
E121$:	MOV	R0,-(SP)	;SAVE CHAR
	CMPB	R0,#40		;IS CHAR PRINTABLE?
	BGE	E120$		;YES - GO PRINT IT
	CMPB	R0,#FF		;IS IT A FORM FEED?
	BNE	E123$		;NO
	MOV	#LF,R0		;YES-ECHO LINE FEEDS
	MOV	#10,E124$	;8 OF 'EM
E125$:	JSR	PC,E122$	
	DEC	(PC)+		;DONE?
E124$:	0			;COUNTER FOR FORM FEED ECHO
	BGT	E125$		;NO-DO ANOTHER
EE118$:	MOV	(SP)+,R0	;YES-RESTORE R0
	RTS	PC		;RETURN
E123$:	CMPB	R0,#15		;IS CHAR A CR?
	BNE	E126$		;NO
	MOV	#11,E127$	;YES-RESET TAB COUNTER
	BR	E120$		;PRINT IT
E126$:	CMPB	R0,#11		;IS CHAR A TAB?
	BEQ	E8$		;YES
	CMPB	R0,#33		;NO-IS IT AN ALTMODE?
	BNE	E119$		;NO
	MOVB	#'$,R0		;YES-TYP "$"
E119$:	CMPB	R0,#40		;IS CHAR NON-PRINTING?
	BGE	E120$		;NO-PRINT IT
	MOVB	#'^,R0		;YES-ECHO "^X"
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
E128$:	JSR	PC,TTYOUT
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
E128$:	JSR	PC,TSTVF	;SEE IF WE'RE IN VERIFY MODE
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	MOV	(SP),R0		;RESTORE CHAR TO R0
	BIS	#100,R0		;WHERE X IS CHAR - 100
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
E120$:	JSR	PC,TTYOUT
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
E120$:	JSR	PC,TSTVF	;SEE IF WE'RE IN VERIFY MODE
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	DEC	E127$		;DECREMENT TAB COUNTER
	BNE	EE118$		;RETURN IF TAB COUNTER NOT EMPTY
EE117$:	MOV	#10,(PC)+	;RESET TAB COUNTER
E127$:	.WORD	8.		;TAB COUNTER (INIT TO 8)
	BR	EE118$		;RETURN
E8$:	MOVB	OTBNDX,R0	;TAB HISTORY INFEX TO R0
	MOVB	E127$,TABNDX(R0) ;SAVE TAB COUNT
	INC	R0
	BIC	#-8.,R0		;NO OVERFLOW ALLOWED
	MOVB	R0,OTBNDX	;SAVE THE ANSWER
1$:	MOV	#40,R0		;FOR TABS,ECHO SPACES
	JSR	PC,E122$		;TYPE IT
	DEC	E127$		;AS MANY AS ARE NEEDED TO REACH
	BGT	1$		;MORE
	BR	EE117$		;DONE

OTBNDX:	.WORD	0		;TAB HISTORY INDEX
TABNDX:	.BYTE	1,1,1,1,1,1,1,1		;TAB HISTORY REGISTER

TSTVF:	TST	VFLG		;VERIFY MODE?
	BEQ	1$		;NOPE
	MOV	#40,R0		;YEP. FAKE IT.
1$:	.TTYOUT			;PRINT IT
	RTS	PC
;ERROR MESSAGE TABLE
;CONTAINS STARTING ADDRESSES OF ERROR MESSAGES

ERRTAB:	MSG0			;"<>" ERR
	MSG1			;ILL ARG
	MSG2			;ILL CMD
	MSG3			;CB FULL
	MSG4			;NO ROOM
	MSG5			;SRCH FAIL
	MSG6			;ILL MAC
	MSG7			;EOF
	MSG10			;HDW ERR
	MSG11			;FILE FULL
	MSG12			;ILL DEV
	MSG13			;FILE NOT FND
	MSG14			;NO FILE
	MSG15			;DIR FULL
	MSG16			;ILL NAME
	MSG17			;ABEND
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C
	MSG17			;I.O CHAN. CONFLICT
	MSG20			;TAPE FULL
	.ENDC			;<<<<<<<<<<<<<<<<<<<<

;ERROR MESSAGES
;ASCII ERROR MESSAGES ARE STORED HERE
;ALL MESSAGES MUST END IN A 0 BYTE

MSG0:	.ASCII /"<>" ERR/
	.BYTE 0
MSG1:	.ASCII /ILL ARG/
	.BYTE 0
MSG2:	.ASCII /ILL CMD/
	.BYTE 0
MSG3:	.ASCII /CB FULL/
	.BYTE 0
MSG4:	.ASCII /NO ROOM/
	.BYTE 0
MSG5:	.ASCII /SRCH FAIL/
	.BYTE 0
MSG6:	.ASCII /ILL MAC/
	.BYTE 0
MSG7:	.ASCII /EOF/
	.BYTE 0
MSG10:	.ASCII /HDW ERR/
	.BYTE 0
MSG11:	.ASCII /FILE FULL/
	.BYTE 0
MSG12:	.ASCII /ILL DEV/
	.BYTE 0
MSG13:	.ASCII /FILE NOT FND/
	.BYTE 0
MSG14:	.ASCII /NO FILE/
	.BYTE 0
MSG15:	.ASCII /DIR FULL/
	.BYTE 0
MSG16:	.ASCII /ILL NAME/
	.BYTE 0
MSG17:	.ASCIZ	/ABEND/
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
MSG17:	.ASCII	-I/O CHAN CONFLICT-
	.BYTE	0
MSG20:	.ASCII	/TAPE FULL/
	.BYTE	0
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
MACMSG:	.ASCII / IN MACRO/
	.BYTE 0
OKCLOS:	.ASCII	/OUT FILE FULL./<12><15>/OK TO CLOSE? /<200>
	.EVEN
;EDITOR COMMAND TABLES

;COMMAND NAME TABLES-HOLDS SINGLE CHARACTERS FOR EDIT COMMANDS

CTABLE:
;COMMANDS BELOW THIS POINT ALLOW NO ARGUMENTS
NOARG:	.BYTE 'R		;READ
	.BYTE 'B		;BEGINNING
	.BYTE 'V		;VERIFY
	.BYTE 'I		;INSERT
	.BYTE '>		;ITERATION END
;COMMANDS BELOW THIS POINT ALLOW "0" ARGUMENT ONLY
ZROARG:	.BYTE 'U		;UNSAVE
	.BYTE 'M		;MACRO
;COMMANDS BELOW THIS POINT ALLOW POSITIVE ARGUMENTS ONLY
POSARG:	.BYTE 'N		;NEXT
	.BYTE 'S		;SAVE
	.BYTE 'G		;GET
	.BYTE 'F		;FIND
	.BYTE 'P		;POSITION
	.BYTE '<		;ITERATION START
;COMMANDS BELOW THIS POINT ALLOW ALL ARGUMENTS EXCEPT "@"
EXCPAT:	.BYTE 'W		;WRITE
	.BYTE 'A		;ADVANCE
	.BYTE 'X		;EXCHANGE
	.BYTE 'L		;LIST
	.BYTE 'K		;KILL
;COMMANDS BELOW THIS POINT ALLOW ALL ARGUMENTS
ALLARG:	.BYTE 'D		;DELETE
	.BYTE 'C		;CHANGE
CTEND:	.BYTE 'J		;JUMP
;COMMANDS BELOW THIS POINT ARE TWO LETTER COMMANDS,THE FIRST OF WHICH IS "E"
ETABLE:	.BYTE 'M		;EXECUTE MACRO
	.BYTE 'X		;EXIT
	.BYTE 'R		;EDIT READ
	.BYTE 'W		;EDIT WRITE
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	.BYTE 'B		;EDIT BACKUP
	.BYTE 'L		;EDIT LOWER
	.BYTE 'U		;EDIT UPPER
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
	.BYTE 'D		;EDIT DISPLAY
	.BYTE 'C		;EDIT CONSOLE
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.BYTE 'V		;EDIT VERSION
ETEND:	.BYTE 'F		;END FILE

	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
;COMMANDS BELOW ARE EXECUTED IN EXTENDED DISPLAY MODE
STABLE:
	;COMMANDS BELOW HAVE 0 OR NO ARGUMENT
NARG:	.BYTE ALTMDE,175,176	;ALTMODES
	;COMMANDS BELOW HAVE POSITIVE ARG
PARG:	.BYTE 'N-100		;CURSOR TO NEXT LINE (ADVANCE)
	.BYTE 'D-100		;CURSOR FORWARD ONE CHAR
	;COMMANDS BELOW HAVE NEGATIVE ARG
MARG:	.BYTE 'V-100		;CURSOR BACK ONE CHAR
	.BYTE 'G-100		;CURSOR UP ONE LINE
STEND:	.BYTE RUBOUT		;DELETE CHAR PRECEDING CURSOR
	.ENDC		;<<<<<<<<<<<<<<<<<<<<
	.EVEN
;ERROR PASS DISPATCH TABLES
;THESE TABLES ARE USED TO DISPATCH TO ROUTINES ON ERROR PASS

EPTAB1:	JR			;READ
	JR			;BEGIN
	JR			;VERIFY
	TMODE			;INSERT
	RGTBRK			;>
	JR			;UNSAVE
	MACEP			;MACRO
	JR			;NEXT
	JR			;SAVE
	TMODE			;GET
	TMODE			;FIND
	TMODE			;POSITION
	LFTBRK			;<
	JR			;WRITE
	JR			;ADVANCE
	TMODE			;XCHANGE
	JR			;LIST
	JR			;KILL
	JR			;DELETE
	TMODE			;CHANGE
	JR			;JUMP

;JR IS SIMPLY AN RTS PC

EPTAB2:	EMACEP			;EXECUTE MACRO
	JR			;EXIT
	TMODE			;EDIT READ
	TMODE			;EDIT WRITE
	.IFNDF $CAPS11		;>R>R>R>R>R>R>R>R>R>R
	TMODE			;EDIT BACKUP
	JR			;EDIT LOWER
	JR			;EDIT UPPER
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
	JR			;EDIT DISPLAY
	JR			;EDIT CONSOLE
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	JR			;EDIT VERSION
	JR			;END FILE

;EDITOR DISPATCH TABLE
;ON THE EXECUTION PASS,THIS TABLE IS USED AS THE JUMP TABLE FOR
;THE VARIOUS COMMAND ROUTINES

DTABLE:	READ
	BEGIN
	VERIFY
	INSERT
	RGTBRK
	UNSAVE
	MACRO
	NEXT
	SAVE
	GET
	FIND
	POSITN
	LFTBRK
	WRITE
	ADVNCE
	XCHNGE
	LIST
	KILL
	DELETE
	CHANGE
	JUMP

EDTABL:	EMACRO
	EXIT
	EREAD
	EWRITE
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	EBCKUP
	ELOWER
	EUPPER
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
	EDSPLY
	ECONS
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	EVERS
	EFILE

	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
;DISPLAY MODE DISPATCH TABLE
SDTABL:	ALTM
	ALTM
	ALTM
	ADVNCE
	JUMP
	JUMP
	ADVNCE
	DELETE
	.ENDC		;<<<<<<<<<<<<<<<<<<<<
;ROUTINE COMAND
;BASIC EDITOR COMMAND LOOP
;EXPECTS CBASE TO POINT TO A COMMAND STRING WHICH ENDS IN A 0 BYTE.
;MAKES TWO PASSES OVER THE COMMAND STRING. THE FIRST USES THE
;DISPATCH TABLES AT EPTAB1 AND EPTAB2,CALLING THE APPROPRIATE ERROR
;CHECKING ROUTINE FOR EACH COMMAND. THE SECOND TIME THROUGH,THE
;DISPATCH TABLES AT DTABLE ARE USED,CALLING THE ACTUAL COMMAND EXECUTIONE
;ROUTINES.

COMAND:	INCB EPFLG		;COMMENCE ERROR PASS
COMND1:	CLR CREL		;START POINTER AT BEGINNING OF COMMAND
	CLRB MINFLG		;MACRO PROCESS FLAG CLEARED

CLOOP:	MOV CBASE,R1		;START OF COMMAND STRING
	ADD CREL,R1		;R1 IS ABSOLUTE POINTER INTO CS
	CLR SPCFLG		;CLEAR SPECIAL CHARACTER AND NUMBER SEEN FLAG
	CLR NEGFLG		;CLEAR NEGATIVE AND "/" FLAG
	CLRB EQSFLG		;CLEAR = SEEN FLAG
	CLRB SRCFLG		;CLEAR SEARCH IN PROGRESS FLAG
	CLR R2			;ZERO ARGUMENT
C16$:	TSTB MINFLG		;ARE WE PROCESSING A MACRO?
	BEQ CL3			;NO
	CMPB (R1),DELIM		;DELIMETER SEEN?
	BEQ MOUTEP		;YES
	TSTB (R1)		;NO-END OF STRING?
	BNE C11$		;NO
	ERROR+6			;YES-DELIMETER ERROR
MOUTEP:	CMP ISTACK,TMP		;DID MACRO MAKE A NET CHANGE IN
	BEQ MOUTP1		;THE ITERATION STACK?
	ERROR+0			;YES-"<> ERR"
MOUTP1:	CLRB MINFLG		;DELIMETER SEEN-CLEAR MACRO PROCESS FLAG
	JMP CECOM		;NEXT CHAR

CL3:	TSTB (R1)		;END OF STRING?
	BNE C11$		;NO
	TSTB MACFLG		;ARE WE PROCESSING A MACRO?
	BNE CL1			;YES-NO NEED TO CHECK STACK
	CMP ISTACK,#ISTCKA	;IS STACK FREE
	BEQ CL1			;YES
	ERROR+0			;NO-"<>" ERROR
CL1:	TSTB EPFLG		;ERROR PASS
	BNE CL2			;YES
	.IFNDF NODISP		;>G>G>G>G>G>G>G
	TSTB	DSFLG		;IS DISPLAY BEING USED?
	BEQ	1$		;NO - DON'T GO UPDATE IT
	JSR	PC,DUPDAT	;UPDATE THE DISPLAY
1$:
	.ENDC			;<<<<<<<<<<<<<<
	JMP ASTER		;NO-GET NEXT COMMAND STRING
CL2:	CLRB EPFLG		;START EXECUTION PASS
	BR COMND1

C11$:	CMPB (R1),#SPACE	;IS NEXT CHAR A SPACE?
	BEQ E12$		;YES-IGNORE IT
	CMPB (R1),#ALTMDE	;IGNORE ALTMODES BETWEEN COMMANDS
	BEQ E12$
	CMPB (R1),#CR		;NO-IS IT A CR?
	BEQ E12$		;YES-IGNORE IT
	CMPB (R1),#LF		;NO-IS IT A LF?
	BEQ E12$		;YES-IGNORE IT
	CMPB (R1),#PLUS		;NO-IS IT A "+"
	BNE E13$		;NO-CHECK FOR A "="
	JSR PC,CHECKF		;YES-MAKE CERTAIN IT IS LEGAL
	BR E12$			;THEN MOVE ON
E13$:	CMPB (R1),#MINUS	;IS IT A "="
	BNE E14$		;NO-CHECK FOR A "/"
	JSR PC,CHECKF		;MAKE SURE ITS LEGAL
	INCB NEGFLG		;YES SET NEGATIVE FLAG
	BR E12$			;CONTINUE
E14$:	CMPB (R1),#SLASH	;IS IT A "/"
	BNE E17$		;NO-CHECK FOR A "="
	JSR PC,CHECKF		;MAKE SURE ITS LEGAL
	INCB SLSFLG		;YES-SET "/" FLAG
	BR E12$			;MOVE ON
E17$:	CMPB (R1),#EQSIGN	;IS IT AN "="
	BNE E15$		;NO-CHECK FOR A DIGIT
	JSR PC,CHECKF		;YES-MAKE SURE IT'S LEGAL
	INCB EQSFLG		;MARK IT SEEN
	INCB NEGFLG		;= IS A NEGATIVE ARGUMENT
	BR E12$			;MOVE ON
E15$:	CMPB (R1),#ZERO		;IS CHAR <0?
	BLO CNTDIG		;YES-IT IS NOT A DIGIT
	CMPB (R1),#NINE		;IS CHAR <9?
	BHI CNTDIG		;NO-IT IS NOT A DIGIT
	TSTB SLSFLG		;YES-CHAR IS DIGIT. "/" SEEN?
	BNE ERR1		;YES-ARGUMENT ERRROR
	TSTB EQSFLG		;CHAR IS DIGIT ;= SEEN?
	BNE ERR1		;YES-ILLEGAL ARG
	MOVB (R1),R4		;MOVE DIGIT INTO R4 AS A TEMPORARY
	BIC #177760,R4		;STRIP TO 4 BITS
	ASL R2
	MOV R2,-(SP)
	ASL R2			;MULTIPLY CURRENT ARG BY 10
	ASL R2
	ADD (SP)+,R2
	ADD R4,R2		;AND ADD IN MOST RECENT DIGIT
	BCS ERR1		;ARGUMENT TOO LARGE
	BIT #140000,R2		;TEST FOR AN ARG>16384
	BNE ERR1		;IF SO,IT IS TOO BIG
	ADD #401,SPCFLG		;SET SPECIAL CHARACTER AND NUMBER SEEN FLAGS
E12$:	INC R1			;BUMP POINTER TO NEXT CS CHARACTER
	INC CREL		;UPDATE CS POINTER
	BR C16$			;CONTINUE

ERR1:	ERROR+1			;ILLEGAL ARGUMENT

	;IF WE GET THIS FAR,CHAR MUST BE A COMMAND OR IT IS ILLEGAL

CNTDIG:	JSR	PC,UCTRAN	;TRANSLATE COMMAND CHAR TO UPPER CASE
	CMPB (R1),#E		;IS CHARACTER "E"?
	BEQ ECMD		;YES-IT IS A TWO LETTER COMMAND
	MOV #NOARG,R4		;NO-SET UP SEARCH
E63$:	CMPB (R4)+,(R1)		;SEARCH FOR CHAR IN CTABLE
	BEQ CFOUND		;MATCH
	CMP R4,#CTEND+1		;NO-MATCH. CHECK FOR END OF TABLE
	BLO E63$		;END NOT REACHED-CONTINUE SEARCH
ERR2:	ERROR+2			;END OF TABLE REACHED-ILLEGAL COMMAND

	;COMMAND CHAR HAS BEEN FOUND

CFOUND:	CMP R4,#ALLARG		;IS COMMAND IN ALL ARG SECTION?
	BHI E24$		;YES-ALL ARGS ARE LEGAL-DISPATCH TO COMMAND
	TSTB EQSFLG		;WAS "=" SEEN?
	BNE ERR1		;IF SO,IT WAS AN ILLEGAL ARG
	CMP R4,#EXCPAT		;DOES COMMAND ALLOW ALL ARGS EXCEPT "@"?
	BHI E26$		;YES-GO EXECUTE IT
	CMP R4,#POSARG		;NO-IS COMMAND PAST POS ARG SECTION?
	BLOS E22$		;NO-CHECK IF ZERO ARGS ALLOWED
	TSTB NUMFLG		;NUMBER SEEN YET?
	BEQ E21$		;NO-ZERO ARG IS CORRECT
	TST R2			;CHECK THE ARGUMENT
	BEQ ERR1		;IF =0 IT IS ILLEGAL
E21$:	TSTB NEGFLG		;MINUS SIGN TYPED?
	BNE ERR1		;YES-ARG ILLEGAL
	TSTB SLSFLG		;SLASH SEEN?
	BNE ERR1		;YES-ILLEGAL ARG
	BR E26$			;ARG IS LEGAL-CALL SUBROUTINE
E22$:	CMP R4,#ZROARG		;DOES COMMAND ALLOW "0" ARGUMENT?
	BLOS E23$		;NO-IT ALLOWS NO ARGS
	TST R2			;YES-IS ARG=0?
	BEQ E26$		;YES-EXECUTE COMMAND
E23$:	TSTB SPCFLG		;ANY ARG TYPED?
	BNE ERR1		;YES-ILLEGAL ARGUMENT

	;EXECUTE COMMAND

E24$:	TSTB EQSFLG		;WAS ARG "="?
	BEQ E26$		;NO
	MOV EQLENG,R2		;YES-ARG WAS LENGTH OF LAST TEXT OBJ
	BR E25$
E26$:	TSTB NUMFLG		;NUMBER SEEN?
	BNE E25$		;YES
	INC R2			;NO-SET ARG=1
E25$:	SUB #CTABLE+1,R4	;FIND COMMAND NUMBER
	MOV #EPTAB1,R3		;R3 POINTS TO ERROR PASS DISPATCH TABLE
	TSTB EPFLG		;ARE WE IN ERROR PASS?
	BNE CMDEX		;YES-USE ERROR TABLE
	ADD #DTABLE-EPTAB1,R3	;NO-USE REGULAR DISPATCH TABLE
	BR CMDEX		;EXECUTE THE COMMAND
	;SEARCH FOR "E" COMMANDS

ECMD:	INC CREL
	INC R1			;POINT TO CHAR FOLLOWING "E"
	JSR	PC,UCTRAN	;TRANSLATE CHARACTER TO UPPER CASE
	MOV #ETABLE,R4		;SET UP SEARCH
E31$:	CMPB (R4)+,(R1)		;SEARCH FOR COMMAND IN ETABLE
	BEQ E32$		;FOUND IT?
	CMP R4,#ETEND+1		;NO-END OF TABLE YET?
	BHIS ERR2		;YES-ILLEGAL COMMAND
	BR E31$			;NO-CONTINUE

	;"E" COMMAND FOUND

E32$:	CMPB (R1),#M		;IS CMD=EM?
	BEQ C35$		;YES-POSITIVE ARGS ALLOWED
	JSR PC,CHECKF		;NO-NO ARGS ALLOWED
C33$:	SUB #ETABLE+1,R4	;FINE COMMAND #
	MOV #EPTAB2,R3		;POINT R3 TO ERROR PASS DISPATCH TABLE
	TSTB EPFLG		;ARE WE IN ERROR PASS?
	BNE CMDEX		;YES-USE ERROR TABLE
	ADD #EDTABL-EPTAB2,R3	;NO-USE REGULAR TABLE

;COMMAND EXECUTER
;CALLED WITH ARG IN R2,COMMAND # IN R4,AND POINTER TO
;DISPATCH TABLE IN R3

CMDEX:	MOV R2,ARG		;SET UP ARG
	ASL R4			;CMD #*2=INDEX OF ADDR IN JUMP TABLE
	MOV R3,TABIND		;PUT TABLE POINTER AS INDEX OF NEXT INST
	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
	TSTB	EPFLG		;ERROR PASS?
	BNE	1$		;YES - DON'T CHECK FOR 'ED' CMD
	JSR	PC,CHECKC	;SEE IF WE CAN RECLAIM DISPLAY CORE
1$:
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	JSR PC,@0(R4)		;JUMP TO COMMAND SUBROUTINE
	TABIND=.-2
CECOM:	INC CREL		;MOVE POINTER TO NEXT CHAR
	JMP CLOOP		;NEXT COMMAND

C35$:	TSTB NEGFLG		;NEGATIVE ARGUMENT?
	BNE ERR1		;YES-ILLEGAL
	TSTB SLSFLG		;SLASH SEEN?
	BNE ERR1		;YES-ILLEGAL ARG
	TSTB NUMFLG		;WAS A NUMBER TYPED?
	BNE E34$		;YES-CHECK IT
	INC R2			;NO  NUM TYPED-SET ARG TO 1
E34$:	TST R2			;YES-IT BETTER NOT BE 0
	BEQ ERR1		;IT IS-ERROR
	BR C33$			;ARG OK-CONTINUE


;SUBROUTINE CHECKF
;USED BY THE COMMAND LOOP TO CHECK VARIOUS ARGUMENT FLAGS WHEN A
;CHARACTER SUCH AS +,- AND / ARE SEEN

CHECKF:	TST SPCFLG		;NUMBER OR SPECIAL CHAR SEEN YET?
	BNE ERR1		;YES-ILLEGAL ARG
	TSTB NEGFLG		;MINUS SIGN SEEN YET?
	BNE ERR1		;YES-ILLEGAL ARG
	INCB SPCFLG		;NO-SET IT
JR:	RTS PC			;RETURN

;SUBROUTINE UCTRAN
;USED BY COMMAND PROCESSING ROUTINES TO TRANSLATE THE CHARACTER
;POINTED TO BY R1 TO UPPER CASE. THE TRANSLATED CHARACTER IS NOT MOVED.

UCTRAN:	CMPB (R1),#141		;IS ASCII VALUE OF CHAR<141?
	BLT E60$		;YES-OK TO PROCESS
	CMPB (R1),#172		;IS CHAR A LOWER CASE ALPHABETIC?
	BGT E60$		;NO-OK TO PROCESS
	BICB #40,(R1)		;YES-TRANSLATE TO UPPER CASE
E60$:	RTS PC			;RETURN

	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G

;THIS ROUTINE ATTEMPTS TO RECLAIM DISPLAY CODE AND BUFFERS
;IF THE SCROLLER IS NOT ACTIVE AND 'EDIT DISPLAY' WAS NOT THE 
;FIRST COMMAND ENTERED

CHECKC:	TSTB	FTFLG		;FIRST COMMAND?
	BEQ	2$		;NO RETURN
	CLRB	FTFLG		;NEVER RETURN
	TSTB	DSFLG		;IS SCROLLER ACTIVE
	BNE	2$		;YES - LEAVE
	CMP	R3,#EDTABL	;WAS IT AN 'E' COMMAND
	BNE	1$		;NO - RECLAIM
	CMPB	(R1),#'D	;WAS IT 'ED'
	BEQ	2$		;YES - RETURN
1$:	MOV	ICERR,EDSPLY	;ERROR IF ED IS USED
	CMP	#EDEND,EDTOP	;CAN WE STEAL THE CORE
	BNE	2$		;NO - RETURN
	MOV	R4,R0		;SAVE R4
	MOV	CBSTRT,R2	;SET UP PARMS FOR
	MOV	CBEND,R3	;CIB TO LOWER CORE
	MOV	#DSFILE,R4	;PLACE TO MOVE IT TO
	MOV	R4,PTR		;RESET POINTERS
	MOV	R4,CBSTRT	;
	MOV	R4,PBSTRT	;
	MOV	R4,CBASE	;
	MOV	R4,EDTOP	;NEW TOP
	SUB	R2,CBEND	;SET UP NEW CBEND
	ADD	R4,CBEND	;
	JSR	PC,MOVDWN	;MOVE IT
	MOV	R0,R4		;RESTORE R4
	MOV	ARG,R2		;	 R2
	MOV	TABIND,R3	;	 R3
2$:	RTS	PC		;OUT


ICERR:	ERROR+2			;ED ERROR ZAP


	;EDITOR IMMEDIATE MODE COMMAND LOOP
;ENTERED UPON RECEIVING DOUBLE ALTMODE IN COMMAND MODE
;EXITS TO COMMAND MODE PROCESSING UPON RECEIPT OF SINGLE ALTMODE
	;USES SDTABL TO CALL IMMEDIATE COMMAND ROUTINES
	;ALL NON-COMMAND CHARS ARE INSERTED INTO TEXT AUTOMATICALLY

REFRSH:	JSR	PC,DUPDAT	;UPDATE THE DISPLAY

SCOMND:
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	IOT
	.BYTE	XREAD,KEYBRD	;READ FROM TTY
	+	TTINBUF
INW1:	BITB	#200,TTST	;WAIT FOR CHAR.
	BEQ	INW1
	MOVB	CHART,R0	;COLLECT CHAR.
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	.TTYIN			;GET CHAR FROM TTY
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	CMPB	#175,R0		;CHECK IF CHAR IS IN TABLE
	BHIS	SC1$		;YES - MATCH IT
	CMPB	#40,R0		;IS CHAR A CTRL?
	BHIS	SC3$		;NOT IN TABLE - GO INSERT IT
SC1$:	MOV	#STABLE,R4	;SET UP TABLE SEARCH TOP
	MOV	#STEND+1,R3	;TABLE END
SC2$:	CMPB	(R4)+,R0	;SEARCH CHAR IN STABLE
	BEQ	SFOUND		;MATCH - GO EXECUTE CMD
	CMP	R4,R3		;END OF TABLE?
	BLO	SC2$		;NO - CONTINUE SEARCH

	;INSERT ANY CHARACTER NOT IN TABLE

SC3$:	MOV	CBEND,R3	;INITIALIZE 'FROM' PTR FOR MOVUP
	MOV	SBSTRT,R2	;CHECK IF SPACE IS AVAILABLE
	SUB	R3,R2		;TEXT BUFF
	SUB	#10,R2		;ROOM FOR EMERGENCY COMMAND
	BHIS	SC4$		;SPACE AVAILABLE - CONTINUE
	ERROR+4			;"NO ROOM"
SC4$:	MOV	PTR,R2		;SET CURRENT PTR FOR MOVUP
	INC	CBEND		;BUFFER WILL BE 1 CHAR LARGER
	INC	CBSTRT		;ALSO BUMP CIB START PTR BY 1
	MOV	CBEND,R4	;INITIALIZE 'TO' PTR
	JSR	PC,MOVUP	;MAKE ROOM FOR CHAR
	MOVB	R0,(R3)+	;INSERT CHAR, AND BUMP PTR
	MOV	R3,PTR		;RESET CURSOR POSITION
	JMP	REFRSH		;REFRESH DISPLAY, GET NEXT CHAR

	;IMMEDIATE COMD CHAR HAS BEEN FOUND

SFOUND:	CLRB	SLSFLG		;CLEAR "/" SEEN FLAG
	CLRB	NEGFLG		;CLEAR "-" SEEN FLAG
	CLR	R2		;ZERO ARGUMENT
	CMP	R4,#PARG	;IS ARG +1?
	BLOS	SC5$		;NO - ZERO
	INC	R2		;SET ARG TO +1
	CMP	R4,#MARG	;IS ARG -1?
	BLOS	SC5$		;NO - +1
	INCB	NEGFLG		;SET ARG TO -1
SC5$:	MOV	R2,ARG		;SET UP ARG
	SUB	#STABLE+1,R4	;CALCULATE CMD NUMBER
	ASL	R4		;#*2=INDEX INTO JUMP TABLE
	JSR	PC,@SDTABL(R4)	;JUMP TO COMMAND SUBROUTINE
	JMP	REFRSH		;REFRESH DISPLAY, GET NEXT CHAR
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.SBTTL CONTROL U STUFF (**** D.S.)
;ROUTINE ASTER
;GETS NEXT COMMAND STRING AFTER CURRENT ONE FINISHED

ASTER:	TSTB MACFLG		;DID WE JUST FINISH A MACRO?
	BEQ AST1		;NO-GET NEXT STRING FROM TTY
	DEC MACCNT		;YES-DECREMENT MACRO COUNT
	BEQ AST9		;IF COUNT=0,RESUME MASTER STRING
	CLR CREL		;COUNT NOT ZERO-START MACRO AGAIN
	JMP CLOOP		;EXECUTE COMMAND STRING

	;MACRO IS FINISHED-RESUME MASTER STRING

AST9:	MOV CBSTRT,CBASE	;RETURN TO MASTER COMMAND STRING
	MOV MACR1,CREL		;GET SAVED CS POINTER
	CLRB MACFLG		;CLEAR MACRO FLAG
	JMP CECOM		;CONTINUE IN MASTER STRING

	;COMMAND STRING MUST COME FROM TTY

AST101:	JSR PC,CRLF		;ISSUE CRLF
AST1:	CLRB ALTFLG		;CLEAR ALTMODE FLAG
	MOV #ISTCKA,ISTACK	;INIT ITERATION STACK
	MOV SBSTRT,R4		;START OF SAVE BUFFER INTO R4
	SUB CBSTRT,R4		;TOTAL LENGTH OF CIB=CBSTRT-SBSTRT/2
	ASR R4			;DIVIDE BY 2
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
AST2:	IOT
	.BYTE	0,0		;CNTRL O
	.WORD	0		;RESET
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
AST2:	.RCTRLO			;ENABLE TTY IN CASE HE ^O 'D IT OUT
	MOV	DSA+4,R0	;GET ADDRESS OF 'BA'
	BEQ	2$		;IT ISN'T HERE
	ADD	#6,R0		;INDEX TO 'BATSW1'
	MOV	(R0),-(SP)	;SAVE IT FOR A SEC.
	BIT	#4,(SP)		;BATCH IN CONTROL?
	BEQ	1$		;NO
	MOV	(SP),BATSVE	;YES. SIGNAL SAME
	BIT	#40000,(R0)	;JOB STREAM CONTROL?
	BNE	1$		;YEP. LEAVE IT ALONE
	CLR	(R0)		;NOPE. ZAP BATCH CONTROL
1$:	TST	(SP)+		;PURGE STACK
2$:
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	MOV CBSTRT,R3		;R3 POINTS INTO COMMAND BUFFER
	MOVB #ASTRSK,R0		;FOLLOWED BY "*"
	JSR PC,TYPCHAR
AST17:
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
AST3:	IOT
	.BYTE	XREAD,KEYBRD	;READ FROM TTY
	+	TTINBUF
INW2:	BITB	#200,TTST	;WAIT FOR CHAR.
	BEQ	INW2
	MOVB	CHART,R0	;COLLECT CHAR.
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
AST3:	.TTYIN			;GET CHAR FROM TTY
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	CMPB R0,#RUBOUT		;IS CHAR RUBOUT
	BEQ AST12		;YES-GO TO RUBOUT PROCESSOR
	CMPB	#12,R0		;LF?
	BNE	AST16
	CMPB	#15,LASTC	;LAST THING IN A CR?
	BEQ	AST16	;YEP.
	MOV	#11,R0		;ELSE FAKE A HT
AST16:	CMPB #33,R0		;IS CHAR AN ALTMODE?
	BEQ AST5		;YES-CHECK FOR DOUBLE ALTMODE
	CMPB #175,R0		;CHECK FOR OBSOLETE TERMINAL ALTMODES
	BEQ AST5
	CMPB #176,R0
	BEQ AST5
	CLRB ALTFLG		;NO-CLEAR ALTMODE FLAG
	CMPB #CTRLU,R0		;CONTROL U?		**** D.S. 12/77
	BEQ CTRULP		;YES. DON'T ECHO IT	****
	JSR	PC,TYPCHAR	;ECHO THE CHARACTER
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	CMPB	#CR,R0		;CHAR. = <CR>?
	BNE	CHAREC		;NO
	JSR	PC,LFOUT	;YES: ECHO <LF> AFTER IT
	MOVB	#CR,R0		;RESTORE <CR>
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
CHAREC:
	CMPB	R0,#CTRLX	;WAS CHAR. CTRL X?
	BEQ AST101		;YES-FORGET EVERYTHING AND START OVER
	BR AST13		;NO. GO STORE THE CHARACTER.	****
CTRULP:	CMP R3,CBSTRT		;IS CIB EMPTY?
	BLOS AST101		;YES-START OVER
	MOVB -1(R3),R0		;GET THE PREVIOUS DATA.		****
	CMPB R0,#LF		;WAS CHAR WE BACKED OVER A LF?
	BEQ AST17		;YES. WE'RE DONE		****
	CMPB R0,#FF		;NO-SAME FOR FORM FEED
	BEQ AST17		;				****
	JSR PC,ROUT		;GO RUBOUT A CHARACTER		****
	BR CTRULP		;NEITHER-BACK UP AGAIN
AST13:	MOVB R0,(R3)+		;PUT CHAR IN CIB
	DEC R4			;DECREASE AVAILABLE SPACE COUNT
	BEQ AST11		;BUFFER FULL?
	.IFDF	$CAPS11		;>C>C>C>C>C>C.C.C.C.C
	CMPB	#CR,R0
	BNE	SZCHK
	MOVB	#LF,R0		;ON <CR>, ALSO INSERT <LF>
	BR	AST13
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
SZCHK:	CMP R4,#12		;NO-ARE WE WITHIN 10 CHARS OF END?
	BHI AST3		;NO-GET NEXT
	MOV	R3,-(SP)	;YES-PRINT WARNING
	MOV	#AST8,R3
	JSR	PC,EPRINT
	MOV	(SP)+,R3
	JMP	AST3

AST11:	ERROR+3			;CIB FULL


AST8:	.BYTE CR,LF
	.ASCII /* CB ALMOST FULL */
	.BYTE 15,12,0
	.EVEN
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
TTINBUF:.WORD	1	;BUFFSIZE
	.BYTE	202		;MODE: UNFORM. ASCII
TTST:	.BYTE	200		;STATUS
	.WORD	1		;COUNT
CHART:	.BYTE	0,0		;CHAR
	.ENDC			;<<<<<<<<<<<<<<<<<<<<


	;ALTMODE SEEN

AST5:	MOVB #33,R0		;ECHO $
	JSR PC,TYPCHAR
	TSTB ALTFLG		;WAS LAST CHAR ALTMODE?
	BNE AST4		;YES-END OF COMMAND
	INCB ALTFLG		;NO-SET ALTMODE FLAG
	MOVB R0,(R3)+		;PUT ALTMODE IN BUFFER
	BR AST3			;NEXT CHAR

AST4:	CLRB -(R3)		;PUT 0 AT END OF COMMAND
	INC R3
	CLRB (R3)		;WE NEED 2 ZEROES IN CASE LAST CMD IS TEXT CMD
	MOV R3,CBEND		;MARK END OF COMMAND BUFFER
	MOV CBSTRT,CBASE	;POINT TO MASTER COMMAND STRING
	JSR PC,CRLF		;ECHO CRLF FOR DOUBLE ALTMODES
	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
	TSTB	DSFLG		;IS DISPLAY BEING USED?
	BEQ	AST18		;NO - DON'T CHECK FOR IMMED. MODE
	TSTB	@CBSTRT		;IS CIB EMPTY?
	BNE	AST18		;NO - PROCESS COMMAND STRING
	INC	SCFLG		;NULL CIB - SET IMMEDIATE MODE
	MOVB	#'!,R0		;PRINT "!"
	JSR	PC,TYPCHAR	;TO INDICATE MODE
	JMP	SCOMND		;GET NEXT IMMEDIATE CHAR
AST18:
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	JMP COMAND		;EXECUTE COMMAND STRING


	.PAGE
	.SBTTL	RUBOUT PROCESSOR. INSTALLED 4/77 BY D. SHEPPERD
AST12:	CLRB	ALTFLG		;RUBOUT NOT ALTMODE
	CMP	R3,CBSTRT	;CIB EMPTY?
	BNE	1$		;NO
	JMP	AST101		;YES. IGNORE RUBOUT
1$:	JSR PC,ROUT		;GO RUBOUT A CHARACTER		****
	BR JMPAST
ROUT:	MOVB	-(R3),R0	;BACK UP
	CMPB	#37,R0		;ANYTHING LESS THAN A SPACE?
	BMI	2$		;NO. NORMAL PROCEDURE
	CMPB	#33,R0		;ESC?
	BNE	3$		;NO
2$:	JMP	NORMRO		;NORMAL RUBOUT STUFF
3$:	CMPB	R0,#11		;HT?
	BMI	UARO		;TWO BS'S FOR OTHER CONTROL
	BNE	AST15		;NOT HT
	MOVB	OTBNDX,R0	;HT FUNCTIONS
	DEC	R0
	BIC	#-8.,R0		;ROLL BACK HISTORY REGISTER
	MOVB	R0,OTBNDX
	MOVB	TABNDX(R0),-(SP)
	MOVB	(SP),E127$	;RESET TAB INDEX
	DECB	(SP)
6$:	.TTYOUT	#10		;PRINT BS
	DECB	(SP)		;LOOP UNTIL ALL DONE
	BPL	6$
	TST	(SP)+		;PRUNE STACK
	BR	CREXIT		;DONE
UARO:	.TTYOUT	#10		;BACKSPACE 2 TIMES (^X FUNCTIONS)
	.TTYOUT
	.TTYOUT	#40		;2 SPACES
	.TTYOUT
	.TTYOUT	#10		;2 MORE BS
	.TTYOUT
	BR	ROEXIT		;DONE
AST15:	CMPB	#12,R0		;LINE FEED?
	BNE	1$		;NOPE
	CLR	-(SP)		;STOP. 1 REVERSE LINE FEED
	BR	2$
1$:	CMPB	#14,R0		;FF?
	BNE	3$
	MOV	#7,-(SP)	;BACK UP 8 LINES
2$:	.TTYOUT	#13		;BACK CURSOR UP 1 LINES
	DEC	(SP)
	BPL	2$
	TST	(SP)+		;PRUNE STACK
	BR	CREXIT		;DON'T DO ANY TAB STUFF
3$:	CMPB	#15,R0		;CR?
	BNE	UARO		;MUST BE OTHER CONTROL FUNCTIONS
	MOV	#8.,E127$	;RESET TAB COUNTER
	MOV	R3,-(SP)	;SAVE CIB INDEX
7$:	CMP	R3,CBSTRT	;AT START OF CIB?
	BNE	8$		;NO.
	CMP	R3,(SP)		;ANY DATA SKIPPED?
	BEQ	6$		;NO.DONE
	MOV	#ASTRSK,R0
	JSR	PC,TYPCHAR	;PRINT A '*' TO SPACE CURSOR
	BR 9$
8$:	MOVB	-(R3),R0	;GET PREVIOUS BYTE
	CMPB	#LF,R0		;LF?
	BNE	5$		;NO
10$:	INC	R3		;UP ONE AGAIN
4$:	CMP	R3,(SP)		;ANY DATA SKIPPED?
	BPL	6$		;NO.DONE
9$:	MOVB	(R3)+,R0	;GET DATA
	JSR	PC,TYPCHAR	;PRINT IT
	BR	4$
5$:	CMPB	#14,R0		;FF?
	BEQ	10$		;YEP.SAME AS LF.
	BR	7$
6$:	MOV	(SP)+,R3	;RESTORE R3
	BR	CREXIT
ROEXIT:
	INC	E127$		;BUMP TAB INDEX BACK UP
	CMPB	#8.,E127$	;OVERFLOW?
	BPL	CREXIT		;NO
	MOV	#1,E127$	;YES. RESET IT TO 1.
CREXIT:	INC	R4		;MAKE ROOM
	RTS PC			;				****
JMPAST3: JMP	AST3
NORMRO:	.TTYOUT	#10		;BS
	.TTYOUT	#40		;SPACE (GOBBLE UP OLD DATA)
	.TTYOUT	#10
	BR	ROEXIT
	.SBTTL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;; SYSTEM SUBROUTINES ;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;SUBROUTINE TMODE
;REMEMBERS START OF OBJECT IN OBSTRT. SEARCHES FOR ALTMODE. RETURNS
;LENGTH OF TEXT OBJECT IN OBLENG. MOVES R1 TO POINT TO ALTMODE

TMODE:	INC CREL
	MOV CREL,R1
	ADD CBASE,R1		;R1 NOW POINTS TO ABS ADDR OF OBJECT
	MOV CREL,OBSTRT		;REMEMBER THIS START
	CLR R0			;ZERO LENGTH
E68$:	CMPB (R1),#33		;ALTMODE CHAR?
	BEQ E69$		;YES-END OF OBJECT
	CMPB (R1),#175		;TEST FOR ALL THREE POSSIBLE ALTMODE CODES
	BEQ E69$
	CMPB (R1),#176
	BEQ E69$
	TSTB (R1)+		;0 CAN ALSO END OBJECT IF LAST CMD IN STRING
	BEQ E69$
	INC CREL		;NO-BUMP POINTER
	INC R0			;BUMP LENGTH
	BR E68$			;LOOP
E69$:	MOV R0,OBLENG		;TEXT OBJECT LENGTH
	TSTB EPFLG		;ARE WE IN ERROR PASS?
	BNE T1			;YES-ERROR PASS DOES NOT AFFECT = ARG
	MOV R0,EQLENG		;REMEMBER IT FOR = ARGUMENT
T1:	RTS PC			;RETURN


;SUBROUTINE CHRARG
;INTERPRETS ARG AS # OF CHARS AND RETURNS WITH R4 POINTING
;TO REFERENCED ADR

CHRARG:	TSTB SLSFLG		;IS ARG="/"?
	BNE LCCOM1		;YES-SET ADR=CBSTST-1
	TST ARG			;ARG=0?
	BEQ LNTSLS		;YES-USE ROUTINE IN LINARG TO FIND
				;BEGINNING OF CURRENT LINE
CHR1:	MOV PTR,R4		;CURRENT POINTER INTO R4
	TSTB NEGFLG		;IS ARG<0?
	BNE CSUB		;YES-SUBTRACT ARG FROM PTR
	ADD ARG,R4		;ADD ARG TO PTR FOR ADR
	CMP R4,CBSTRT		;IS ADR PAST END?
	BHIS LCCOM1		;YES-EQUIV TO "/"
	RTS PC			;RETURN

CSUB:	SUB ARG,R4		;PTR-ARG=ADR
	CMP R4,PBSTRT		;ADR BEFORE BEG OF BUFFER?
	BHIS CHRET		;NO-RETURN
	MOV PBSTRT,R4		;YES-ADR = BEGINNING
CHRET:	RTS PC




;SUBROUTINE EMACEP
;ERROR PASS ROUTINE FOR EM COMMAND

EMACEP:	TSTB MINFLG		;ARE WE PROCESSING A MACRO?
	BEQ MACEPR		;NO-RETURN
ERM:	ERROR+6			;YES-ILLEGAL TO EXECUTE A MACRO FROM WITHIN A MACRO

;SUBROUTINE MACEP
;ERROR PASS ROUTINE FOR M COMMAND

MACEP:	TST ARG			;0M ?
	BEQ EMACEP		;YES, JUST CHECK FOR RECURSION
	INC R1			;POINT TO DELIMETER
	INC CREL
	MOVB (R1)+,DELIM	;STORE DELIMETER
	BEQ ERM			;END OF STRING MEANS DELIMETER ERROR
	JSR PC,EMACEP		;TEST FOR RECURSION PROBLEMS
	MOV ISTACK,TMP		;MARK CURRENT POSITION OF ITERATION STACK
	INCB MINFLG		;SET FLAG FOR MACRO PROCESSING
MACEPR:	RTS PC
;SUBROUTINE LINARG
;INTERPRETS ARG AS A LINE ARGUMENT,AND RETURNS WITH R4 POINTING
;TO IMPLIED ADR

LINARG:	TSTB SLSFLG		;IS ARG="/"
	BEQ LNTSLS		;NO
LCCOM1:	MOV CBSTRT,R4		;ADR IS END OF BUFFER
	RTS PC			;DONE

LNTSLS:	MOV PTR,R4		;CURRENT CHAR POSITION IN R4
	TST ARG			;IS ARG=0?
	BNE LTMIN		;NO-SEE IF <0
	MOV #1,R3		;YES-BACK OVER 1 CRLF
	BR LBLOOP

LTMIN:	TSTB NEGFLG		;IS IT <0?
	BEQ LFOR		;NO-MOVE FORWARD
	MOV ARG,R3		;YES-NUMBER OF CRLF'S IN R3
	INC R3			;BACK OVER ARG+1 CRLF
LBLOOP:	CMP R4,PBSTRT		;IS ADR PAST BEG OF BUFFER?
	BLOS LRET		;YES-SET ADR AT BEG
	CMPB -(R4),#LF		;NO-IS PREV CHAR LF?
	BNE LBLOOP		;NO-BACKUP
	CMPB -(R4),#CR		;YES-IS PREV CHAR CR?
	BNE LBLOOP		;NO-BACKUP
	DEC R3			;YES-DECREASE COUNT
	BNE LBLOOP		;MORE
	CMPB (R4)+,(R4)+	;DONE-MOVE OVER LAST CRLF
				;TO BEG OF NEXT LINE
LRET:	RTS PC

LFOR:	MOV ARG,R3		;NUMBER OF CRLF'S TO STEP OVER IN R3
LFLOOP:	CMP R4,CBSTRT		;ADR PAST END?
	BHIS LCCOM1		;YES-SET IT TO END
	CMPB (R4)+,#CR		;NEXT CHAR=CR?
	BNE LFLOOP		;NO
	CMPB (R4)+,#LF		;YES-CHAR AFTER THAT LF?
	BNE LFLOOP		;NO
	DEC R3			;YES-DECREASE COUNT
	BNE LFLOOP		;DONE?
	RTS PC			;YES


;SUBROUTINE SEARCH
;COMPARES TEXT OBJECT WITH PAGE BUFFER STARTING AT PTR.
;RETURNS TO CALL+1 IF MATCH FOUND,CALL+2 IF SEARCH FAILS.
;LEAVES POINTER AFTER LAST CHARACTER CHECKED. LOOKS FOR "ARG"
;NUMBER OF MATCHES BEFORE SUCCESS.

SNOHIT:	INC PTR			;MOVE POINTER FORWARD ONE AND SEARCH AGAIN
SEARCH:	MOV PTR,R4		;R4 POINTS TO DOT
	MOV OBSTRT,R3		;R3 POINTS TO OBJECT
	ADD CBASE,R3		;R3 NOW ABSOLUTE ADDR OF OBJECT
	MOV OBLENG,R2		;R2 CONTAINS OBJ LENGTH
SLOOP1:	CMP R4,CBSTRT		;END OF BUFFER?
	BHIS SFAIL		;YES-SEARCH FAILED
	CMPB (R4)+,(R3)+	;NO-DOES THIS CHAR MATCH?
	BNE SNOHIT		;NO
	DEC R2			;YES-MORE CHARS IN OBJECT TO MATCH?
	BEQ SMATCH		;NO-SEARCH SUCCESSFUL
	BR SLOOP1		;YES-CHECK THEM

SFAIL:	ADD #2,(SP)		;BUMP RETURN
	MOV R4,PTR		;SET PTR
	RTS PC			;RETURN

SMATCH:	MOV R4,PTR		;SET PTR
	DEC ARG			;MORE MATCHES TO FIND?
	BGT SEARCH		;YES-GET NEXT ONE
	RTS PC			;NO-DONE

;ROUTINES IOPCHK AND OOPCHK
;TESTS IF INPUT OR OUTPUT FILES OPEN

IOPCHK:	TSTB	INOFLG		;IS INPUT FILE OPEN?
IOPCOM:	BNE	IOPRET		;YES
	ERROR+14		;NO-ERROR
IOPRET:	RTS	PC
OOPCHK:	TSTB	OTOFLG
	BR	IOPCOM

;SUBROUTINE BLKEMT
;GETS CHARS FROM INPUT BUFFER, READING BLOCKS AS NECESSARY

BLKEMT:	TSTB	INOFLG		;IS THERE AN INPUT FILE OPEN?
	BNE	E41$		;YES
	ERROR+14		;"FILE NOT OPEN"
E41$:	TSTB	EOFFLG		;EOF SEEN YET?
	BEQ	E46$		;NO
EOFERR:	TSTB	SRCFLG		;YES-FILE SEARCH IN PROGRESS?
	BNE	E42$		;YES-SRCH FAIL MSG
	ERROR+7			;NO-"EOF"
E42$:	ERROR+5			;"SRCH FAIL"
E46$:	MOV	IBPTR,R2	;R2 POINTS INTO INPUT BUFFER
	INC	IBPTR		;BUMP INPUT POINTER
	MOVB	(R2)+,-(SP)	;SAVE NEXT CHAR ON STACK
	BIC	#177600,(SP)	;STRIP TO 7 BITS
	CMP	R2,#IBUFF2	;IS INPUT BUFFER 1 EMPTY?
	BNE	E43$		;NO-CHECK BUFF 2
	TSTB	EFFLG		;YES-HAS LAST BLOCK OF FILE BEEN READ?
	BEQ	E47$		;NO
E48$:	INCB	EOFFLG		;YES-SET END OF FILE FLAG FOR READ
	TST	(SP)+		;POP CHAR OFF STACK
	RTS	PC		;AND RETURN
E47$:	MOV	#IBUFF1,R2
	JSR	PC,BREAD	;READ NEXT BLOCK
	BR	E45$		;BACK TO CALLER
E43$:	CMP	R2,#IBEND	;IS BUFFER2 EMPTY
	BLO	E45$		;NO-RETURN
	TSTB	EFFLG		;YES-HAS LAST BLOCK BEEN READ?
	BNE	E48$		;YES-SET FLAG AND RETURN
	MOV	#IBUFF2,R2	;READ BLOCK 2
	JSR	PC,BREAD
	MOV	#IBUFF1,IBPTR	;RESET INPUT POINTER
E45$:	MOVB	(SP)+,R0	;CHAR INTO R0
	BEQ	E46$		;IGNORE NULLS
E44$:	CMPB	R0,#RUBOUT	;IS CHAR A RUBOUT?
	BEQ 	E46$		;YES-IGNORE IT
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	CMPB	R0,#CNTRLZ
	BNE	OUT01
	INCB	EFFLG
	INCB	EOFFLG
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
OUT01:	RTS	PC
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
BREAD:	JSR	PC,BUFZRO	;ZERO THE BUFFER BEFORE READING IT
	.WAIT 12		;WAIT FOR LAST BUFFER
	BCS 	2$		;WAS LAST READ AN ERROR?
	.READ 12,R2,#400,IBLKNM	;READ 1 BLOCK FROM INPUT FILE INTO BUFFER AT R2
	BCS	2$		;READ ERROR
1$:	INC	IBLKNM		;BUMP BLOCK NUMBER
	RTS	PC
2$:	TSTB	ERRWD		;HARDWARE ERROR?
	BEQ	E3$
	ERROR+10		;YES
E3$:	INCB EFFLG		;EOF-SET LAST BLOCK READ FLAG
	RTS	PC
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
BREAD:	JSR	PC,BUFZRO
	MOV	R2,RLBUFF	;ENTER BUFF. ADDR.
	MOV	#RLIST,R2
RTST:	IOT
	.BYTE	WAITR,0		;WAIT FOR CT I/O TO COMPLETE
	+	RTST
	TSTB	(R2)		;ERROR?
	BMI	RERR		;YES
	IOT
	.BYTE	XREAD
IDEV:	.BYTE	0		;DEVICE (INIT'D)
	.WORD	RLIST
	RTS	PC
;
RERR:	BITB	#50,(R2)	;FIL. GAP OR CLR. LDR.?
	BNE	EOFR		;YES: END OF FILE
	ERROR+10		;HARDWARE ERROR
EOFR:	INCB	EFFLG		;SET LAST BLK. READ FLAG
	RTS	PC
;
RLIST:	.BYTE	1		;ST/ERR MUST INIT T0 1
	.BYTE	0
RLBUFF:	.WORD	0		;BUFF. ADDR.
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
;SUBROUTINE BUFZRO
;CLEARS THE 256 WORD BUFFER WHOSE ADDRESS IS IN R2

BUFZRO:	MOV R2,-(SP)		;SAVE R2
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	MOV #400,R1		;COUNTER INTO R0
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	MOV	#64.,R1		;COUNTER
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
E70$:	CLR (R2)+		;ZERO LOCATION
	DEC R1			;DECREASE COUNT
	BGT E70$		;MORE TO GO
	MOV (SP)+,R2		;RESTORE R2
	RTS PC			;DONE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;; COMMAND SUBROUTINES  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;ADVANCE
;MOVES PTR TO IMPLIED ADR

ADVNCE:	JSR PC,LINARG		;ADVANCE IS A LINE COMMAND
AJCOM:	MOV R4,PTR		;SET PTR
	RTS PC			;RETURN

;JUMP
;MOVES POINTER TO IMPLIED ADR

JUMP:	JSR PC,CHRARG		;ARG IS A CHAR ARG
	BR AJCOM		;SET POINTER AND RETURN

;DELETE
;MOVES TEXT AFTER DELETE UP

DELETE:	JSR PC,CHRARG		;DELETE IS A CHAR COMMAND
DKCOM:	CMP PTR,R4		;IS ADR>PTR?
	BHIS E76$		;YES
	MOV R4,R2		;NO
	SUB PTR,R4		;GET # OF CHARS TO DELETE
	MOV R4,-(SP)		;SAVE # OF DELETED CHARS
	MOV PTR,R4		;SET UP DESTINATION
	BR E75$			;PREPARE MOVDWN
E76$:	MOV PTR,R2		
	SUB R4,R2		;GET # OF DELETED CHARS
	MOV R2,-(SP)		;SAVE THAT NUMBER
	MOV PTR,R2		;SET UP MOVE
E75$:	MOV CBEND,R3		;MOV PB AND CIB
	MOV R4,PTR		;SET NEW PTR
	JSR PC,MOVDWN		;DELETE TEXT
	SUB (SP),CBSTRT		;UPDATE NEW CIB POINTERS
	SUB (SP),CBEND
	TSTB MACFLG		;MACRO IN PROGRESS?
	BNE E74$		;YES
	SUB (SP),CBASE		;NO-ADJUST CS POINTER TO REFLECT CIB MOVE
E74$:	TST (SP)+		;CLEAN # OF CHARS OFF STACK
	RTS PC

;KILL
;SAME AS DELETE ONCE ADR IS DETERMINED

KILL:	JSR PC,LINARG		;KILL IS A LINE COMMAND
	BR DKCOM		;SAME AS DELETE
	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
;IMMEDIATE MODE COMMAND SUBROUTINES



;ALTM
;SINGLE ALTMODE - RETURNS TO COMMAND STRING MODE

ALTM:	CLRB	SCFLG		;SET IMMEDIATE MODE OFF
	MOVB	#'!,LASTC	;MAKE SURE CR-LF PRINTS
	JSR	PC,CRLF		;PRINT CR-LF
	TST	(SP)+		;POP OFF RETURN PC
	JMP	ASTER		;GET NEXT COMMAND STRING

	.ENDC			;<<<<<<<<<<<<<<<<<<<<
;LIST
;OUTPUTS CHARS BETWEEN PTR AND IMPLIED ADR TO TTY

LIST:	MOV TTY,OUTINS		;SET UP CALL TO TYPE FOR OUTPUT DEVICE
	MOV TTY+2,OUTINS+2
LWCOM:	JSR PC,LINARG		;ARG IS A LINE ARG
	CMP R4,PTR		;FORWARD OR BACKWARD?
	BLO E77$		;BACKWARD
	MOV R4,R3		;FORWARD
	MOV PTR,R4		;FINAL ADR IN R3
	BR L2
E77$:	MOV PTR,R3		;FINAL LIST CHAR IN R3
L2:	CMP R4,R3		;DONE?
	BEQ LDONE		;YES
	MOVB (R4)+,R0		;NO-SET UP CHAR
OUTINS:	.WORD 0			;CALL TO OUTPUT ROUTINE GOES HERE
	.WORD 0
	BR L2			;LOOP
LDONE:	RTS PC


;OUTPUT CALLS
TTY:	JSR PC,@#TYPCHAR
FILE:	JSR PC,@#BLKSTF


;VERIFY
;EQUIVALENT TO 0L,L

VERIFY:	CLR ARG			;SET ARG TO 0
	JSR PC,LIST		;DO A 0 L
	INC ARG			;SET ARG TO 1
	JSR PC,LIST		;DO LAST HALF OF LINE
	CLR ARG			;GOING TO DO ANOTHER 0L
	JSR PC,LINARG		;SET UP PTR'S
	CMP R4,PTR		;POINTER IN RIGHT SPACE?
	BEQ V1$			;YEP. DON'T PRINT UA
	INC	(PC)+		;SET VERIFY MODE
VFLG:	.WORD	0
	JSR	PC,E77$		;FAKE A 0L COMMAND
	CLR	VFLG		;RESET VERIFY MODE
3$:	.TTYOUT #'^		;PRINT UA
	JSR	PC,CRLF		;PRINT A CR LF
V1$:	RTS PC

;BEGIN
;SETS PTR TO START OF PAGE BUFFER

BEGIN:	MOV PBSTRT,PTR		;SELF-EXPLANATORY
	RTS PC

;WRITE
;SAME AS A LIST GOING TO FILE BUFFER INSTEAD OF TTY

WRITE:	TSTB OTOFLG		;IS THERE AN OUTPUT FILE OPEN?
	BNE E78$		;YES
	ERROR+14		;NO-NO FILE
E78$:	MOV FILE,OUTINS		;SET FILE STUFFING ROUTINE AS OUTPUT DEV
	MOV FILE+2,OUTINS+2
	BR LWCOM		;SAME AS LIST
;INSERT
;INSERT TEXT OBJECT AT PTR

INSERT:	JSR PC,TMODE		;GET OBJECT LENGTH
IUCOM:	MOV SBSTRT,R4		;START OF SAVE BUFFER IN R4
	SUB CBEND,R4		;SPACE AVAILABLE IS START OF SB-END OF CIB
	SUB #10,R4		;MUST LEAVE ROOM FOR EMERGENCY COMMAND STRING
	CMP OBLENG,R4		;COMPARE IT TO OBJECT LENGTH
	BLO E91$		;THERE IS ROOM
	ERROR+4			;"NO ROOM"
E91$:	MOV CBEND,R3		;INITIALIZE MOVE LIMITS
	ADD OBLENG,CBEND	;UPDATE CBEND
	MOV CBEND,R4		;INIT DEST FOR MOVUP
	MOV PTR,R2		;MAKE ROOM AT PTR
	JSR PC,MOVUP		;MAKE ROOM FOR INSERT
	ADD OBLENG,CBSTRT	;UPDATE START OF CIB
	TSTB MACFLG		;MACRO IN PROGRESS?
	BNE E92$		;YES
	ADD OBLENG,CBASE	;NO-UPDATE COMMAND POINTER
E92$:	MOV OBSTRT,R4		;R4 POINTS TO TOBJECT
	ADD CBASE,R4		;R4 POINTS TO ABSOLUTE ADDR OF OBJECT
E93$:	DEC OBLENG		;DEC COUNT
	BMI E94$		;FINISHED?
	MOVB (R4)+,(R3)+	;NO-INSERT CHAR
	BR E93$			;LOOP
E94$:	MOV R3,PTR		;YES-UPDATE POINTER
	RTS PC

;CHANGE
;EQUIVALENT TO A DELETE FOLLOWED BY AN INSERT

CHANGE:	JSR PC,DELETE
	BR INSERT

;EXCHANGE
;EQUIVALENT TO A KILL FOLLOWED BY INSERT

XCHNGE:	JSR PC,KILL
	BR INSERT


;GET
;SEARCHES CURRENT BUFFER-PRINTS ERROR IF NOT FOUND

GET:	JSR PC,TMODE		;GET SEARCH OBJECT
	JSR PC,SEARCH		;FIND IT
	RTS PC			;WE DID
	ERROR+5			;WE DIDN'T

;FIND
;SEARCHES CURRENT BUFFER. IF SEARCH FAILS,WRITES CURRENT BUFFER
;READS NEXT,AND TRIES AGAIN

FIND:	JSR PC,TMODE		;GET SEARCH OBJECT
	INCB SRCFLG		;SET FLAG SO EOF CAUSES SRCH ERROR
E79$:	JSR PC,SEARCH		;FIND OBJECT
	BR PSDONE		;SUCCESSFUL
	MOV ARG,-(SP)		;SAVE SEARCH ARGUMENT
	MOV #1,ARG		;WE WANT TO DO A 1N
	JSR PC,NEXT		;FAILED-GET IN NEXT PAGE
	MOV (SP)+,ARG		;RESTORE SEARCH ARG
	BR E79$			;AND TRY AGAIN

;POSITION
;SEARCHES CURRENT BUFFER. IF SEARCH FAILS,KILLS THIS BUFFER,READS NEXT,
;AND TRIES AGAIN.

POSITN:	JSR PC,TMODE		;GET TEXT OBJECT
	INCB SRCFLG		;SET FLAG SO EOF CAUSES SEARCH ERROR
E80$:	JSR PC,SEARCH		;FIND IT
	BR PSDONE		;SUCCESSFUL
	INCB SLSFLG		;FAILURE
	JSR PC,BEGIN		;PTR TO BEGINNING
	JSR PC,DELETE		;DO A /D
	JSR PC,READ		;GET NEXT
	BR E80$			;TRY AGAIN

PSDONE:	RTS PC			;SEARCH IS DONE

;NEXT
;EQUIVALENT TO B /W /D R

NEXT:	JSR PC,BEGIN		;DO A B
	INCB SLSFLG		;SET ARG="/"
	JSR PC,WRITE		;DO A /W
	JSR PC,DELETE		;DO A /D
	JSR PC,READ		;DO A R
	DEC	ARG
	BGT	NEXT
	RTS PC			;RETURN
;LEFT BRACKET (<)
;STORES COMMAND CHAR ADDRESS ON ITERATION STACK,FOLLOWED BY COUNT

LFTBRK:	CMP ISTACK,#ISTCKE	;STACK FULL?
	BGT E81$		;NO
	ERROR+0			;YES-"<>" ERROR
E81$:	MOV CREL,-(ISTACK)	;SAVE CURRENT CS POINTER ON ITERATION STK
	MOV ARG,-(ISTACK)	;SAVE COUNT
	RTS PC			;RETURN

;RIGHT BRACKET (>)
;CHECKS COUNT ON TOP OF ITERATION STACK
;IF ZERO,POPS ENTRY OFF STACK AND CONTINUES.
;IF NOT ZERO,MOVES ADR ON STACK INTO CREL

RGTBRK:	CMP ISTACK,#ISTCKA	;STACK EMPTY?
	BLO RGTB1		;NO
	ERROR+0			;YES-"<> ERROR"
RGTB1:	DEC (ISTACK)		;DECREASE ITERATION COUNT BY 1
	BLE E82$		;THIS LOOP DONE?
	MOV 2(ISTACK),CREL	;NO-RESET CREL TO START OF THIS LOOP
	RTS PC			;RETURN

E82$:	CMP (ISTACK)+,(ISTACK)+	;LOOP DONE-DELETE ITEM FROM STACK
	RTS PC


;EXECUTE MACRO
;SAVES CURRENT COMMAND STRING POINTER AND STARTS COMMAND LOOP
;WORKING ON MACRO BUFFER

EMACRO:	INCB MACFLG		;WE ARE STARTING A MACRO
	CMP MBSTRT,BEND		;IS MACRO BUFFER EMPTY?
	BLO E83$		;NO-GO AHEAD
	ERROR+6			;YES-MACRO ERROR
E83$:	MOV CREL,MACR1		;NO-SAVE CURRENT CS POINTER
	MOV MBSTRT,CBASE	;POINT COMMAND POINTER TO MACRO BUFFER
	MOV ARG,MACCNT		;SET UP MACRO COUNT
	TST (SP)+		;CLEAN OFF STACK BEFORE STARTING
				;NEW LINE.THIS IS CALLED VIA JSR BUT
				;DOES NO RTS.
	JMP COMAND		;EXECUTE MACRO COMMAND STRING
;SAVE
;MOVES CHARS FROM PTR THROUGH ADR INTO SAVE BUFFER

SAVE:	JSR PC,LINARG		;SAVE IS A LINE COMMAND
	SUB PTR,R4		;# OF CHARS TO SAVE
	MOV PTR,R3		;START MOVING AT POINTER
	MOV MBSTRT,R2
	SUB R4,R2		;R2 NOW POINTS TO START OF NEW SAVE BUFFER
	CMP R2,CBEND		;ENOUGH ROOM?
	BHI E85$		;YES
	ERROR+4			;"NO ROOM"
E85$:	MOV R2,SBSTRT		;SET NEW SBSTRT
E86$:	TST R4			;DONE?
	BLE E87$		;YES
	MOVB (R3)+,(R2)+	;SAVE CHAR
	DEC R4			;DECREASE COUNT
	BR E86$
E87$:	RTS PC			;FINISHED

;UNSAVE
;INSERTS SAVE BUFFER AT POINTER. IF 0U,ZEROES SAVE BUFFER

UNSAVE:	TST ARG			;IS ARG=0?
	BNE E88$		;NO
	MOV MBSTRT,SBSTRT	;YES-ZERO SAVE BUFFER
	RTS PC			;RETURN

E88$:	MOV #OBLENG,R4		;R4 POINTS TO OBJECT LENGTH
	MOV MBSTRT,(R4)
	SUB SBSTRT,(R4)+	;LENGTH OF SAVE BUFFER=OBJECT LENGTH
	MOV SBSTRT,(R4)		;START OF SAVE BUFFER IS START OF TEXT OBJECT
	SUB CBASE,(R4)		;OBSTART IS THE RELATIVE ADDR OFF THE MOVED CIB
	TSTB MACFLG		;MACRO IN PROGRESS?
	BNE E89$		;YES-INSERT WILL NOT ADD OBLONG TO CBASE
	SUB OBLENG,(R4)		;INSERT WILL ADD OBLENG TO CBASE AS PART OF NORMAL OPERATION
E89$:	JMP IUCOM		;DO AN INSERT,TREATING THE SAVE BUFFER
				;AS THE TEXT OBJECT
;READ
;INPUTS CHARS TO PAGE BUFFER UNTIL FF OR EOF IS SEEN,OR WE GET
;WITHIN 500 CHARS FROM END AND A CRLF IS SEEN

READ:	CLRB SRFLG		;CLEAR SUCCESSFUL READ FLAG
	JSR PC,IOPCHK		;MAKE SURE THERE IS AN INPUT FILE OPEN
	MOV CBSTRT,-(SP)	;SAVE CURRENT CIB START
	MOV (SP),R2
	MOV CBEND,R3
	MOV SBSTRT,R4		;SET UP MOVE TO OPEN UP PB
	DEC R4			;MOVE TO RIGHT BELOW SAVE BUFFER
	JSR PC,MOVUP		;MAKE ROOM FOR READ
	MOV R4,-(SP)		;SAVE NEW CIB START
	MOV CBSTRT,R4		;FIRST READ CHAR GOES INTO R4
E95$:	MOV (SP),R3		;LAST FREE SPOT IN R3
	SUB #12,R3		;LEAVE ROOM FOR EMERGENCY COMMAND STRING
	SUB R4,R3		;ANY ROOM LEFT?
	BHI E96$		;YES
	JSR PC,READRS		;NO-RESTORE BUFFER BEFORE REPORTING ERROR
	ERROR+4			;NO ROOM
E96$:	JSR PC,BLKEMT		;YES-GET CHAR FROM FILE
	TSTB EOFFLG		;IS IT END OF FILE?
	BNE E97$		;YES-EOF MEANS END OF READ
	MOVB R0,SRFLG		;MARK THIS READ A SUCCESSFUL
	MOVB R0,(R4)+		;PUT CHAR INTO BUFFER
	CMPB R0,#FF		;IS CHAR FF?
	BEQ E97$		;YES-READ IS OVER
	CMP #776,R3		;NO-ARE WE WITHIN 500 OF END?
	BLO E95$		;NO-READ NEXT CHAR
	CMPB R0,#LF		;YES-IS CHAR LF?
	BNE E95$		;NO-GET NEXT
	CMPB -2(R4),#CR		;YES-WAS LAST CR?
	BNE E95$		;NO-GET NEXT
				;YES-END READ

E97$:	JSR PC,READRS		;RESTORE BUFFERS
	TSTB MACFLG		;MACRO IN PROGRESS?
	BNE E98$		;YES
	ADD R4,CBASE		;NO-UPDATE CS POINTER
E98$:	TSTB SRFLG		;WAS THERE AT LEAST ONE CHAR IN THIS READ?
	BNE E99$		;YES-RETURN
	TSTB EXFLG		;EXIT IN PROGRESS?
	BNE E99$		;YES-DON'T REPORT THE ERROR
	JMP EOFERR		;NO-EOF ERROR;SRCH FAIL IF SEARCHING
E99$:	RTS PC

READRS:	MOV (SP)+,R0		;SAVE RETURN ADDR IN R0
	MOV SBSTRT,R3
	DEC R3			;MOVE FROM RIGHT BELOW SAVE BUFFER
	MOV (SP)+,R2		;SET UP MOVE DOWN
	MOV R4,-(SP)		;SAVE NEW CIB STRT
	JSR PC,MOVDWN		;SLIDE CIB BACK DOWN
	MOV (SP)+,R4
	SUB (SP)+,R4		;GET # OF CHARS READ
	ADD R4,CBSTRT
	ADD R4,CBEND		;UPDATE CIB POINTERS
	MOV R0,PC		;RETURN
;MACRO
;PUTS COMMAND MACRO INTO MACRO BUFFER
;0M EMPTIES MACRO BUFFER

MACRO:	TST ARG			;IS IT 0M?
	BNE E102$		;NO-INSERT MACRO
	MOV BEND,R4
	MOV SBSTRT,R2
	MOV MBSTRT,R3
	JSR PC,MOVUP		;YES-SLIDE SAVE BUFFER UP TO END OF CORE
	MOV R4,SBSTRT
	MOV BEND,MBSTRT		;MACRO BUFFER NOW LOGICALLY EMPTY
	RTS PC

E102$:	MOV SBSTRT,R2
	MOV MBSTRT,R3
	MOV CBEND,R4
	JSR PC,MOVDWN		;SLIDE SB DOWN,MAKING ROOM FOR INSERT
	MOV BEND,TMP
	SUB R4,TMP		;MAX # OF CHARS ALLOWED IN MACRO
	SUB #10,TMP		;MUST LEAVE ROOM FOR EMERGENCY COMMAND STRING
	CLR R2			;ZERO COUNT OF MACRO CHARS
	INC R1			;R1 NOW POINTS TO DELIMITER
	MOVB (R1)+,R3		;R3 HOLDS DELIMETER CHAR
	ADD #2,CREL
E103$:	CMPB (R1),R3		;FIND SECOND DELIMETER
	BEQ E106$		;FOUND IT
	INC R2			;NOT FOUND-INCREMENT MACRO CHAR COUNT
	TSTB (R1)+		;END OF STRING?
	BEQ E104$		;YES-DELIMITER ERROR
	INC CREL		;NO-BUMP POINTER
	BR E103$
E104$:	JSR PC,E105$		;RESORE SAVE BUFFER BEFORE REPORTING ERROR
	ERROR+6			;NO-DELIMETERS DON'T MATCH

E106$:	CMP R2,TMP		;IS THERE ENOUGH ROOM FOR THIS MACRO?
	BLO E107$		;THERE IS
	JSR PC,E105$		;RESTORE SAVE BUFFER BEFORE REPORTING ERROR
	ERROR+4			;NO ROOM
E107$:	MOV BEND,R3		;R3 POINTS TO END OF MACRO BUFFER
	CLRB (R3)		;LAST BYTE OF MACRO MUST BE 0
E108$:	TST R2			;DONE?
	BEQ E109$		;YES
	MOVB -(R1),-(R3)	;NO-PUT CHAR IN MACRO BUFF (FROM RIGHT TO LEFT)
	DEC R2			;DECREASE COUNT
	BR E108$

E105$:	MOV BEND,R3		;ON ERROR,ZERO MACRO BUFFER
E109$:	MOV R3,MBSTRT		;START OF MBUFF
	CMPB -(R4),-(R4)	;SUBTRACT 2 FROM R4
	MOV R4,R3
	MOV CBEND,R2
	MOV MBSTRT,R4		;MOVE SAVE BUFFER UP AGAINST MACRO BUFFER
	DEC R4			;LAST LOC OF MOVE IS MBSTRT-1
	JSR PC,MOVUP
	MOV R4,SBSTRT		;SET START OF SB
	RTS PC
;SUBROUTINE FNGET
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
;CALLS CSI IN SPECIAL MODE TO CONVERT TEXT OBJECT INTO
;RAD50 FILE DESCRIPTOR

FNGET:	MOV R0,-(SP)		;SAVE R0 (IT WILL BE DESTROYED BY TMODE)
	MOV	#CSIBLK,R2	;R2 -> WORK AREA FOR CSI
	MOV	#CSISTR,R3	;R3 -> INPUT STRING AREA
	JSR PC,TMODE		;ISOLATE TEXT OBJECT
	CMP OBLENG,#23		;FILE DESCRIPTOR MORE THAN 19 CHARS?
	BGT E55$		;YES-ERROR
	MOV OBSTRT,R4		;RELATIVE START OF TEXT STRING
	ADD CBASE,R4		;MAKE IT ABSOLUTE
	MOV R3,-(SP)		;SAVE ADDRES OF CSI AREA
E56$:	DEC OBLENG		;MORE CHARS IN NAME?
	BLT E57$		;NO
	MOVB (R4)+,(R3)+	;COPY NAME INTO CSI AREA
	BR E56$
E57$:	MOVB #LBRCKT,(R3)+	;END WITH "<"
	CLRB (R3)+
	MOV (SP)+,R3
	.CSISPC R2,#DEFEXT,R3	;SPECIAL MODE CSI
	BCC E53$		;IF ERROR,NAME MUST BE ILLEGAL
E55$:	ERROR+16		;ILLEGAL NAME
E53$:	TST (SP)+		;MAKE SURE THERE WERE NO SWITCHES
	BNE E55$		;THERE WERE
	MOV #4,R3		;DESCRIPTOR IS 4 WORDS LONG
	MOV (SP)+,R0		;RESTORE ADDRESS OF FILE BLOCK
E54$:	MOV (R2)+,(R0)+		;PUT DESCRIPTOR IN NAME BLOCK
	DEC R3			;DONE?
	BGT E54$		;NO
	MOV (R2)+,FILENG	;REMEMBER LENGTH FOR ENTER
	RTS PC			;YES-RETURN

	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
FNGET:	CLRB	@DEVPTR		;DFLT. DEV. = CT0
	CLR	(PC)+		;SHOW NO DEV. YET
DFLG:	0			;DEVICE FLAG
	MOV	R0,-(SP)	;SAVE NAME PTR
	JSR	PC,TMODE	;ISOLATE TEXT OBJECT
	CMP	OBLENG,#14.	;14 CHARS. MAX.
	BGT	ILLNMER
	MOV	OBSTRT,R4	;REL. TEXT STR. ST.
	ADD	CBASE,R4	;NOW, ABSOL.
	MOV	R4,(PC)+	;SAVE STR PTR
STRPTR:	.WORD	0		;STRING	PTR.
TRYNM:	MOV	(SP),R0		;
;
; --GETNAME
;
	MOV	PC,R3		;EXTEN. FLAG - NOW ON NAME
	MOV	#3,R2		;NAME CNT. = 6
DOEXT:	ADD	#3,R2		;EXTEN. CNT. = 6
MORE:	JSR	PC,CHKC		;CHK. CHAR
	BPL	NONALNM		;NOT ALPHANUM.
	DEC	R2
	BLT	EXITA2		;CHA. AFTER CNT OF 0 ILL.
	MOVB	R1,(R0)+	;INSERT CHAR. OF NAME
	BR	MORE
NONALNM:CMP	#6,R2		;NON ALPHA-NUM. CAN'T
	BEQ	MRKNULL		;  BE FIRST
	TST	R2
	BR	CHKPAD		;SEE IF NEC. TO PAD. W/ SPACES
PADSP:	MOVB	#SPACE,(R0)+
	DEC	R2
CHKPAD:	BNE	PADSP
	CMPB	R1,#SPACE	;WAS NON- A/H CHAR. SPACE?
	BNE	NOTSP		;NO
	TST	R3		;EXTENSION?
	BEQ	EXITA1		;IT'S DONE: ET OUT
	CMPB	(R4)+,#'.	;'.'AFTER SP.?
	BNE	MRKNULL		;MAKE NULL EXT. AND LEAVE
	MOV	R4,R2		;CURR. CHAR. PTER. - WANT TO
	SUB	(SP),R2		;  GET CHARS. FROM HERE TO ST. O
	SUB	#7,R2		;  NAME. IF .LT. 6 CHARS.
	BLE	MRKDOT		;  BEFORE '.', GOOD NAME
	BR	MRKNULL
;
NOTSP:	TST	R3		;EXT. DONE?
	BEQ	EXITA0		;YES: PT. AT NEXT CHAR.
	CMPB	R1,#'.		;WAS IT '.'?
	BNE	MRKNULL		;BACK W/ PTR. AT ILL. CHAR.
MRKDOT:	CLR	R3		;SHOW GOING TO DO EXT.
	BR	DOEXT
EXITA2:	TST	R3		;ON ILL. CHAR. W/ NO EXT.
	BEQ	EXITA0		;  SEEN CLR 1ST EXT.BYTE
MRKNULL:CLRB	(R0)+		;MARK NULL NAME OR EXT.
EXITA0:	DEC	R4		;PT. TO 1ST NON-BLANK CHAR.
EXITA1:	MOV	(SP),R0		;ST-OF NAME
	JSR	PC,CHKC		;CHK. THAT CHAR.
	BCS	DODEV		;COLON
	BVC	ILLNMER		;NOT ALTMODE SO, ERROR
	TSTB	(R0)		;NAME NULL?
	BEQ	ILLNMER		;YES: ILL.
	TSTB	6(R0)		;EXT NULL?
	BNE	EXIT10		;NO
	MOV	#"PA,6(R0)	;INSERT DFLT. EXT.
	MOVB	#'L,8.(R0)
EXIT10:	CMPB	IDEV,ODEV
	BNE	OUT
	CMP	#INBLK,R0	;INPUT NOW?
	BEQ	INCHK		;YES
	CLRB	INOFLG		;NO: CANCEL INPUT
	BR	OUT
CNFLCT:	ERROR+17		;I/O CHAN CONFLICT
INCHK:	TSTB	OTOFLG
	BNE	CNFLCT
OUT:	TST	(SP)+
	RTS	PC
;
; --DODEV
;
DODEV:	TST	DFLG		;BEEN HERE BEFRE?
	BNE	ILLNMER		;YES: CAN'T DO DEV. TWICE
	INC	DFLG		;SHOW DEVICE SEEN
	MOV	STRPTR,R4	;PTR. TO ST. OF STRING
	MOV	#-2,R3		;
GETDN:	CLR	R2		;WILL ACCUM. CHARS.
	INC	R3		;ONLY GO THRU GETDN TWICE
	BGT	ILLNMER
SECHAR:	MOVB	(R4)+,R1	;GET CHAR
	BIS	R1,R2
	SWAB	R2
	BEQ	SECHAR		;GET 2 CHARS.
	CMP	R2,#"CT
	BEQ	GETDN		;NOW GET NUM
	CMP	R2,#"0:		;DEV. = 0?
	BEQ	TRYNM		;YES
	INCB	@DEVPTR		;MAKE UNIT #1
	CMP	R2,#"1:		;UNIT #1?
	BEQ	TRYNM
ILLNMER:ERROR+16		;ILL. NAME ERROR
;
; CHKC - CHECK CHAR.
;
CHKC:	MOV	#10,-(SP)	;WILL BE PS
	MOVB	(R4)+,R1
	BEQ	ALTOUT
	CMPB	#33,R1		;ANY ALTMODE FINISHES THINGS
	BEQ	ALTOUT
	CMPB	#175,R1
	BEQ	ALTOUT
	CMPB	#176,R1
	BEQ	ALTOUT
	CMPB	#'0,R1
	BGT	ERR
	CMPB	#72,R1
	BEQ	COLOUT
	BGT	AN
	CMPB	#'A,R1
	BGT	ERR
	CMPB	#'Z,R1
	BGE	AN
ERR:	ASR	(SP)		;4 SHIFTS='CCC'
COLOUT:	ASR	(SP)		;3 SHIFTS='SEC'
ALTOUT:	ASR	(SP)		;2 SHIFTS='SEV'
	ASR	(SP)
AN:	MOV	(SP)+,@#PS	;NEW STATUS
	RTS	PC
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
;EDIT VERSION
;TYPES VERSION # AND CREATION DATE ON TTY

EVERS:	JSR PC,CRLF
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	.PRINT #VMSG
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	MOV	R3,-(SP)
	MOV	#VMSG,R3
	JSR	PC,EPRINT
	MOV	(SP)+,R3
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	RTS PC			;TYPE THE MESSAGE AND RETURN

VMSG:	.ASCII	!V02-13 !
	.BYTE	0
	.EVEN

	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
;EDIT LOWER
;ENABLES UPPER/LOWER CASE EDITING BY SETTING UPPER/LOWER CASE BIT IN JSW

ELOWER:	BIS	#ULCASE,@#JOBSTAT ;SET UL CASE BIT IN JSW (BIT 14)
	RTS	PC

;EDIT UPPER
;SETS EDITING TO UPPER CASE ONLY BY CLEARING UPPER/LOWER CASE BIT IN JSW

EUPPER:	BIC	#ULCASE,@#JOBSTAT ;TURN OFF UL CASE
	RTS	PC
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
;START ROUTINE
;CALCULATES HOW MUCH CORE IS AVAILABLE  ,SETS THE TOP,THEN ASKS
;FOR FIRST COMMAND.

	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	.MCALL	.DSTAT
RESTRT:	BR	JAST10
START:	MOV	EDSTRT,SP	;STACK START
	MOV	#ERRORT,@#TRAPV	;SET UP TRAP VECTOR
	CLR	@#TRAPV+2
	MOV #NEGFLG,R0
1$:	CLR (R0)+		;LOOP TO INITIALIZE ALL FLAGS TO 0
	CMP R0,#EQLENG
	BLOS 1$			;BRANCH IF NOT DONE
	MOV #177776,R0		;WANT ALL WE CAN GET
	.SETTOP
	CMP	R0,#EDEND+1000	;NEED THIS MUCH
	BHI	E117$		;BR IF WE GOT IT
	.PRINT	#OVLFLO		;NOT ENOUGH
	MOV	@#RMONTP,R0	;GET RMON ADDRESS
	MOVB	#200,MONCOM(R0)	;SET HARD I/O ERROR
	JMP	RETMON		;DO SPECIAL EXIT
OVLFLO:	.ASCIZ	/?NOT ENUF CORE?/
E117$:	MOV	#USRSWP,@#USRADD ;USR SWAPS HERE
	MOV	#BEND,R1	;DYNAMIC PTRS START ADDR
	MOV	R0,(R1)+	;SET BEND
	MOV	R0,(R1)+	;SET MBSTRT
	MOV	R0,(R1)+	;SET SBSTRT
	TST	(R1)+		;SKIP CBEND
	MOV	EDTOP,R0	;TOP OF EDITOR
	MOV	R0,(R1)+	;SET CBSTRT
	MOV	R0,(R1)		;SET PBSTRT
	MOV	R0,PTR		;SET PTR
	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
	TST	CBEND		;FIRST TIME THROUGH
	BNE	2$		;NO,  SKIP
	INCB	FTFLG		;SET FIRST TIME SW
2$:	CMP	EDSPLY,ICERR	;CAN'T USE ED
	BEQ	NDSP		;THEN FORGET DISPLAY INIT
	JSR	PC,DREST	;FIX TYPCHAR FOR RESTARTS
	.UNLNK			;TRY UNLINK IN CASE OF RESTART
	.LNKRT			;LINK TO MONITOR
	BMI	NDSP		;CAN'T LINK - NOW
	BCC	1$		;SCROLLER NOT ACTIVE?
	.UNLNK			;IT'S NOT, FORGET DISPLAY
	BR	NDSP		;CONTINUE INIT
1$:	INCB	DSFLG		;YES - LET'S USE DISPLAY
	JSR	PC,INDSP	;INIT DISPLAY
NDSP:
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	BIS	#30000,@#JOBSTAT ;JOB RESTARTABLE, TTY SELF SERVICE MODE
	.QSET	#IOQ,#3		;INIT I/O Q FOR 3 ENTRIES
	CLR	BATSVE		;START WITH BATCH OUT OF CONTROL
	.DSTAT	#DSA,#BA	;GET STATUS OF 'BA'
	JMP ASTER		;GET FIRST COMMAND

JAST10:	BIS	#30000,@#JOBSTAT
	MOV	EDSTRT,SP	;RESET STACK
	JMP	AST101		;RESTART INCASE OF ^C
	.ENDC			;<<<<CAPS NDF

	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
;EDIT DISPLAY
;SETS UP DISPLAY ROUTINES IF DISPLAY IS AVAILABLE

EDSPLY:	TSTB	DSFLG		;ARE WE CURRENTLY USING DSPLY?
	BNE	2$		;YES - RETURN
	.LNKRT			;LINK TO MONITOR
	TST	R0		;IS DSPLY THERE?
	BMI	3$		;NO - ERROR
	INCB	DSFLG		;SET DSPLAY FLAG ON
	JSR	PC,INDSP	;INIT DISPLAY
	JSR	PC,DUPDAT	;REFRESH DISPLAY
2$:	RTS	PC		;RETURN
3$:	ERROR+12		;ILLEGAL DEVICE


;EDIT CONSOLE
;DISABLES DISPLAY FUNCTIONS IF ACTIVE AND USES TTY AS OUTPUT DEVICE

ECONS:	TSTB	DSFLG		;CURRENTLY USING DISPLAY?
	BEQ	1$		;NO - IGNORE CMD AND RETURN
	.UNLNK			;UNLINK FROM MONITOR
	JSR	PC,DREST	;FIX TYPCHAR FOR TTY
	CLRB	DSFLG		;MARK DISPLAY GONE
1$:	RTS	PC		;RETURN

SCBUF:	.WORD	4		;NUMBER OF LINES
	.WORD	140		;CHANGE IN Y POS.

;
; SUBROUTINE TO INITIALIZE DISPLAY FUNCTIONS
;
INDSP:	.CLEAR			;INIT DISPLAY HANDLER
	MOV	#DBUFR,DPTR	;INIT DISPLAY FILE
	CLR	DARG		;WITH AN IMMEDIATE
	JSR	PC,DCALL	;DISPLAY RETURN.
G1:	JSR	PC,TSTSCP	;TEST FOR SCOPE SIZE
	.SCROL	#SCBUF		;ADJUST SCROLLER PARMS
	.INSRT	#DSFILE		;INSERT DISPLAY FILE
	.TTYOUT	#LF		;PRINT LF TO CLEAR SCROLLER
	RTS	PC		;RETURN

;
; SUBROUTINE TO UPDATE THE DISPLAY BUFFER
;
DUPDAT:	.STOP			;STOP FILE TO WORK ON IT
	MOV	#DBUFR,DPTR	;POINT TO DISPLAY BUFR
	MOV	DSPLY,E120$	;SET UP TO DIVERT TTY
	MOV	DSPLY+2,E120$+2 ;OUTPUT TO DISPLAY BUFR
	MOV	DSPLY,E122$
	MOV	DSPLY+2,E122$+2
	MOV	DSPLY,E128$
	MOV	DSPLY+2,E128$+2
	MOV	TTY,OUTINS	;SET UP LWCOM CODE
	MOV	TTY+2,OUTINS+2	;TO USE TYPCHAR ROUTINE
	MOV	#10,E127$	;RESET TAB COUNTER
	CLRB	SLSFLG		;CLEAR "/" SEEN FOR LIST CMD
	MOV	DSARG,ARG	;PREPARE TO SIMULATE
	INCB	NEGFLG		;A MINUS 
	JSR	PC,LWCOM	;L COMMAND
	MOV	#CUR1,R1	;SETUP CURSOR ADJUSTMENT
	MOV	#100,R2		;BIT MASK FOR VECTOR WORD
	CMP	#15,R0		;LAST CHAR OUT A CR?
	BEQ	1$		;YES - MINUS CURSOR
	BIC	R2,(R1)+	; POSITIVE CURSOR
				;CLEAR MISVY IN FIRST VECT WORD
1$:	BIS	R2,(R1)+	;SET MISVY (MINUS CURSOR) 
	BIC	R2,(R1)		;CLEAR MISVY
	MOV	#CURSOR,DARG	;INSERT CALL TO CURSOR
	JSR	PC,DCALL	;INTO DISPLAY BUFR.
	MOV	DSARG,ARG	;PREPARE TO SIMULATE
	CLRB	NEGFLG		;A PLUS
	JSR	PC,LWCOM	;L COMMAND.
	CLR	DARG		;INSERT A DRET 0
	JSR	PC,DCALL	;INTO DISPLAY BUFR.
	JSR	PC,DREST	;RESTORE TYPCHAR TO TTYOUT
	.START			;START DISPLAY
	RTS	PC
DREST:	MOV	TTYOUT,E120$	;RESTORE .TTYOUT TO
	MOV	TTYOUT+2,E120$+2 ;TYPCHAR ROUTINE
	MOV	TTYOUT,E122$
	MOV	TTYOUT+2,E122$+2
	MOV	TTYOUT,E128$
	MOV	TTYOUT+2,E128$+2
	RTS	PC
;
; SUBROUTINE TO INSERT A CHARACTER INTO DISPLAY BUFFER.
;
DINSRT:	CMP	DPTR,#DBUFE	;PAST BUFFER END?
	BHIS	1$		;YES, GO EXIT
	MOVB	R0,@DPTR	;NO, INSERT THE CHAR.
	INC	DPTR		;AND BUMP POINTER.
1$:	RTS	PC
;
; SUBROUTINE TO INSERT A DISPLAY SUBROUTINE CALL INTO DISPLAY FILE
;
DCALL:	BIT	#1,DPTR		;WORD BOUNDARY?
	BEQ	1$		;YES
	CLR	R0		;NO, INSERT A NULL
	JSR	PC,DINSRT	;TO ALIGN POINTER
1$:	CMP	DPTR,#DBUFE-3	;ROOM IN BUFFER FOR CALL?
	BHIS	2$		;NO - EXIT
	MOV	#DJSR,@DPTR	;NOW INSERT A CALL
	ADD	#2,DPTR		;BUMP THE POINTER
	MOV	DARG,@DPTR	;INSERT SUBR. ADDRESS
	ADD	#2,DPTR		;BUMP POINTER
2$:	RTS	PC
;
DARG:	.WORD	0		;ADDR. OF DISPLAY SUBR
DPTR:	.WORD	DBUFR		;INIT POINTER TO DBUFR
DSPLY:	JSR	PC,@#DINSRT	;CALL TO A ROUTINE TO
				;INSERT ACHAR. INTO DISPLAY BUFR.
TTYOUT:	.TTYOUT			;TTYOUT CODE FOR SETUP
DSARG:	.WORD	12		;LINE ARG. FOR L COMD.
	.ENDC			;<<<<<<NODISP
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
;SUBROUTINE FETCH
;LOADS DEVICE HANDLER INTO CORE IF NOT THERE ALREADY
;EXPECTS R2 TO POINT TO FILE DESCRIPTOR BLOCK

FETCH:	.DSTATUS #CORADD,R2	;GET INFO ON HANDLER
	BCC	2$		;BRANCH IF NO ERROR
1$:	ERROR+12		;ILLEGAL DEVICE
2$:	TST	CORADD+4	;ALREADY RESIDENT?
	BNE	FETCHR		;YES - RETURN
	INC	CORADD+2	;MAKE SURE IT FITS
	MOV	CORADD+2,R4	;GET HANDLER SIZE
	MOV	SBSTRT,R3	;FREE AREA TOP
	SUB	CBEND,R3	;MINUS BOTTOM
	SUB	#10,R3		;LESS EMERGENCY CMD SPACE
	CMP	R4,R3		;IS HNDLR SMALLER THAN AVAILABLE?
	BLOS	3$		;YES - GO INSERT IT
	ERROR+4			;'N O  R O O M'
3$:	TST	HAND1N		;AREA 1 IN USE?
	BNE	5$		;YES - USE AREA 2
	MOV	R2,R0		;SAVE R2
	JSR	PC,SETUP1	;SET UP PARMS FOR MOVE
	JSR	PC,MUP		;MOVE PB AND CIB TO MAKE HOLE
	MOV	R0,R2		;RESTORE R2
	.FETCH	EDTOP,R2	;GET THE HANDLER INTO HOLE
	BCC	4$		;BRANCH IF NO ERROR
	JSR	PC,CLOSE1	;CLOSE AREA 1 HOLE
	ERROR+12		;ILLEGAL DEVICE
4$:	MOV	(R2),HAND1N	;REMEMBER THE DEVICE NAME IN AREA 1
	BR	FETCHR		;EXIT
5$:	MOV	R2,R0		;SAVE R2
	NEG	R4		;SET TO DECREASE PTRS
	JSR	PC,SETUP2	;SET UP PARMS FOR MOVE DOWN
	JSR	PC,MDWN		;MOVE SB AND MB DOWN TO MAKE HOLE
	MOV	BEND,R3		;GET ADDRESS OF HOLE BOTTOM
	INC	R3		;MAKE IT WORD BOUNDARY
	BIC	#1,R3		;ADDRESS TO LOAD HANDLER
	MOV	R0,R2		;RESTORE R2
	.FETCH	R3,R2		;GET HANDLER
	BCC	6$		;BRANCH IF NO ERROR
	JSR	PC,CLOSE2	;CLOSE AREA 2 HOLE
	ERROR+12		;ILLEGAL DEVICE
6$:	MOV	(R2),HAND2N	;REMEMBER DEVICE NAME IN AREA 2
	BR	FETCHR		;EXIT

UNSET1:	MOV	CORADD+2,R4	;GET HANDLER (HOLE) SIZE
	NEG	R4		;SET TO DECREASE PTRS
SETUP1:	MOV	PBSTRT,R2	;BOTTOM ADDR OF AREA TO BE MOVED
	ADD	R4,PBSTRT	;UPDATE BOTTOM ADDR
	ADD	R4,CBSTRT	;UPDATE CIB ADDR
	ADD	R4,PTR		;UPDATE CIB PTR
	TSTB	MACFLG		;ARE WE IN A MACRO?
	BNE	1$		;YES - CONTINUE
	ADD	R4,CBASE	;UPDATE CMD STRING PTR
1$:	MOV	CBEND,R3	;TOP ADDR OF AREA TO BE MOVED
	ADD	R4,CBEND	;UPDATE TOP ADDR
	RTS	PC		;RETURN


UNSET2:	MOV	CORADD+2,R4	;GET HANDLER (HOLE) SIZE
SETUP2:	MOV	SBSTRT,R2	;BOTTOM ADDR OF AREA TO BE MOVED
	ADD	R4,SBSTRT	;UPDATE BOTTOM ADDR
	MOV	BEND,R3		;TOP ADDR OF AREA TO BE MOVED
	ADD	R4,BEND		;UPDATE TOP ADDR
	ADD	R4,MBSTRT	;UPDATE MB START
	TSTB	MACFLG		;ARE WE IN A MACRO
	BEQ	1$		;NO - CONTINUE
	ADD	R4,CBASE	;UPDATE MB PTR
1$:	RTS	PC		;RETURN

CLOSE1:	JSR	PC,UNSET1	;SETUP TO ELIMINATE HOLE 1
MDWN:	ADD	R2,R4		;MOVE DESTINATION
	JMP	MOVDWN		;CLOSE IT AND RETURN

CLOSE2:	JSR	PC,UNSET2	;SETUP TO ELIMINATE HOLE 2
MUP:	ADD	R3,R4		;MOVE DESTINATION
	JMP	MOVUP		;CLOSE IT AND RETURN


;SUBROUTINE MOVUP
;MOVES THE BYTES FROM R2 THROUGH R3 TO HIGHER CORE,WORKING DOWN.
;STARTS AT R3,WORKS TO R2. HIGHEST ADDR OF MOVE IS IN R4

MOVUP:	INC R3			;BACK UP IN PREPARING FOR DECREMENT
	INC R4			;DITTO
E65$:	CMP R3,R2		;DONE?
	BLOS E66$		;YES-RETURN
	MOVB -(R3),-(R4)	;NO-MOVE CHARACTER
	BR E65$			;AND LOOP
E66$:	RTS PC

;SUBROUTINE MOVDWN
;MOVES THE BYTES FROM R2 THROUGH R3 TO LOWER CORE,WORKING UP
;STARTS AT R2,WORKING UP TO R3. LOWEST ADDR OF MOVE IS IN R4

MOVDWN:	CMP R2,R3		;DONE?
	BHI E67$		;YES-RETURN
	MOVB (R2)+,(R4)+	;NO-MOVE THE CHARACTER
	BR MOVDWN		;LOOP
E67$:	RTS PC

FETCHR:	RTS PC

;SUBROUTINE RELEAS
;RELEASES HANDLER IF NO LONGER NEEDED
;R2 POINTS TO HANDLER NAME


RELEAS:	.DSTATUS #CORADD,#INBLK	;FIND OUT WHAT INPUT DEVICE IS
	MOV CORADD,-(SP)	;REMEMBER IT
	.DSTATUS #CORADD,#OUTBLK;FIND OUT WHAT OUTPUT DEVICE IS
	CMP CORADD,(SP)+	;ARE THEY THE SANE
	BEQ 1$			;YES - CAN'T RELEASE HANDLER
	.DSTATUS #CORADD,R2	;GET LENGTH OF HANDLER
	INC CORADD+2		;ACCOUNT FOR BOUNDARY ROUNDUP
	CMP (R2),HAND1N		;IS THIS HANDLER IN AREA 1?
	BNE 2$			;NO-TRY AREA 2
	CLR HAND1N		;YES-MARK AREA 1 FREE
	.RELEAS R2		;RELEASE HANDLER
	JSR PC,CLOSE1		;RECLAIM HANDLER SPACE 1
1$:	RTS PC

2$:	CMP (R2),HAND2N		;IS HANDLER IN AREA 2?
	BNE 1$			;NO-MUST BE SYSTEM HANDLER,SO LEAVE IT
	CLR HAND2N		;YES-MARK AREA 2 FREE
	.RELEAS R2		;RELEASE HANDLER
	JSR	PC,CLOSE2	;RECLAIM HANDLER SPACE 2
	BR 1$
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
;SUBROUTINE EBCLOSE
;FORCES OUT LAST BUFFER,THEN
;IF AN EDIT BACKUP IS IN PROGRESS,CLOSES THE INPUT FILE,
;RENAMING IT TO FILE.BAK,THEN CLOSES OUTPUT FILE.

EBCLOS:	TSTB OTOFLG		;IS AN OUTPUT FILE OPEN?
	BEQ E72$		;NO-DON'T BOTHER TO WRITE
	JSR PC,WFORCE		;FORCE OUT LAST BUFFER LOAD
	.WAIT 13		;WAIT FOR LAST BUFFER TO BE WRITTEN
	BCS BW1$		;WRITE ERROR
E72$:	TSTB EBFLG		;IS AN EDIT BACKUP IN PROGRESS?
	BNE 1$			;YES
	RTS PC			;NO-RETURN
1$:	.LOCK			;FREEZE USR IN CORE
	.CLOSE 12		;CLOSE INPUT FILE
	MOV #BAK,OUTBLK+6	;PREPARE NAME BLOCKS FOR RENAME
	.RENAME 12,#INBLK	;RENAME INPUT FILE TO X.BAK
	.CLOSE 13		;CLOSE OUTPUT FILE
	.UNLOCK			;RELEASE USR FROM CORE
	CLRB OTOFLG		;MARK OUTPUT FILE CLOSED
	CLRB INOFLG		;MARK INPUT FILE CLOSED
	CLRB EBFLG		;NO EB IN PROGRESS ANY MORE
	RTS PC			;RETURN
	.ENDC			;<<<<<<<<<<<<<<<<<<<<

;SUBROUTINE WFORCE
;WRITES LAST OUTPUT BUFFER INTO OUTPUT FILE,FOLLOWED BY A CTRL/Z

WFORCE:	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	MOV	#CNTRLZ,R0	;PUT IN '^Z' AT FILE END
	JSR	PC,BLKSTF
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	CMP OBPTR,#OBUFF2	;WHICH BUFFER IS CURRENT POINTER IN?
	BHIS E71$			;IN BUFFER 2
	CMP OBPTR,#OBUFF1	;IF BUFFER IS EMPTY,WE DON'T WANT IT
	BEQ E73$
	BR BLKST8		;IN BUFFER 1,SO WRITE IT AN RETURN
E71$:	BNE BLKST2		;IF BUFFER NOT EMPTY,WRITE BUFF2 AND RETURN
E73$:	RTS PC
;SUBROUTINE BLKSTF
;PUTS CHARS IN OUTPUT BUFFERS, CALLING WRITE WHEN A BUFFER IS FULL

BLKSTF:	TSTB	OTOFLG		;IS AN OUTPUT FILE OPEN?
	BNE	BLKST7		;YES
	ERROR+14		;"FILE NOT OPEN"
BLKST7:	MOV	OBPTR,R2	;R2 POINTS INTO OUTPUT BUFFER
	INC	OBPTR		;BUMP OUTPUT POINTER
	MOVB	R0,(R2)+	;PUT CHAR IN OUTPUT BUFFER
	CMP	R2,#OBUFF2	;IS BUFFER 1 FULL?
	BNE	BLKST1		;NO-CHECK BUFFER 2
BLKST8:	MOV	#OBUFF1,R2	;YES-WRITE BUFFER 1
	MOV	#OBUFF2,-(SP)	;REMEBER TO ZERO BUFFER 2 BEFORE USING
	JMP	BWRITE		;AND RETURN

BLKST1:	CMP	R2,#OBEND	;IS BUFFER 2 FULL?
	BLO	BLKST3		;NO - RETURN
BLKST2:	MOV	#OBUFF2,R2	;WRITE BLOCK 2
	JSR	PC,BWRIT1
	MOV	#OBUFF1,OBPTR	;MOVE POINTER TO START OF BUFF1
BLKST3:	RTS	PC


	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
BWRIT1:	MOV	#OBUFF1,-(SP)	;ZERO BUFF1 BEFORE USING
BWRITE:	.WAIT 13		;WAIT FOR LAST WRITE
	BCS	BW1$		;WATCH FOR ERROR ON LAST WRITE
	.WRITE 13,R2,#400,OBLKNM;WRITE 1 BLOCK INTO OUTPUT FILE .
	BCS	BW1$		;ERROR
	INC	OBLKNM		;WRITE SUCCESSFUL SO BUMP BLK#
	MOV	(SP)+,R2	;PUT ADDR OF BUFFER TO CLEAR IN R2
	JSR	PC,BUFZRO	;CLEAR BUFFER
	RTS	PC

BW1$:	TSTB	ERRWD		;IS IT EOF
	BEQ	2$		;YES
	ERROR+10		;"HARDWARE ERROR"
2$:	.RCTRLO			;JUST IN CASE
	.PRINT	#OKCLOS		;"OK TO CLOSE OUTPUT"
	CLR	-(SP)
	BIC	#10000,@#JOBSTAT	;RESET SPECIAL TTY MODE
4$:	.TTYIN
	CMP	#'Y,R0		;YES?
	BNE	3$
	INC	(SP)
3$:	CMP	#12,R0		;LF?
	BNE	4$
	BIS	#10000,@#JOBSTAT	;SET SPECIAL TTY MODE
	TST	(SP)+		;YES TYPED IN?
	BEQ	5$		;NOPE
	JSR	PC,E72$		;TEST FOR EB IN PROGRESS
	JSR	PC,EFILE2	;DO NORMAL CLOSE IF NOT
	ERROR+17		;ABEND
5$:	ERROR+11		;"FILE FULL"
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
BWRIT1:	MOV	#OBUFF1,-(SP)	;NEW BUFF.
BWRITE:	IOT
	.BYTE	WAITR,0		;WAIT ON MAIN BUFF.
	+	BWRITE		;BUSY
	TSTB	WLIST		;END OF TAPE DETECTED?
	BPL	ITSOK		;NOPE
	JSR	PC,CNTINR	;YUP-CLOSE FILE-OPEN NEW ONE
	MOVB	ODEV,ODEV1	;REWRITE BLOCK THAT FAILED
	IOT
	.BYTE	XWRITE
ODEV1:	.BYTE	0
	.WORD	WLIST
	BR	BWRITE		;GO WAIT FOR IT TO FINISH
ITSOK:	MOV	R2,WLBUFF	;CURR. BUFF
	IOT
	.BYTE	XWRITE		;WRITE BUFF.
ODEV:	.BYTE	0		;DEVICE
	.WORD	WLIST
	MOV	(SP)+,R2	;2ND BUFF.
	JSR	PC,BUFZRO	;CLR. IT
	RTS	PC
;
WLIST:	.BYTE	1		;ST/ERR: MUST INIT. TO 1
	.BYTE	0
WLBUFF:	.WORD	0		;BUFF. ADDR.
	.ENDC			;<<<<<<<<<<<<<<<<<<<<

;EDIT READ
;PREPARES NEW FILE FOR INPUT

EREAD:	CLRB INOFLG		;THERE IS NOW NO INPUT FILE OPEN
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	JSR 	PC,EBCLOSE	;IF EB OPEN, CLOSE IT OUT
	.CLOSE 12		;CLOSE ANY OPEN INPUT FILE
	MOV	#INBLK,R2
	JSR	PC,RELEAS	;RELEASE OLS INPUT HANDLER
	MOV	#INBLK,R0	
	JSR	PC,FNGET	;GET NAME FOR NEW FILE
	MOV	#INBLK,R2
	.LOCK			;LOCK USR IN CORE
	JSR	PC,FETCH	;FETCH NEW INPUT HANDLER
	.LOOKUP 12,#INBLK	;IT IS ER-USE LOOKUP
	BCC	E111$	
	ERROR+13		;NO FILE
E111$:	MOV	R0,BLOCKS	;SAVE INPUT BLOCK LENGTH
	JSR	PC,CVDI		;PRINT INPUT SIZE
	.UNLOCK			;CHASE USR OUT OF CORE
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	MOVB	#1,RLIST	;INIT. RD. LIST ST/ERR
	MOV	#INBLK,R0
	MOV	#IDEV,DEVPTR
	JSR	PC,FNGET	;NAME INTO INBLK
	MOVB	IDEV,SKCHAN
	IOT
	.BYTE	10		;SEEK
SKCHAN:	.BYTE	0		;CHANNEL
	.WORD	SKLIST		;ARG LIST
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	CLR	IBLKNM		;START BLOCK 0
	CLRB	EFFLG		;CLEAR LAST BLOCK READ FLAG
	CLRB	EOFFLG		;CLEAR END OF FILE
	MOV	#IBUFF1,R2	
	JSR	PC,BREAD	;DO INITIAL READS TO FILL
	MOV	#IBUFF2,R2
	JSR	PC,BREAD
	INCB	INOFLG		;MARK OPEN
	MOV	#IBUFF1,IBPTR	;INIT INPUT BUFFER POINT
	RTS	PC
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
;
SKLIST:	.BYTE	0		;ST/ERR
	.BYTE	2		;MODE: UNFORM. ASCII
	.WORD	0,0		;UNFORM. ACCESS
	+	HDRBUF
	+	INBLK		;NAME
	+	SKERR
;
HDRBUF:	.=.+32.			;HDR. SCRATCH SPACE
;
SKERR:	BITB	#40,SKLIST	;ST/ERR - BLK. CHK?
	BEQ	FNFND		;NO: FILE NOT FND.
	ERROR+10		;HARDWARE ERROR
FNFND:	ERROR+13		;NO FILE
	.ENDC			;<<<<<<<<<<<<<<<<<<<<


;EDIT WRITE
;PREPARES NEW FILE FOR OUTPUT
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R

EWRITE:	TSTB	OTOFLG		;IS ANY OUTPUT FILE OPEN?
	BEQ	EWRIT3		;NO
	JSR	PC,EFILE1	;CLEAN UP ANY OPEN FILE
EWRIT3:	MOV	#OUTBLK,R0	
	JSR	PC,FNGET	;GET NEW NAME FOR OUTPUT
EWRIT5:	MOV 	#OUTBLK,R2
	.LOCK			;LOCK USR IN CORE
	JSR	PC,FETCH	;GET NEW OUTPUT HANDLER
	.ENTER 13,#OUTBLK,FILENG;OPEN OUTPUT FILE
	BCC	E100$		;ERROR?
	.CLOSE	13		;YES-CLOSE OUTPUT FILE
	ERROR+15		;MUST BE FULL DIRECTORY
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
EWRITE:	TSTB	OTOFLG
	BEQ	EWRIT3
	JSR	PC,EFILE1
EWRIT3:	MOV	#OUTBLK,R0
	MOV	#ODEV,DEVPTR
	JSR	PC,FNGET
	MOVB	ODEV,ENTCHAN
REDO:	MOV	#ENTERR,ERRAD
	MOV	#OBDATE,R2	;ZERO DATE TO GET
	CLR	(R2)+		;  CURR. ONE IN
	CLR	(R2)+
	CLR	(R2)+
	IOT
	.BYTE	7		;ENTER
ENTCHAN:.BYTE	0
	.WORD	ENTLIST
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
E100$:
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	JSR	PC,CVDO
	.UNLOCK			;RELEASE USR
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	MOV	#OBUFF1,R2
	JSR	PC,BUFZRO
	MOV	#OBUFF2,R2	;ZERO OUTPUT BUFFERS BEFORE USING THEM
	JSR	PC,BUFZRO
	CLR	OBLKNM		;START AT BLOCK 0
	INCB	OTOFLG		;OUTPUT FILE IS OPEN
	MOV	#OBUFF1,OBPTR	;INITIALIZE OUTPUT POINTER
	RTS PC			;RETURN
	.IF DF,NODISP			;>>>>NODISP
	.PAGE
	.SBTTL  FILE SIZE DETERMINATION

; INSTALLED BY D.SHEPPERD ATARI,INC. 4/5/77

CVDI:	MOV	R0,-(SP)	;SAVE SIZE
	.PRINT	#INSIZE		;PRINT 'INPUT'
	BR	CVD
CVDO:	MOV	R0,-(SP)	;SAVE SIZE
	.PRINT	#OUTSZE		;PRINT 'OUTPUT'
CVD:	MOV	R1,-(SP)
	MOV	R2,-(SP)
	.PRINT	#SZE0		;PRINT 'FILE SIZE'
	MOV	4(SP),R1	;GET SIZE
	MOV	#10.,R2
	JSR	PC,DNC		;CONVERT TO DECIMAL
	.PRINT	#SZE1		;PRINT '.BLOCKS'
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	PC

DNC:	CLR	R0
	JSR	PC,DIV		;DIVIDE R1 BY 10.
	MOV	R1,-(SP)	;SAVE REMAINDER
	MOV	R0,R1		;PREPARE TO DIVIDE AGAIN
	BEQ	1$		;UNLESS 0
	JSR	PC,DNC		;LOOP
1$:	MOV	(SP)+,R0	;GET NUMBER
	ADD	#'0,R0		;MAKE IT ASCII
	.TTYOUT			;PRINT IT
	RTS	PC		;FINISH ALL DIGITS, EXIT

DIV:	MOV	#16.,-(SP)	;LOOP COUNT
	CLR	-(SP)		;RESULT
1$:	ASL	(SP)		;SHIFT RESULT
	ASL	R1		;SHIFT WORK REG
	ROL	R0		;(DOUBLE WORD)
	CMP	R0,R2		;BIG ENOUGH?
	BLT	2$		;NO
	SUB	R2,R0		;YES
	INC	(SP)		;BUMP RESULT
2$:	DEC	2(SP)		;END?
	BNE	1$		;NO
	MOV	R0,R1		;REMAINDER TO R1
	MOV	(SP)+,R0	;RESULT TO R0
	TST	(SP)+		;PRUNE STACK
	RTS	PC

INSIZE:	.ASCII	/INPUT /<200>
OUTSZE:	.ASCII	/OUTPUT /<200>
SZE0:	.ASCII	/FILE SIZE /<200>
SZE1:	.ASCIZ	/. BLOCKS/
	.EVEN
	.ENDC			;<<<<NODISP

	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
ENTLIST:.BYTE	0		;ST/ERR
	.BYTE	2		;MODE: UNFORM. ASCII
	.WORD	0,0
	+	HDRBUF
	+	OUTBLK
ERRAD:	.WORD	ENTERR
	+	CNTINR
;
ENTERR:	BIT	#40,ENTLIST
	BNE	HRDWER		;HRDW ERR.
	BIT	#100,ENTLIST
	BNE	TF		;TAPE FULL
	HALT			;CAN'T HAPPEN
HRDWER:	ERROR+10
TF:	ERROR+20		;TAPE FULL
;
CNTINR:	MOVB	#-1,ENTLIST	;TO PROMP
	MOVB	ODEV,ECH
	MOV	#ENTERR,ERRAD
	MOVB	ODEV,CNUM	;CLOSE FILE
	IOT
	.BYTE	6
CNUM:	.BYTE	0
	.WORD	.+2
	CLRB	OTOFLG		;OUT FILE NO LONGER OPEN
	IOT
	.BYTE	7		;ENTER
ECH:	.BYTE	0
	.WORD	ENTLIST
	INCB	OTOFLG		;OUT FILE OPEN
	RTS	PC
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.SBTTL
	.MCALL	.TTINR
;EXIT
;FLUSHES REST OF INPUT FILE THROUGH AND EXITS TO MONITOR

EXIT:	INCB	EXFLG		;MARK EXIT IN PROGRESS
	TSTB	OTOFLG		;IS THERE AN OUTPUT FILE OPEN?
	BNE	E115$
	ERROR+14		;NO-"NO FILE"
E115$:	TSTB	INOFLG		;IS THERE AN INPUT FILE OPEN?
	BEQ	E116$		;NO-JUST WRITE THIS BUFFER
E114$:	TSTB	EOFFLG		;EOF YET?
	BNE	E116$		;YES-DONE
	JSR	PC,NEXT		;NO-DO A NEXT
	BR	E114$
E116$:	JSR	PC,BEGIN
	INCB	SLSFLG
	JSR	PC,WRITE	;DO ONE LAST B/W TO OUTPUT LAST PAGE
	JSR	PC,EFILE	;YES-DO AN END FILE
	CLRB	EXFLG		;EXIT NO LONGER IN PROGRESS
	.IFNDF NODISP		;>G>G>G>G>G>G>G>G>G>G
	TSTB	DSFLG		;IS DISPLAY HDWRE ACTIVE
	BEQ	1$		;NO - SKIP DISPLAY COMMANDS
	.UNLNK			;UNLINK FROM MONITOR
1$:
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
	MOV	@#RMONTP,R0
	CLRB	MONCOM(R0)	;NO ERRORS FOR BATCH
	MOV	BATSVE,R2	;BATCH IN CONTROL?
	BIT	#4,R2
	BEQ	RETMON		;NOPE
	MOV	DSA+4,R1	;GET ENTRY ADDRESS
	BEQ	RETMON		;NO GOOD
	ADD	#6,R1		;INDEX TO 'BATSW1'
	BIS	#40100,R2	;SET '\B' MODE
	BIC	#220,R2
	MOV	R2,(R1)		; PASS IT TO BATCH
1$:	.TTINR			;EMPTY TT BUFFER
	BCC	1$
RETMON:	CLR	@#JOBSTAT	;RESET TT STUFF AND NO RE-ENTER
	CLR	R0
	.EXIT			;BACK TO RMON

BA:	.RAD50	/BA /
DSA:	.WORD	0,0,0,0
BATSVE:	.WORD	0
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
	TSTB	@#KBLRES
	BEQ	RBOOT
	JMP	@KBLADR
RBOOT:	MOV	#CCMES,R3	;PROMPT USER TO MOUNT SYS. CT
	JSR	PC,EPRINT
	IOT
	.BYTE	XREAD,KEYBRD	;WAIT FOR A RESPONSE
	+	TTINBUF
XY:	BITB	#200,TTST	;GOT IT YET?
	BEQ	XY		;NO
	CLR	PC
;
CCMES:	.ASCII	/^C?/
	.BYTE	0
	.EVEN
	.ENDC			;<<<<<<<<<<<<<<<<<<<<

	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R
;END FILE
;CLOSES OUTPUT FILE

EFILE:	JSR	PC,OOPCHK	;MAKE SURE AN OUTPUT FILE IS OPEN
EFILE1:	JSR	PC,EBCLOS	;CLOSE ACTIVE EB IF ANY AND FORCE OUT LAST BLOCK
EFILE2:	.LOCK			;LOCK USR IN CORE
	.CLOSE 13		;CLOSE OUTPUT FILE
	CLRB	OTOFLG		;MARK OUTPUT NOT OPEN
	MOV	#OUTBLK,R2
	JSR	PC,RELEAS	;FREE OUTPUT HANDLER
	.UNLOCK			;CHASE USR BACK OUT
	RTS	PC
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
EFILE:	JSR	PC,OOPCHK
EFILE1:	JSR	PC,WFORCE
	MOVB	ODEV,CLSCHAN
	IOT
	.BYTE	6		;CLOSE
CLSCHAN:.BYTE	0
	.+2			;ERROR RTN (NONE POSS.)
	CLRB	OTOFLG
	RTS	PC
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IFNDF	$CAPS11		;>R>R>R>R>R>R>R>R>R>R


;EDIT BACKUP
;PREPARES FILE FOR BACKUP RENAME

EBCKUP:	JSR	PC,EFILE1	;CLOSE ANY CURRENTLY OPEN FILES
	JSR	PC,EREAD	;OPEN INPUT FILE
	MOV #INBLK,R2		;R2 POINTS TO INPUT NAME
	MOV #OUTBLK,R0		;R0 POINTS TO OUTPUT NAME
	MOV (R2)+,(R0)+
	MOV (R2)+,(R0)+
	MOV (R2)+,(R0)+		;MOVE INPUT NAME INTO OUTPUT NAME BLOCK
	MOV (R2)+,(R0)+
	INCB	EBFLG		;MARK EDIT BACKUP IN PROGRESS
	JMP	EWRIT5		;OPEN OUTPUT FILE

	BAK=6263		;.RAD50 /BAK/
	.ENDC			;<<<<<<<<<<<<<<<<<<<<
	.IF NDF,NODISP		;>G>G>G>G	NODISP
CURSOR:	SHORTV!INT7!BLKON
CUR1:	15!INTX		; 15!INTX!MISVY	FOR MINUS CURSOR
	15!MISVY	; 15		FOR MINUS CURSOR
	3200!INTX
	3200!MISVX
	CHAR!INT4!BLKOFF
	DRET
	0
DSFILE:	POINT			;DRAW LINE ABOVE SCROLL AREA
	0
	200
	LONGV!LINE3
	MAXX!INTX
	0
	POINT			;POSITION THE BEAM
	0
DSDTOP:	1350
	CHAR!INT4!BLKOFF
DBUFR:	DRET
	0
; THIS CODE IS INITIALIZATION CODE LOCATED IN THE
; DISPLAY BUFFER AND IS EXECUTED ONCE ON START UP.
; IT TESTS FOR SCOPE SIZE AND SETS THE TOP OF THE
; BUFFER DISPLAY TO THE PROPER POSITION.

DPC=172000	;DISPLAY PROGRAM COUNTER
DSR=172002	;DISPLAY STATUS REGISTER

TSTSCP:	.INSRT	#TESTF		;DISPLAY A TEST FILE
1$:	TST	@#DSR		;DISPLAY STOPPED?
	BPL	1$		;NO, KEEP TESTING
	CMP	@#DPC,#G3	;STOPPED IN RIGHT PLACE?
	BNE	1$		;NO, KEEP LOOPING
	BIT	#40,@#DSR	;EDGE FLAG SET?
	BNE	2$		;YES, 12" SCOPE
	MOV	#1750,DSDTOP	;SET TOP FOR 17" SCOPE
	MOV	#8.,SCBUF	;SET 8 LINE OF COMMANDS
	MOV	#300,SCBUF+2	;AT LOCATION 300 ON SCREEN
	MOV	#340,DSFILE+4	;POSITION LINE ABOVE COMMAND TEXT
	MOV	#15.,DSARG	;DISPLAY 30 LINES OF TEXT
2$:	MOV	#NOP,G1		;NOP THE CALL WHICH
	MOV	#NOP,G1+2	;GOT US HERE!
	MOV	#DNOP,G2	;REMOVE DISPLAY STOP
	.START			;RESTART DISPLAY 
	.REMOV	#TESTF		;REMOVE TEST FILE
	RTS	PC		;THEN EXIT FOREVER
;
TESTF:	POINT
	500
	1350
	LONGV
	0
	400
G2:	173000			;DISPLAY STOP
G3:	DRET
	0
;END OF INITIALIZATION CODE

	.BLKW	1200		;DISPLAY FILE
DBUFE=.
	DRET
	0
	.ENDC			;<<<<<<<<<<<<<<<<<<<
	.IFDF	$CAPS11		;>C>C>C>C>C>C>C>C>C>C
START:	MOV	EDSTRT,SP
	IOT
	.BYTE	1,0		;RESET
	+	0
	IOT
	.BYTE	2,0		;SET CONTROL/P RESTART
	+	CPREST		;  TO RETURN TO CMD. MODE
	MOV #ERRORT,@#30
	CLR @#32		;INIT ERROR TRAP VECTOR
	TSTB	@#KBLRES	;IF KBL NOT RESIDENT,
	BNE	ITSIN
	MOV	@#HIFREE,R0	;  PUT LIMIT AT HIGHEST POSS.
	BR	LIMIN
ITSIN:	MOV	@#KBLADR,R0
	TST	-(R0)		;NOW HAVE HIGHEST FREE LOC
LIMIN:	MOV	R0,BEND
	MOV	R0,MBSTRT
	MOV	R0,SBSTRT
	MOV	EDTOP,R1
	MOV	R1,CBSTRT
	MOV	R1,PBSTRT
REENTR:	MOV #NEGFLG,R0
REENT1:	CLR (R0)+		;LOOP TO INITIALIZE ALL FLAGS TO 0
	CMP R0,#EQLENG
	BLOS REENT1		;BRANCH IF NOT DONE
	MOV	R1,PTR
	MOVB	#1,RLIST
	MOVB	#1,WLIST
	JMP	ASTER
;
CPREST:	MOV	EDSTRT,SP	;RESET STACK
	TSTB	OTOFLG		;OUTPUT FILE OPEN?
	BEQ	START		;NO: NEEDN'T CLOSE IT
	JSR	PC,EFILE1	;CLOSE OUTPUT FILE
	BR	START		;START FROM SCRATCH
	.ENDC			;<<<<<<   CAPS
;

	.EVEN

	EDEND=.			;TOP OF EDITOR

	.END	START
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        