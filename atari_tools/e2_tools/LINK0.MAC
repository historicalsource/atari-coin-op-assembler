;	20-NOV-76
;	11:00:00
;	LINKER MODIFIED FOR MICROPROCESSORS BY D.SHEPPERD 11/20/76

	.TITLE	LINK0: LINKM ROOT CODE   V04-04
; RT-11 LINKER
;
; DEC-11-ORLLA-E
;
; MAY 15, 1974
;
; EP/ ENHANCED BY JG
;
; COPYRIGHT (C) 1974,1975
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE,
; OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE MADE
; AVAILABLE TO ANY OTHER PERSON EXCEPT FOR USE ON SUCH SYSTEM AND TO
; ONE WHO AGREES TO THESE LICENSE TERMS. TITLE TO AND OWNERSHIP OF THE 
; SOFTWARE SHALL AT ALL TIMES REMAIN IN DIGITAL.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE
; OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DIGITAL.
	.PAGE
	.SBTTL	SYMBOLIC CONSTANTS


	R0=%0
	R1=%1
	R2=%2
	R3=%3
	R4=%4
	R5=%5
	SP=%6
	PC=%7


	TAB=	11
	LF=	12
	FF=	14
	CR=	15
	SPAC=	40
	PER=	56


	GSD=	1	;OBJECT MODULE CODES
	TXT=	3
	RLD=	4
	MODEND=	6
	LBR=	7	;LIBRARY MODULE CODE
	LBREND= 10	;LIBRARY END CODE

	BYTBLK=	512.	;BYTE BLOCK SIZE
	BEGIN=	40	;DISPS INTO SYS JOB DATA AREA
	JSTACK=	42	;JOB'S INITIAL STACK POINTER
	JSTATS=	44	;JOB STATUS WORD
	USRLOC=	46	;ADDR OF SWAPPING USR
	HIGH=	50	;HIGHEST LOC USED BY USER
	ERRBYT=	52	;MONITOR ERROR INDICATOR
	MONLOW=	54	;ADDR OF RMON LOWER LIMIT
	RSIZE=	52	;ROOT SIZE OG PROGRAM
	OVSIZE=	54	;SUMS OF THE LARGEST OVERLAY REGIONS
	RELID=	56	;FB IDENTIFIER ADR
	RELBLK=	60	;ADDRESS OF REL
	MONCOM=	356	;OFFSET TO BATCH COMMUNICATION BYTE


	.CSECT=	2	;LINKER SYMBOL TABLE FLAGS
	.OVR=	4


	$DEFIN=	10	;GSD FLAGS
	$RELOC=	40
; OFFSETS INTO ENTRY POINT TABLE
	EPTALO=	30	;EPT ENTRIES ALLOCATED(BYTES)
	LHEND=	44	;REL END OF LBR HEADER


	;OFFSETS INTO OVERLAY SECTION BLOCK
	LEVPTR=	2	;POINTER TO LEVEL BLOCK
	IDNO=	4	;OVERLAY SECTION ID NUMBER
	BASBLK=	6	;BASE BLOCK OF SECTION ON OUTPUT
	SECLEN=	30	;SECTION LENGTH
	NXSPTR=	32	;POINTER TO NEXT SECTION SAME LEVEL

	LVLN=	-8.	;OFFSETS INTO OVERLAY LEVEL BLOCK
	LVLP=	-6
	SECP=	-4


	OVJOB=	1000	;BIT IN JSTATS WORD TO INDICATE
			;AN OVERLAY JOB


	; USEFUL EMT INSTRUCTIONS
	LKEMT=	EMT+20	;LOOKUP EMT
	SSEMT=	EMT+120	;SAVESTATUS EMT
	WEMT=	EMT+240	;WAIT EMT




	.MCALL	..V1..
	..V1..
	.MCALL	.CSISPC,.CSIGEN,.SETTOP,.LOCK,.UNLOCK
	.MCALL	.FETCH,.LOOKUP,.PRINT,.TTYIN,.WAIT,.ENTER
	.MCALL	.CLOSE,.SRESET,.READW,.WRITW,.WRITE
	.MCALL   .REOPEN,.RCTRLO,.QSET,.DATE,.READ


	LDA=	0	;TURN ON LDA FEATURE
;	FB=	0	;TURN ON FB


	.SBTTL	BUFFERS AND VARIABLES

	.ASECT
	.=42
	.WORD	STK
	.WORD	1400
	.CSECT	MONARG	;THIS CSECT MUST BE FIRST

	.GLOBL	DEFEXT

; DO NOT CHANGE ORDER OF FOLLOWING WORDS:
DEFEXT:	.RAD50	/OBJ/	;CSI DEFAULT EXTENSIONS
	.RAD50	/SAV/
	.RAD50	/MAP/
	.WORD	0
	.CSECT	IMPUR1

	.GLOBL	IMPURE,STK,ODBLK,MDBLK,TEMP,TXTBLK
	.GLOBL	SYMEND,STINCR,STLEN,STSIZE,SYMM6,SYMM12
	.GLOBL	SYMM20,SYMM22,STDIV,CURBUF,CURBLK
	.GLOBL	MODCNT,CSECT,ENDOL,OVFLG,OVCOUN,SECNUM
	.GLOBL	OVSPTR,OVSEC,OVLVL,FILPT,FILPT1,HGHLIM
	.GLOBL	NXTBLK,BEGBLK,LDAPTR,CKSUM,COLCT,BASE
	.GLOBL	TXTLEN,PADDR,OBLK,ABWMAP,SEGBAS,SEGBLK
	.GLOBL	CLC,LINBUF,PASS,ASWIT,CSWIT
	.GLOBL	ISWIT,LSWIT,PAS1.5,BUFSWT
	.GLOBL	ONEPT,SSWIT,LIBDIR,STKBLK
	.GLOBL	DOSB,ASECT,BWMAP,OVLV1,HLRT,DOLB
	.GLOBL	BOTTOM,IMPURT,DIREND,BSWIT,STKBLK
	.GLOBL	BEGLML,ENDLML,STLML,LMLSWT,LMLBLK,HARDER
	.GLOBL	PA2LML,LIBBLK
	.IF DF FB
	.GLOBL	RSWIT,RELPTR,FBTXT,OVLNUM,RELOVL,RLSTRT
	.GLOBL	RELADR,PNRELO,RELID1,RSIZ1,OVSIZ1,OVLCDE
	.ENDC
	.GLOBL	LERRF,CURPC,BSECT,SSECT,BSCTSW

IMPURE:
	;EVERYTHING IN THIS CSECT IS CLEARED AT START


	.BLKW	100		;STACK AREA
STK:

; DO NOT CHANGE ORDER OF FOLLOWING 4 AREAS
ODBLK:	.BLKW	5		;BLOCK TO HOLD BINOUT SPEC
MDBLK:	.BLKW	5		;BLOCK TO HOLD MAPOUT SPEC
TEMP:	.BLKW	2		;TEMPORARY STORAGE
TXTBLK:	.BLKW	65.

; SYMBOL TABLE PARAMETERS:
SYMEND:	.BLKW	;ADDR OF FREE WORD AFTER TABLE
STINCR:	.BLKW	;INCREMENT USED BY LOOKUP
STLEN:	.BLKW	;LENGTH OF TABLE IN BYTES
STSIZE:	.BLKW	;LENGTH OF TABLE IN ITEMS (4 WDS/ITEM)
SYMM6:	.BLKW	;POINTER TO SYMBOL TABLE MINUS 6
SYMM12:	.BLKW	;PTR TO SYMTAB-12
SYMM20:	.BLKW	;ETC.
SYMM22:	.BLKW
STDIV:	.BLKW	;NORMALIZED STSIZE USED BY LOOKUP

PA2LML:	.BLKW	
BEGLML:	.BLKW			;PTR TO LIBRARY MOD LIST
STLML:	.BLKW		;START OF LML PTR
ENDLML:	.BLKW		;PTR TO END OF LIB MOD LIST
LMLBLK:	.BLKW		;LIB MOD LIST BLK COUNT
CURBUF:	.BLKW	;CURRENT INPUT BUFFER
CURBLK:	.BLKW	;CURRENT BLOCK # ON INPUT
LIBBLK:	.BLKW		;LIBRARY BLK #
MODCNT:	.BLKW	;OBJECT MODULE COUNTER
CSECT:	.BLKW	;PTR TO LATEST CSECT (PASS1)
ENDOL:	.BLKW	;POINTER TO CURRENT END OF SYMTAB LIST
; DO NOT CHANGE ORDER OF NEXT 2 WORDS:
OVFLG:	.BLKW	;=4 IF OVERLAYS
OVCOUN:	.BLKW	;4*NO. OF OVERLAY ENTRY PTS.
SECNUM:	.BLKW	;COUNT OF OVERLAY SECTIONS*6
OVSPTR:	.BLKW	;PTR TO OVERLAY SECT BLK
OVSEC:	.BLKW	;OVERLAY SECTION COUNT
OVLVL:	.BLKW	;OVERLAY LEVEL COUNT
FILPT:	.BLKW	;PTR TO CURRENT INPUT FILE BLK
FILPT1:	.BLKW	;INITIAL VALUE OF FILPT
HGHLIM:	.BLKW	;HIGHEST LOCATION USED BY PROGRAM
NXTBLK:	.BLKW	;NEXT ASSIGNABLE OUTPUT BLK
BEGBLK:	.BLKW	5	;TRANSFER ADDRESS BLOCK
STKBLK:	.BLKW	3		;USER STACK ADDRESS BLOCK
	.IF	DF	LDA
LDAPTR:	.BLKW	;LDA OUTPUT BUFFER POINTER
CKSUM:	.BLKW	;ACCUMULATOR FOR LDA CHECKSUMS
	.ENDC
COLCT:	.BLKW	;COLUMN COUNTER FOR MAP PRINT
BASE:	.BLKW	;PASS 2 BASE OF CURRENT CSECT
TXTLEN:	.BLKW	;PASS 2 LENGTH OF TXT BLOCK
PADDR:	.BLKW	;PASS 2 PROGRAM ADDRESS OF OBUF
OBLK:	.BLKW	;PASS 2 RELATIVE BLK # IN OUTPUT FILE
ABWMAP:	.BLKW	;ADDR OF BIT MAP
SEGBAS:	.BLKW	;PASS 2 BASE OF OVERLAY SECTION
SEGBLK:	.BLKW	;PASS 2 BASE BLK OF OVERLAY SECT
CLC:	.BLKW	;PASS 2 CURRENT LOCATION COUNTER
LINBUF:	.BLKW	40.	;ERROR MSG BUFFER
BUFADR:	.BLKW		;CURRENT BUFFER ADR
LIBDIR:	.BLKW		;PTR TO RESIDENT LIBR DIR
DIREND:	.BLKW		;END OF RES LIB DIR
	.IF DF FB
RLSTRT:	.BLKW		;CURRENT REL BLK OVERLAY NUM
RELPTR:	.BLKW		;POINTER TO CURRENT REL BLK LOCATION
FBTXT:	.BLKW		;LENGTH OF TEXT
OVLNUM:	.BLKW		;CURRENT REL BLK OVL NUM
RELOVL:	.BLKW		;NEXT REL BLK OVL NUM
RELADR:	.BLKW		;ADR OF RELOC CODE IN TEXT IN REL FILE
RELID1:	.BLKW
OVSIZ1:	.BLKW	
RSIZ1:	.BLKW
OVLCDE:	.BLKW
	.ENDC
LERRF:	.BLKW		;ERROR LIST CONTROL
CURPC:	.BLKW		;CURRENT BASE SAVE SPACE
BSECT:	.BLKW		;LOCATION OF THE NEXT .BSECT
SSECT:	.BLKW		;LOCATION OF .SSECT
BSCTSW:	.BLKW		;FLAG INDICATING PROCESSING .BSECT OR .SSECT
BSWIT:	.BYTE		;BOTTOM SWITCH
PASS:	.BYTE		;PASS SWITCH (0 = PASS1)
ASWIT:	.BYTE		;ALPHABETICAL LOAD MAP
CSWIT:	.BYTE		;INITIAL DIALOGUE CONTINUE SWITCH
ISWIT:	.BYTE		;GLOBAL INCLUDE SWITCH (01)/LIBRARY FILE (01)
;			/(100) LIBRARY FILE PASS 2
	.IF	DF	LDA
LSWIT:	.BYTE		;LDA SWITCH
	.ENDC
PAS1.5:	.BYTE		;PASS 1.5 SWITCH
BUFSWT:	.BYTE		;LIBR SEARCH BUFFER SWITCH
ONEPT:	.BYTE		;SPECIAL PROCESSING WHEN = -1
SSWIT:	.BYTE		;NON RES LIBR DIR SWITCH
LMLSWT:	.BYTE		;LIBRARY MODULE LIST SWITCH
	.IF DF FB
RSWIT:	.BYTE		;FB SWITCH
PNRELO:	.BYTE		;POSITIVE/NEGATIVE RELOCATION
	.ENDC

	.EVEN
; DO NOT CHANGE ORDER OF FOLLOWING WORDS:
DOSB:		;DUMMY OVERLAY SECTION BLOCK
ASECT:	.BLKW	;POINTER TO SYMBOLTABLE LIST FOR ROOT SEG
	.BLKW	;POINTER TO DUMMY OVERLAY LEVEL BLOCK
	.BLKW	;ID NO. OF ROOT
	.BLKW	;BASE BLOCK OF ROOT
BWMAP:	.BLKW	8.	;BIT MAP FOR BLOCKS WRITTEN
	.BLKW	;LENGHT OF ROOT
	.BLKW	;PTR TO NEXT SECTION THIS LEVEL (NONE)

; DO NOT CHANGE ORDER OF FOLLOWING WORDS:
; DUMMY OVERLAY LEVEL BLOCK
	.BLKW	;LEVEL NUMBER
OVLV1:	.BLKW	;BECOMES PTR TO LIST
	.BLKW	;PTR TO DUMMY SECTION BLOCK
HLRT:	.BLKW	;HIGH LIMIT OF AREA
DOLB:
BOTTOM:	.BLKW	;DEFAULT BOTTOM ADDRESS
IMPURT:

	.CSECT	DPURE

	.GLOBL	LDAEXT,EXPAND,LIMIT,IBUF1,EIBUF1,IBUF2
	.GLOBL	EIBUF2,MAPBUF,EMAPBU,MAPBLK
	.IF DF FB
	.GLOBL	RELEXT

RELEXT:	.RAD50	/REL/		;FOREGROUND EXTENSION
	.ENDC

; I/O BUFFER POINTERS - DO NOT CHAMGE ORDER !!!

	.WORD	EIBUF2		;POINTER TO END OF ALT BUFFER
	.WORD	IBUF2		;POINTER TO ALT BUFFER
	.BLKW		;STATUS OF ALT BUFFER
IBUF1:	.BLKW		;POINTER TO BUFFER #1
EIBUF1:	.BLKW		;POINTER TO END OF BUFFER #2
	.WORD	EIBUF1
	.WORD	IBUF1
	.BLKW
IBUF2:	.BLKW		;POINTER TO BUFFER #2
EIBUF2:	.BLKW		;POINTER TO END OF BUFFER #2

; END I/O BUFFER POINTERS

MAPBLK:	.BLKW		;MAP FILE BLOCK #
MAPBUF:	.BLKW		;MAP BUFFER POINTER
EMAPBU:	.BLKW		;END OF MAP BUFFER

LIMIT:	.LIMIT
	.IF DF	LDA
LDAEXT:	.RAD50	/LDA/
	.ENDC
	.WORD	-1		;TERMINAL
	.WORD	0		;END OF WORD SIGNAL
	.WORD	50		;DIVISOR
	.WORD	3100		;DIVISOR
	.WORD	0		;END OF WORD SIGNAL
	.WORD	50		;DIVISOR
EXPAND:	.WORD	3100		;DIVISOR


	.CSECT	CHAR

	.GLOBL	CRLF,TAM,CSIPT,CSISZE

	.NLIST	BEX
CRLF:	.BYTE	CR,LF,0
TAM:	.ASCIZ	<CR><LF><LF>/TRANSFER ADDRESS = /
	.EVEN
CSIPT:	.BLKW	256.
CSISZE:	.WORD	0

	.LIST	BEX
	.SBTTL	MISCELLANEOUS MACRO DEFINITIONS

	.MACRO	ERROR	MSG
	JSR	R0,ERROR
	.ASCIZ	"?'MSG'?"
	.EVEN
	.ENDM

	.MACRO	PRINT	MSG
	JSR	R5,PR00
	.WORD	MSG
	.ENDM

	.MACRO	LERROR	MSG,REG
	.CSECT	CHAR
	CHARPT=.
	.ASCIZ	"MSG"
	.CSECT	MAIN
	.IF NB	REG
	MOV	REG,R0
	JSR	R5,LERROR
	.IFF
	JSR	R5,LERROR+2
	.ENDC
	.WORD	CHARPT
	.ENDM

	.MACRO	LERRA	MSG
	.CSECT	CHAR
	CHARPT=.
	.ASCIZ	"MSG"
	.CSECT	MAIN
	JSR	R5,LERRA
	.WORD	CHARPT
	.ENDM

	.MACRO	MAPOUT	OP
	.IIF NB,<OP>,MOVB	OP,%0
	JSR	PC,MAPOUT
	.ENDM
	.CSECT	MAIN		;ROOT CODE

	.GLOBL	EPTSER,LOOKUP,PR00,LERROR,LERRA,SAVREG
	.GLOBL	BYTE,NEWBLK,GT1BYT,GETBYT,NEWBUF,SKPBLK
	.GLOBL	POST,PASS1
	.GLOBL	OBUF,EOBUF,INIO,ERROR
	.GLOBL	OCTOUT,DECODE,DMP0,DMPA,LDAOUT
	.GLOBL	START1,RPACK,CLOSE,SSWIT,LIBDIR,RESLIB
	.GLOBL	GETLIB,NEWBF1,TDMP0,MAPOUT			;###
	.IF DF FB
	.GLOBL	WRTREL,RELWRD,RELBUF,RELERR
	.ENDC

	.SBTTL	OUTPUT BUFFERS


OBUF:	.BLKW	256.
EOBUF:
	.SBTTL	START AND EPT SEARCH ROUTINES

; ENTER HERE TO CALL START OVERLAY

	BR	RESTRT
START:	MOV	#STK,SP	;INIT THE STACK
	JMP	START1

RESTRT:	.RCTRLO
	.PRINT	#CRLF
	CLR	R0
	.WAIT	0
	.WAIT	3
	.SRESET
	.UNLOCK
	BR	START

; ENTRY POINT SEARCH ROUTINE - CALLED BY PASS1,PASS2,AND PASS3
; SEARCH THE ENTRY POINT ABLE FOR A MATCH OF THE
; INDICATED SYMBOL.
; INTERFACE:
;	R0 - DESTROYED
;	R1 - POINTS TO SYMBOL TO BE SEARCHED FOR
;	R2 - DESTROYED
;	R4 - POINTS TO EPT SYMBOL HEAD
;	R5 - POINTS TO END OF INPUT BUFFER
;RETURN INTERFACE:
;	C BIT = 0 - SYMBOL FOUND
;	C BIT = 1 - SYMBOL NOT FOUND
;	R4 - POINTS TO END OF EPT IF SYMBOL NOT FOUND.
;	OTHERWISE, IT POINTS TO THE SYMBOL AFTER THE 
;	FOUND SYMBOL, AND R3 POINTS TO THE FOUND SYMBOL
;	BUFSWT = -1 - EPT HDR BUFFER SWITCHED
;	BUFSWT = 0 - EPT HDR IN CURRENT INPUT BUFFER

EPTSER:
	MOV	#LINBUF,R0
	MOV	R1,-(SP)	;SAVE UNDEF SYMBOL PTR
1$:	MOV	R0,R3
	MOV	#8.,R2
2$:	MOVB	(R4)+,(R0)+	;MOVE EPT ENTRY
	TSTB	SSWIT		;LIBR DIR RES ?
	BEQ	3$		;YES
	CMP	R4,R5		;END OF INPUT BUFFER ?
	BLO	3$
	MOV	R0,-(SP)
	CLRB	BUFSWT		;INSURE SWITCH NEGATIVE
	JSR	PC,NEWBF1	;READ LIBR DIRECTORY
	MOV	(SP)+,R0
	COMB	BUFSWT		;IND NOT AT EPT HEAD
3$:	DEC	R2		;EPT MOVED ?
	BNE	2$
	MOV	R3,R0
	INC	R2
4$:	CMP	(R1)+,(R3)+	;SYMBOL MATCH ?
	BNE	10$
	DEC	R2		;CHECK 2ND HALF OF SYMBOL ?
	BEQ	4$
	MOV	R0,R3		;PT TO FOUND SYMBOL
	CLC			;IND SYMBOL FOUND
	BR	SEREXT
10$:	TST	@R4		;END OF EPT?
	BEQ	12$
	MOV	@SP,R1		;RESTORE UNDEF SYMBOL PTR
	BR	1$
12$:	SEC			;IND SYMBOL NOT FOUND
SEREXT:	MOV	(SP)+,R1
	RTS	PC
	.SBTTL	LIBRARY DIRECTORY RESIDENT ROUTINE

; RESLIB - MAKE THE LIBRARY DIRECTORY RESIDENT
;	INTERFACE - 
;	R4 - POINTER TO START OF LIBRARY IN INPUT BUFFERS
; RETURN INTERFACE:
;	SSWIT - (0) LIBR DIR MADE RESIDENT
;	SSWIT - (+1) LIBR DIR NOT RESIDENT

RESLIB:
	MOV	R0,-(SP)	;[HJ/17-NOV-74]
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	EPTALO-6(R4),R1		;GET EPT ENTRIES ALLOC.
	MOV	DIREND,R0	;R0 - END OF DIR BUFFER
	MOV	LIBDIR,R2	;GET PTR TO CORE AREA
	SUB	R2,R0	;HOW BIG IS IT ?
	ADD	#2,R1		;+ ONE WORD FOR END
	CMP	R0,R1		;WILL DIR FIT IN BUFFER ?
	BLO	1$
	ADD	R1,R2	;PT TO END OF LIB DIR
	CLR	(R2)+	;CLEAR END OF DIR AREA
	CLR	(R2)+
	CLR	R0	;INDICATE BLOCK 0
	ROR	R1		;AND GET WORD COUNT FOR READ
	.READW	3,LIBDIR,R1	;READ THE EPT
	BCC	2$		;BRANCH UNLESS ERROR
1$:	INCB	SSWIT		;INDICATE NON-RES
2$:	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	PC

	.SBTTL	LIBRARY I/O ROUTINE

; GETLIB - READS THE LIBRARY FILE IN SINGLE BUFFERED
; INSTEAD OF DOUBLE BUFFERED MODE. (NOTE - 512 WORD BUFFER )

GETLIB:	MOV	IBUF1,R4	;GET LIBRARY BUFFER PTR
	MOV	LIBBLK,R0		;GET BLK # TO READ
	.READW	3,R4,#512.	;READ LIBRARY FILE
	BCC	1$
	TSTB	@#ERRBYT	;FATAL I/O ERRORS
	BEQ	1$		;NO
	JMP	HARDER
1$:	MOV	EIBUF2,R5	;IND END OF BUFFER ADR
	TST	-(R5)		;MAKE BUF RIGHT SIZE
	MOV	R5,R0
	CLR	(R0)+		;CLEAR END OF BUFFER
	CLR	(R0)+
	RTS	PC
	.SBTTL	SYMBOL TABLE SEARCH ROUTINE

; ENTER WITH R3 POINTING TO 1ST WORD OF SYMBOL TO BE LOOKED UP
; (SYMBOL MUST BE TWO WORDS IN RAD50 NOTATION)
; RETURN WITH R0 POINTING TO SYMBOL TABLE ENTRY
; AND R3 POINTING TO 2ND WORD OF ARGUMENT.

LOOKUP:	MOV	R5,-(SP)
	MOV	(R3)+,R0	;1ST RAD50 WORD
	BEQ	10$		;ITS A BLANK CSECT
	CMP	R0,(PC)+	;.BSECT?
	.RAD50	/. B/
	BNE	3$		;NOPE. TREAT IT AS A NORMAL NAME
	TST	(R3)		;BLANK .BSECT?
	BNE	3$		;YEP. TREAT IT AS NORMAL NAME
	MOV	MODCNT,(R3)	;ELSE USE MODCNT AS PART OF .BSECT NAME
	BR	3$
10$:	MOV	MODCNT,R0	;USE MODULE COUNT FOR BLANK CSECT NAME
	ASL	R0
	ASL	R0
	MOV	R0,-2(R3)
3$:	ADD	@R3,R0		;ADD 2ND WORD OF SYMBOL
	MOV	STDIV,R5	;NORMALIZED SYMBOL TABLE SIZE
1$:	CMP	R5,R0		;CAN SUBTR BE DONE?
	BHI	2$
	SUB	R5,R0
2$:	CLC
	ROR	R5		;SHIFT DIVISOR
	CMP	R0,STSIZE	;SMALLER THAN TABLE SIZE?
	BHIS	1$
	ASL	R0
	ASL	R0
	ASL	R0
	ADD	SYMM6,R0	;CALC ADDR OF TABLE ENTRY
	MOV	STSIZE,R5	;NUMBER OF ENTRIES TO SEARCH
4$:	TST	-(R3)
	TST	@R0		;EMPTY CELL?
	BEQ	8$
	CMP	(R3)+,(R0)+
	BEQ	6$
5$:	DEC	R5
	BEQ	LOOKNO		;ERROR: SYMBOL TABLE FILLED
	ADD	STINCR,R0	;INCREMENT SEARCH POINTER
	CMP	R0,SYMEND
	BLO	4$
	SUB	STLEN,R0
	BR	4$
6$:	CMP	@R3,@R0
	BNE	5$
;AT THIS POINT HAVE FOUND SYMBOL @R0
7$:	ADD	#4,R0		;POINT TO LAST WORD OF NODE
	MOV	(SP)+,R5
	RTS	PC
;HAVE FOUND AN EMPTY LOCATION
8$:	MOV	(R3)+,(R0)+
	MOV	@R3,@R0
	BR	7$
LOOKNO:	ERROR	<SYMBOL TABLE OVERFLOW>
;ROUTINE TO PRINT AN ASCIZ MESSAGE IN THE OUTPUT FILE.
;	ENTER WITH R1 = OUTPUT BUFFER POINTER
;	R5 ARGUMENT AND RETURN POINTER
;	EIBUF1 IS END OF BUFFER
;	R2 IS DESTROYED
PR00:	MOV	(R5)+,R2	;PICK UP MSG ADDRESS
PR01:	MOVB	(R2)+,R0
	BMI	2$
	BEQ	2$
	MAPOUT
	BR	PR01
2$:	RTS	R5

	.ENABL	LSB
MAPOUT:	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;SAVE R1
	MOV	MAPBUF,R1	;FIND ADDRESS OF INPUT BUFFER
	MOVB	R0,(R1)+	;STORE DATA
	CMP	R1,EMAPBU	;BUFFER FULL?
	BLO	1$		;NOPE
	SUB	#512.,R1	;BACK UP TO BEGINING
	.WAIT	1		;MAP FILE REQUESTED?
	BCS	2$		;NO. IGNORE OUTPUT
	.WRITW	1,R1,#400,MAPBLK
	BCC	2$
	ERROR	<MAP FILE ERROR>
2$:	INC	MAPBLK
	MOV	R1,R0
3$:	CLR	(R0)+
	CMP	R0,EMAPBU	;END?
	BLO	3$		;NOPE
1$:	MOV	R1,MAPBUF	;PASS POINTER
	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R0	;RESTORE R0
	RTS	PC
	.DSABL	LSB
	.SBTTL	LISTING ERROR HANDLERS
	.GLOBL IBUFSV

	.ENABL	LSB
LERROR:	BR	5$		;ENTRY TO PRINT REG & MSG
	JSR	R1,SAVREG
	MOV	#7$,R4		;JUST PRINT MSG
	BR	6$
5$:	JSR	R1,SAVREG
	MOV	#UNPHEX,R4
	BR	6$
LERRA:	JSR	R1,SAVREG	;ENTRY TO PRINT MSG & RAD50 SYMBOL
	MOV	#DECODE,R4
	MOV	SP,DCDFLG	;NO TABS
	MOV	R0,R3		;ADDR OF SYMBOL NODE
6$:	MOV	(R5)+,R2	;PICK UP ADDR OF MSG
	MOV	#LINBUF,R1
1$:	MOVB	(R2)+,(R1)+	;COPY MSG TO BUFFER
	BNE	1$
	DEC	R1
	MOVB	#40,(R1)+	;FOLLOW WITH A SPACE
	JSR	PC,@R4		;CALL CONVERSION ROUTINE
	TST	LERRF		;CONTINUE?
	BNE	8$		;YES. NO CRLF RQD
	MOVB	#CR,(R1)+
	MOVB	#LF,(R1)+
8$:	MOVB	#200,(R1)+
	CLR	LERRF		;BURN OUR BRIDGES
	JSR	R5,PR00
	.WORD	LINBUF
	.PRINT	#LINBUF
	MOV	@#MONLOW,R0	;ROM @
	MOVB	MONCOM(R0),R1	;GET ERROR COUNT
	INCB	R1		;COUNT IT
	BMI	7$		;OVERFLOW. IGNORE COUNT
	MOVB	R1,MONCOM(R0)	;PASS ERROR COUNT TO BATCH
7$:	RTS	PC
	.DSABL	LSB

SAVREG:	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	JSR	PC,@R1
	MOV	(SP)+,R4
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	RTS	R5
	.SBTTL	INPUT FILE HANDLERS

;	ROUTINE TO GET NEXT INPUT BYTE INTO R0
BYTE:	CMP	R4,R5	;END OF INPUT BUFFER?
	BLO	1$
	JSR	PC,NEWBUF
1$:	MOVB	(R4)+,R0
	RTS	PC

;	ROUTINE TO GET NEXT FORMATTED BINARY BLOCK FOR INPUT
; ENTER WITH R4 POINTING TO CURRENT BUFFER POSITION
;	     R5 POINTING TO THE BYTE AFTER THE LAST BYTE
;		OF THE CURRENT INPUT BUFFER
;	     CURBUF POINTING TO THE BEGINNING OF CURRENT BUFFER
;	     CURBLK RELATIVE BLOCK NUMBER OF BLOCK BEING READ.
;RETURNS WITH R4 POINTING TO 1ST DATA WORD OF NEW BLOCK
;	      R2 = NUMBER OF DATA BYTES IN THE BLOCK.
;	      R1 AND R3 ARE DESTROYED
;	      R0 = TYPE CODE OF THE BLOCK
NEWBLK:	CMP	R4,R5
	BLO	1$
	JSR	PC,NEWBUF
1$:	TSTB	(R4)+
	BEQ	NEWBLK		;SKIP ALL NULL BYTES
	CMPB	-(R4),#1
	BNE	MODERR		;MODE ERROR, NOT FB BLOCK
	MOV	#2,R0
	MOV	#TEMP,R3
	JSR	PC,GETBYT	;SKIP 2 BYTES & PUT 3RD IN TEMP
	JSR	PC,GT1BYT	;NEXT BYTE IN TEMP+1
	MOV	-(R3),R2	;PICK UP ASSEMBLED LENGTH OF BLOCK
	SUB	#6,R2		;CALC CORRECTED LEN
	JSR	PC,GT1BYT	;GET TYPE BYTE
	JSR	PC,BYTE		;SKIP NULL BYTE
	MOVB	-(R3),R0
	RTS	PC
MODERR:	INC	R4		;SKIP CHARS CAUSING MODE ERR
	BR	NEWBLK

;	ROUTINE TO SKIP NUMBER OF BYTES SPECIFIED BY R0,
;AND THEN PLACE THE NEXT BYTE IN R0 AND AT (R3)+.
GT1BYT:	CLR	R0		;ENTRY TO MAKE R0=0
GETBYT:	MOV	R0,-(SP)
1$:	CMP	R4,R5
	BLO	2$
	JSR	PC,NEWBUF
2$:	MOVB	(R4)+,R0
	DEC	@SP
	BPL	1$
	MOVB	R0,(R3)+
	TST	(SP)+
	RTS	PC
;	ROUTINE TO SWAP INPUT BUFFERS
; UPDATES R4, R5, CURBUF, CURBLK
; DESTROYS R0!!!

NEWBUF:	TSTB	ONEPT		;LIBRARY I/O ?
	BEQ	NEWBF1		;NO
	ADD	#2,LIBBLK	;IND NEXT BLK TO READ
	JSR	PC,GETLIB	;READ LIBRARY FILE
	BR	NBF4
NEWBF1:	MOV	CURBUF,R0	;ADDR OF CURRENT BUFFER
	MOV	#1,-(SP)	;BEGIN SETTING UP READ CALL
	MOV	#256.,-(SP)
	MOV	@R0,-(SP)
	MOV	-(R0),R5	;STATUS OF OTHER BUFFER
	BEQ	1$		;NORMAL CASE
	BMI	NBF2		;END OF PASS
; BUFFER BEGINS AN OVERLAY SECTION SO SET IT UP
	CLR	@R0		;RESET BUFFER STAT
	ASL	R5		;R5 POINTS TO OVERLAY BLOCK
	TSTB	PASS		;DECIDE PASS(0=PASS1)
	BEQ	2$
	TST	(R5)+
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	JSR	PC,DMP0		;UNLOAD LAST TXT BLK
	MOV	@(R5)+,SEGBAS	;BASE ADDR OF OVERLAY LEVEL
	SUB	#2,SEGBAS	;ALLOW FOR ID WORD
	MOV	(R5)+,R4	;SECTION ID #
	.IF DF FB
	INC	RELOVL		;INC REL BLK #
	MOV	R4,RELID1	;SAVE SECTION ID #
	.ENDC
	MOV	(R5)+,SEGBLK	;BASE BLOCK ON OUTPUT FILE
	MOV	R5,ABWMAP	;SET UP NEW BIT MAP
	MOV	SEGBAS,TXTBLK
	MOV	R4,TXTBLK+2	;SECTION ID #
	MOV	#4,TXTLEN
	JSR	PC,DMPA		;OUTPUT LAST OBUF OF OLD LEVEL
				;AND BEGIN NEW OVERLAY LEVEL
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	.IF DF FB
	MOV	OBLK,RLSTRT	;IND START OF OVL FOR REL BLK
	.ENDC
	BR	1$
2$:	MOV	#.OVR,OVFLG	;SET OVERLAY FLAG
	MOV	R5,ENDOL	;START NEW SYMTAB LIST FOR OVERLAY
1$:	MOV	@-(R0),R4	;ADDR OF OTHER BUFFER
	MOV	@R0,BUFADR	;IND BUFFER PTR
	MOV	@-(R0),R5	;END ADDR OF OTHER BUFFER
	MOV	CURBLK,R0
	INC	CURBLK
	.WAIT	3
	BCC	5$
	JMP	ODDRD1
5$:
	EMT	203		;READ CHAN 3
	BCC	NBF3
	JMP	ODDRD
NBF3:	MOV	BUFADR,CURBUF
NBF4:	RTS	PC
NBF2:	CLR	@R0		;CLEAR BUFFER STATUS
	ADD	#8.,SP		;CLEAR THE STACK
	TSTB	PASS		;DECIDE PASS
	BNE	10$
	JMP	EOP1		;GO FINISH UP PASS1
;END OF PASS2; FINISH UP THIS LINK
10$:	JSR	PC,TDMP0	;OUTPUT LAST TXT BLOCK		;###
	TST	ODBLK		;SAVE FILE DESIRED?
	BEQ	2$		;NO
	.IF DF	LDA
	TSTB	LSWIT		;LDA OUTPUT?
	BEQ	4$		;NO
	CLR	R2		;YES, PREPARE TO OUTPUT LAST BUFF
	CLR	R3
	MOV	#BEGBLK+8.,R1	;CREATE A TRANFER BLOCK
	JSR	PC,LDAOUT
	MOV	LDAPTR,R2	;GET OUTPUT PTR
	CMP	R2,#OBUF	;BLOCK EMPTY?
	BEQ	6$		;YES, DONE
3$:	CLRB	(R2)+		;CLEAR REMAINDER OF BUFFER
	CMP	R2,#EOBUF
	BLO	3$
4$:
	.ENDC
	.WRITW	0,#OBUF,#256.,OBLK	;WRITE FINAL BUFFER LOAD
	BCS	HARDER
	.IF DF FB
	JSR	PC,ENDREL	;TERMINATE PREVIOUS REL IF FB LINK
	.ENDC
6$:	.CLOSE	0		;CLOSE BINARY FILE
	BCS	HARDER
2$:	MOV	EMAPBU,R1	;GET MAP BUF ADDR
	SUB	#512.,R1	;BACK UP TO BEGINING
	CMP	R1,MAPBUF	;BUFFER EMPTY?
	BEQ	5$		;YEP
	.WAIT	1		;ANY MAPOUT?
	BCS	5$		;NOPE
	.WRITW	1,R1,#400,MAPBLK	;DUMP LAST BLOCK
	BCS	HARDER
5$:	.CLOSE	1		;AND CLOSE MAP FILE
	BCS	HARDER
	JMP	RESTRT		;BEGIN AGAIN

	.IF DF FB
ENDREL:	TSTB	RSWIT		;FOREGROUND LINK ?
	BEQ	15$		;NO
	MOV	#177776,@RELPTR
	JSR	PC,WRTREL	;WRITE REL BUFFER
15$:	RTS	PC
	.ENDC

; READ/WRITE ERROR RECOVERY

ODDRD1:	ADD	#6,SP		;CLEAN UP STACK AFTER WAIT ERR
ODDRD:	TSTB	@#ERRBYT		;TEST THE MONITER ERROR BYTE
	BNE	HARDER
CLOSE:	.CLOSE	3
	BCS	HARDER
	MOV	R5,-(SP)
	MOV	R1,-(SP)	;SAVE REGS
	MOV	BUFADR,R5
	MOV	FILPT,R1	;PTR TO LAST OPEN FILE
	SUB	#16.,R1		;POINT TO NXT FILE
	MOV	R1,R0		;FOR RESTORE LATER
	TST	-(R1)		;IS THIS THE END ?
	BMI	2$		;YES
	MOV	R0,FILPT	;UPDATE FILE PTR
	TST	-(R1)
	MOV	-(R1),-(R5)	;SET OVERLAY PTR IN BUFFER STATUS
	.REOPEN	3		;REOPEN CHAN 3
	BCS	HARDER		;CAN'T HAPPEN ****************
	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R5
	CLR	CURBLK		;RESET RELATIVE BLK COUNTER
	JMP	NEWBUF		;AND GO READ FROM NEW FILE
2$:	TSTB	PAS1.5		;PASS 1.5 ?
	BLE	3$
	CMP	(SP)+,(SP)+	;POP STACK
	BR	STP1.5
3$:	MOV	#-1,-(R5)	;END OF INPUT INDICATOR
4$:	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R5
	JMP	NBF3		;RETURN TO USE FINAL BUFFER LOAD

HARDER:	ERROR	<HARD I/O ERROR>
EOP1:	TST	(SP)+		;POP RETURN ADDR
	TSTB	PAS1.5		;PASS 1.5 REQUIRED FOR LIBR ?
	BLE	EOP1.5		;NO
STP1.5:	BISB	#200,PAS1.5	;MARK END OF PASS 1.5 NXT TIME
; PASS 1.5 SPECIAL PROCESSING
; IN ORDER TO CORRECTLY PLACE THE UNDEFINED SYMBOLS INTO
; THE ROOT SEGMENT, ALL THE DEFINED SYMBOLS IN THE 
; SYMBOL TABLE MUST HAVE THEIR LINKS ZEROED. PASS 1.5 THEN
; SCANS THE INPUT MODULES AND LIBRARIES, AND PLACES THE RE-
; SOLVED LIBRARY SYMBOLS INTO THE ROOT SEGMENT.
;(NOTE - ENDOL,PTR TO END OF SYMTAB,MUST BE RESET TO PT
; TO THE 1ST SYMBOL)

	MOV	#ASECT,R1	;PT TO ROOT SECTION BLK
	MOV	R1,R4
	MOV	@R1,R1		;GET 1ST SYMB PTR
	MOV	R1,R5
	BR	30$
1$:	MOV	R1,R4		;SAVE SECTION BLK ADR
	MOV	@R1,R1		;GET REL SYMBOL ADR
2$:	BIC	#100007,R1	;MASK OFF SYM PTR INDICATORS
	BEQ	3$		;END OF CHAIN ?
	ADD	SYMM20,R1	;CALC. PTR TO SYMB NODE
30$:	MOV	@R1,R3		;SAVE REL SYM PTR
	CLR	-(R1)		;CLEAR VALUE WORD
	TST	(R1)+
	CLR	@R1		;CLEAR REL PTR WORD
	MOV	R3,R1		;RESTORE REL SYM PTR
	BR	2$
3$:	MOV	R4,R1
	ADD	#26.,R1		;PT TO NXT SECT BLK ON LVL ADR
	MOV	@R1,R1		;ANOTHER SECTION BLK ?
	BNE	1$		;YES
	TST	(R4)+
	MOV	@R4,R4		;GET OVL LVL BLK ADR
	SUB	#6,R4
	MOV	@R4,R4		;GET NXT LVL BLK ADR
	BEQ	10$		;NO - MORE LVL BLKS ?
	SUB	#4,R4
	MOV	@R4,R1		;GET SECT BLKS THIS LVL ADR
	BR	1$
10$:	MOV	R5,ENDOL	;RESET END OF LIST PTR
	MOV	#.CSECT,@R5	;SET CSECT BIT IN ASECT
	CLR	OVFLG		;RESET OVERLAY INDICATOR
	JMP	PASS1		;CALL PASS 1.5
EOP1.5:	JMP	POST		;GO TO POST PASS1 ROUTINE

;	ROUTINE TO SKIP FB BLOCKS ON INPUT
; ENTER WITH POINTER TO BLOCK IN R4
;	     END OF CURRENT INPUT BUFFER IN R5
;	     AND LENGTH OF BLOCK IN R2.
;	     DESTROYS R0!!!
SKPBLK:	INC	R2		;INCLUDE CHECKSUM BYTE
1$:	ADD	R2,R4
	CMP	R4,R5
	BLO	2$
	MOV	R4,R2
	SUB	R5,R2
	JSR	PC,NEWBUF
	BR	1$
2$:	RTS	PC
INIO:	MOV	R0,FILPT
	.REOPEN	3
	MOV	#IBUF1,CURBUF
	CLR	CURBLK
	CLR	IBUF1-2
	CLR	IBUF2-2
	JSR	PC,NEWBUF
	JSR	PC,NEWBUF
	MOV	#1,MODCNT
	RTS	PC

;
;CHECK IF TEXT BLOCK IS ON ODD BOUNDARY, IF SO-MOVE IT BACK
;THEN OUTPUT IT.  TEXT WAS MOVED AT DMPTXT.
;USES R1,R2,R3,R0  (CALLS DMP0)
; OTHER AREAS AFFECTED BY THIS FIX ARE  LOC PA2RLD IN LNKOV4.
;					LOC PA2RLD IN LNKOV5
;					LOC DMPTXT IN LNKOV5
;					LOC NBF2   IN LINK0
;					LOC DMPTXT IN LNKOV4
;
TDMP0:	MOV	#TXTBLK,R1	;ADDR OF TXTBLK 		;###
	BIT	#1,(R1)+	;IS PROG ADDR IN TXTBLK ODD?	;###
	BEQ	7$		;IF EQ-NO			;###
	MOV	TXTLEN,R2	;YES-PUT LENGTH IN R2		;###
8$:	MOVB	1(R1),(R1)+	;MOVE TXT BACK A BYTE(LOWER)	;###
	DEC	R2		;MOVED ALL?			;###
	BGE	8$		;IF GE-NO			;###
7$:	JMP	DMP0		;YES-OUTPUT TEXT BLOCK		;###
ERROR:	.PRINT
	MOV	@#MONLOW,R0
	MOVB	#200,MONCOM(R0)	;PASS HARD ERROR TO BATCH
	JMP	RESTRT
	.SBTTL	DUMP TEXT SUBROUTINE (ROOT SEGMENT)

; COME HERE TO UNLOAD CONTENTS OF TEXT BUFFER
;	THERE ARE FIVE POSSIBLE CASES:
;		1. ALL TXT FALLS BEFORE OBUF WINDOW (A)
;		2. PART OF TXT FALLS BEFORE OBUF (B)
;		3. ALL OF TXT FALLS WITHIN OBUF (C)
;		4. PART OF TXT FALLS AFTER OBUF (D)
;		5. ALL OF TXT FALLS AFTER OBUF (A)

; THIS ROUTINE DISTINGUISHES THE CASES, AND MOVES THE
; WINDOW IF NECESSARY IN ORDER TO DUMP THE CONTENTS OF TXTBLK

DMP0:	MOV	TXTLEN,R2	;AND GET LEN OF OLD BLK
	SUB	#2,R2
	BLE	2$		;EXIT IF NO TXT
	MOV	R2,R3
	MOV	#TXTBLK,R1	;ADDR OF WORD ALIGNED TEXT
	.IF DF LDA
	TSTB	LSWIT
	BEQ	10$
	JMP	LDAOUT
10$:
	.ENDC
	MOV	(R1)+,R0	;R0 = FINAL ABS ADR OF TEXT
	SUB	PADDR,R0	;MAKE RELATIVE TO WINDOW
	BLO	DMPBA		;BRANCH IF CASE A OR B
	ADD	R0,R3		;ADD LENGTH OF TEXT BLK
	SUB	#512.,R3	;MINUS LENGTH OF WINDOW
	BHI	DMPDA		;BRANCH IF CASE A OR D
	ADD	#OBUF,R0	;ENTIRE TXT BLK FITS INTO OBUF
1$:	MOVB	(R1)+,(R0)+	;MOVE TXT BLK TO OUTPUT BUFFER
	DEC	R2
	BNE	1$
2$:	CLR	TXTLEN		;MARK BLOCK EMPTY
	RTS	PC		;RETURN

DMPBA:	ADD	R0,R3		;ANY OF TXT WITHIN WINDOW ?
	BCC	DMPA		;BRANCH IF NOT (CASE A)
	BEQ	DMPA		;ALSO MIGHT BE ZERO
	NEG	R0		;LAST PART OF TXT FITS INTO OBUF
	MOV	R0,TXTLEN	;STORE LEN OF PART THAT DOEN'T FIT
	ADD	R0,R1
	MOV	#OBUF,R0
	BR	DMP4		;GO MOVE PORTION THAT FITS

DMPDA:	CMP	R0,#512.	;ANY OF TXT WITHIN WINDOW
	BHIS	DMPA		;NO
	MOV	R3,TXTLEN	;1ST PART OF TXT FITS INTO OBUF
	SUB	R3,R2		;CALC LEN OF PART THAT FITS
	ADD	#OBUF,R0	;AND ITS ADDR
3$:	MOVB	(R1)+,(R0)+	;MOVE PORTION THAT FITS
	DEC	R2
	BNE	3$
	MOV	#TXTBLK,R0	;NOW MOVE UP REMAINING TXT
	MOV	PADDR,R2
	ADD	#512.,R2
	MOV	R2,(R0)+	;STORE ABS ADR OF REMAINING TXT
DMP4:	MOVB	(R1)+,(R0)+
	DEC	R3
	BNE	DMP4
	ADD	#2,TXTLEN	;ALLOW FOR ADDR WORD

DMPA:	TST	ODBLK
	BEQ	1$
	.WRITE	0,#OBUF,#256.,OBLK	;WRITE OUT OBUF
	BCC	1$
	.IF DF FB
	TSTB	RSWIT		;FOREGROUND LINK ?
	BEQ	10$
	JMP	RELERR
10$:
	.ENDC
	ERROR	<SAV FILE ERR>
1$:	MOV	TXTBLK,R1	;ABS ADDR OF CURRENT TXT
	BIC	#000777,R1	;FIND NEAREST BLK BOUNDARY
	MOV	R1,PADDR	;PROG ADR OF NEW OBUF CONTENTS
	CLRB	R1		;NOW CALC DEV BLK NUMBER
	SWAB	R1		;ALSO CLEARS CARRY BIT
	ROR	R1
	MOV	R1,R0		;PREVENT BIT TABLE OVERFLOW
	MOV	R1,OBLK		;REL BLOCK # OF NEW OBUF
	ASR	R1		;NOW ADDR THE BLOCK BIT MAP
	ASR	R1
	ASR	R1
	ADD	ABWMAP,R1	;ADDR OF BYTE WITHIN MAP
	BIC	#177770,R0	;BIT WITHIN BYTE
	CLR	R2
	SEC
7$:	RORB	R2
	DEC	R0
	BPL	7$
	MOV	#256.,R0
	CLR	-(SP)
	BITB	R2,@R1		;BIT ALREADY SET FOR NEW BLK ?
	BNE	DMREAD		;YES, GO READ BLK FIRST
	BISB	R2,@R1		;SET BIT NOW
DMREAD:	MOV	R0,-(SP)	;WORD COUNT (0 IF SEEK ONLY)
	MOV	#OBUF,-(SP)
	MOV	OBLK,R0
	.WAIT	0
	EMT	200		;READ OR SEEK NEXT BLK
	JMP	DMP0		;GO TRY AGAIN TO UNLOAD TXT

	.SBTTL	LDA OUTPUT ROUTINES

	.IF DF LDA

LDAOUT:	JSR	PC,FBSTRT	;START A FOMATTED BINARY BLK
	ADD	#2,R3
1$:	MOVB	(R1)+,R0		;NEXT BYTE TO BE OUTPUT
	JSR	PC,LDABYT	;WRITE TO OUTPUT
	DEC	R3		;DECREMENT COUNT
	BNE	1$
	JSR	PC,FBFIN	;CLOSE FORMATTED BINARY BLK
	RTS	PC

FBSTRT:	ADD	#6,R2		;CALC ACTUAL LENGHT OF BLK
	MOV	R2,-(SP)	;SAVE LENGTH
	MOV	LDAPTR,R2	;SET UP BUFFER POINTER
	CLR	CKSUM		;INIT THE CHECKSUM
	MOV	#1,R0		;FLAG BEGINNING OF FB BLK
	JSR	PC,LDABYT
	CLR	R0
	JSR	PC,LDABYT
	MOV	@SP,R0
	JSR	PC,LDABYT
	MOV	(SP)+,R0
	SWAB	R0
	JSR	PC,LDABYT
	RTS	PC

FBFIN:	MOV	CKSUM,R0
	NEG	R0
	JSR	PC,LDABYT
	MOV	R2,LDAPTR	;SAVE FINAL BUFFER PT
	RTS	PC

LDABYT:	BIC	#177400,R0	;BYTE TO BE OUTPUT
	ADD	R0,CKSUM
	TST	R2		;LDA OUTPUT FILE ?
	BEQ	10$		;NO
	MOVB	R0,(R2)+	;MOVE TO OUTPUT BUFFER
	CMP	R2,#EOBUF	;BUFFER FULL ?
	BHIS	1$		;YES
10$:	RTS	PC
1$:	MOV	#OBUF,R2
	.WRITW	0,R2,#256.,OBLK
	BCS	2$
	INC	OBLK
	RTS	PC
2$:	ERROR	<LDA FILE ERROR>
	.ENDC	;LDA
	.SBTTL	MOD40 AND OCTAL PRINT ROUTINES

;	MOD40 UNPACKER
; ENTER WITH R1 POINTING TO ASCII CHAR AREA
;		R3 POINTING TO SYMBOL TABLE NODE-2 TO BE UNPACKED
; RO THROUGH R3 ARE CHANGED BY THIS ROUTINE

DECODE:	MOV	R4,-(SP)
	CMP	-(R3),-(R3)
	MOV	#EXPAND,R4	;ADDR OF LIST OF DIVISORS
	MOV	(R3)+,R2
	CMP	R2,(R4)		;BLANK CSECTS GET ALL SPACES
	BLO	8$
2$:	CLR	R0
3$:	CMP	R2,@R4
	BLO	4$
	SUB	@R4,R2
	INC	R0
	BR	3$
1$:	MOV	R2,R0
	MOV	(R3)+,R2
4$:	TSTB	R0		;BLNK ?
	BEQ	5$
	CMPB	R0,#33		;DOLLAR SIGN ?
	BEQ	7$
	BGT	6$		;DIGIT
	ADD	#40,R0		;LETTER
5$:	ADD	#16,R0
6$:	ADD	#11,R0
7$:	ADD	#11,R0
	MOVB	R0,(R1)+
	TST	-(R4)		;MOVE ON TO NEXT DIVISOR
	BGT	2$
	BEQ	1$		;START NEW WORD
9$:	MOV	(SP)+,R4
	TST	DCDFLG		;SPECIAL MODE?
	BNE	10$		;YEP
	MOVB	#11,(R1)+	;FOLLOW WITH A TAB
	RTS	PC

; "NAME" OF BLANK CSECT CAN PRINT UP TO 7 CHARS IF DESIRED.
; MOVE AS MANY CHARS (UP TO 7) AS YOU WISH TO (R1)+ OR CALL
; PRINT (NOT .PRINT) TO DO IT FOR YOU AT LABEL "8$:"

8$:	CMP	(R3)+,(R3)+
	MOV	#5,R0
11$:	MOVB	#SPAC,(R1)+
	DEC	R0
	BPL	11$
	BR	9$

10$:	CLR	DCDFLG		;BURN THE BRIDGE
	RTS	PC		;AND JUST EXIT

	.GLOBL	DCDFLG,LABEL
DCDFLG:	.WORD	0
LABEL:	.BLKB	6
	.BYTE	11,0
;		OCTOUT ROUTINE
; PRINT THE NUMBER IN R0 IN HEX FORM AT THE LOCATION POINTED
; TO BY R1. RO AND R2 DESTROYED. A TAB IS LEFT AFTER THE NUMBER
; MODIFIED FROM ORIGINAL OCTAL OUTPUT 11/20/76 BY D.SHEPPERD

OCTOUT:	MOV	R0,-(SP)	;SAVE R0
	SWAB	R0
	JSR	PC,CVHEX		;CONVERT HIGH BYTE TO HEX
	MAPOUT				;PRINT IT
	SWAB	R0
	MAPOUT
	MOV	(SP)+,R0		;GET INITIAL VALUE
	JSR	PC,CVHEX		;CONVERT LOW BYTE TO HEX
	MAPOUT
	SWAB	R0
	MAPOUT
	MAPOUT	#11		;OUTPUT A TAB
	RTS	PC

CVHEX:	MOV	R0,-(SP)		;PUSH R0
	ASR	R0
	ASR	R0
	ASR	R0
	ASR	R0
	BIC	#-16.,R0
	MOVB	HEX(R0),1(SP)
	MOV	(SP),R0			;GET DATA
	BIC	#-16.,R0
	MOVB	HEX(R0),(SP)
	MOV	(SP)+,R0
	SWAB	R0
	RTS	PC

HEX:	.ASCII	/0123456789ABCDEF/

	.GLOBL	R50MAP,UNPHEX
R50MAP:	MOV	#LABEL,R1
	MOV	SP,DCDFLG	;NO TABS
	JSR	PC,DECODE
	PRINT	LABEL
	RTS	PC

UNPHEX:	MOV	R0,-(SP)
	SWAB	R0
	JSR	PC,CVHEX
	MOVB	R0,(R1)+
	SWAB	R0
	MOVB	R0,(R1)+
	MOV	(SP)+,R0
	JSR	PC,CVHEX
	MOVB	R0,(R1)+
	SWAB	R0
	MOVB	R0,(R1)+
	RTS	PC
;	RPACK SUBROUTINE
; ENTER WITH R5 = NUMBER OF CHARACTERS TO ACCEPT (MAX)
;	R4 = POINTER TO WHER RESULT IS TO BE PLACED
;	R0,R1 ARE DESTROYED
; N CH@RACTERS ARE ACCEPTED FROM THE TTY AND CONVERTED TO 
; RAD50 AND STORED IN THE RESULT LOCATION.

RPACK:	MOV	R3,-(SP)
11$:	MOV	#3,R3
	CLR	R1		;CLEAR RAD 50 WORD
5$:	.TTYIN			;GET NEXT CHAR
	CMPB	R0,#CR		;END OF LINE ?
	BEQ	9$
	CMPB	R0,#40		;BLANK ?
	BEQ	2$
	CMPB	R0,#'$
	BEQ	4$
	CMPB	R0,#'A
	BLO	3$
	SUB	#40,R0
2$:	SUB	#16,R0
3$:	SUB	#11,R0
4$:	SUB	#11,R0
7$:	MOV	R1,-(SP)	;NOW MULT PREV BY 50
	ASL	R1
	ASL	R1
	ADD	(SP)+,R1	;5 * R1
	ASL	R1
	ASL	R1
	ASL	R1		;50 * R1
	ADD	R0,R1		;INCLUDE CURRENT CHAR
	DEC 	R3
	BLE	6$
	DEC	R5		;DONE REQUIRED CHARS ?
	BGT	5$
10$:	CLR	R0		;YES FINISH CURENT WORD ONLY
	BR	7$
6$:	MOV	R1,(R4)+	;STORE A COMPLETED RAD50 WORD
	DEC	R5		;DONE ?
	BGT	11$
8$:	.TTYIN			;SEARCH FOR A LINE TERM
	CMPB	R0,#LF
	BNE	8$
	MOV	(SP)+,R3
	RTS	PC
9$:	CLR	R5		;FOUND CR, FINISH CURRENT WORD
	BR	10$
	.END	START
                                                                                                                                                                  