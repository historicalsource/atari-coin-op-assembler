	.IIF NDF,MACXX,MACXX	=0	;MACRO ASSEMBLER
	.IF EQ,MACXX
	.TITLE RTEXEC MACRO I/O INTERFACES
	.INCLUDE RTPAR
	.ENDC
	.INCLUDE RPARAM
	.INCLUDE RCIOCH
	.SBTTL **********
	.SBTTL * RTEXEC *
	.SBTTL **********

	.GLOBL	START,CONT,FIN,ENDLIN,ERRBTS

MCEXEC=0

	.MCALL	.SETTOP,.WAIT,.CLOSE,.SRESET,.LOOKUP,.CSIGEN
	.MCALL	.PRINT,.DATE,.LOCK,.UNLOCK,.RCTRLO,.CSISPC,.ENTER
	.MCALL	.TTYOUT,.TTYIN,.FETCH,.GTIM
	.MCALL  ..V1..,.DSTAT
	..V1..
...V3	=0		;SET NON ZERO FOR VERSION 3 STUFF

	USRLOC=46
	HIGHAD=50
	EMTERR=52
	MONLOW=54
	CONFIG=300
	MONCOM=356
	JSW=44
	SPAREA=500
	TTYBUF=SPAREA+<39.*2>

	PARAM	STKFDG,60.	;STACK OVERFLOW FUDGE FACTOR

	ENTSEC	IMPUR$
IMPUR$:

	.MACRO	XITSEC		;OVER-RIDE FOR EXEC
	.CSECT	MAIN$
	.ENDM	XITSEC
	XITSEC

	.IF NDF	BRERR		;BRIEF ERRORS?
	.MACRO	SERROR	NUMBER,MESSAGE
	JSR	R0,SERROR
	.ASCIZ	/?'MESSAGE'?/
	.EVEN
	.ENDM	SERROR
	.IFF
	.MACRO	SERROR	NUMBER,MESSAGE
	JSR	R0,SERROR
	.ASCIZ	/?'NUMBER'?/
	.EVEN
	.ENDM	SERROR
	.ENDC

	.MACRO	.FIND	CHAN,FILE
	MOV	FILE,-(SP)
	MOV	CHAN,-(SP)
	JSR	PC,FIND
	.ENDM	.FIND

..T	=1		;JUST FOR BIT SHIFTING
	.IRPC	CHAR,< ABDEILMNOPQRTUZ>
ERR.'CHAR	=..T
..T	=..T+..T
	.ENDR

	.MACRO	ERROR	ARG
	BIS	#ERR.'ARG,ERRBTS
	.ENDM

	.MACRO BITDEF BIT,LABL
...R	=10
	.RADIX 10
...B	=1
	.REPT	BIT
...B	=...B+...B
	.ENDR
LABL	=...B
	.RADIX	...R
	.ENDM

;   BITS IN THE JSW

	BITDEF	15,$USR		;SWAP USR ALWAYS
	BITDEF	14,$LC		;LOWER CASE ENABLE
	BITDEF	13,RENTER	;PGM RE-ENTERABLE
	BITDEF	12,$TTSPC	;TTY SPECIAL
	BITDEF	9,$OVLY		;PGM IS OVERLAYED
	BITDEF	8,$CHAIN	;PGM HAS BEEN CHAINED TO
	BITDEF	7,$HIO		;HALT ON I/O ERRORS
	BITDEF	6,$TTWT		;NO WAIT ON TTY

;   BITS IN THE CONFIG WORD

	BITDEF	15,$KW11	;KW11 INSTALLED AND RUNNING
	BITDEF	11,$1103	;PROCESSOR IS AN 11/03
	BITDEF	9,$USRP		;USR HAS BEEN SET NOSWAP
	BITDEF	8,$GT40C	;A GT40 IS THE SYSTEM CONSOLE
	BITDEF	7,$FGACT	;FOREGROUND IS ACTIVE
	BITDEF	6,$1145		;PROCESSOR HAS FLOATING POINT
	BITDEF	5,$CLK50	;LINE CLOCK IS 50 CYCLES
	BITDEF	3,$BTCH		;BATCH HAS BACKGROUND
	BITDEF	2,$GT40		;SYSTEM HAS A GT40 ON-LINE
	BITDEF	0,$FB		;O.S. IS RT-11FB

MONVER	=276			;SYSTEM RELEASE LEVEL (BYTE)

	.IIF EQ,MACXX-00.,EXTNSN	=50553		;.MAC
	.IIF EQ,MACXX-65.,EXTNSN	=53403		;.M65
	.IIF EQ,MACXX-68.,EXTNSN	=53406		;.M68
	.IIF EQ,MACXX-69.,EXTNSN	=53407		;.M69
	.SBTTL	PROGRAM START

	BR	ERRB		;REENTRY POINT
START:
	.IF DF	TRAPS
	MOV	#TRPPRO,@#34	;SET UP TRAP VECTOR
	CLR	@#36
	.ENDC

; SET UP USR TO LOAD OVER PURE CODE >>>>>>>>>>>>>>>>>>>>>>>>>>>
	MOV	#ASSEM,@#USRLOC

	BIS	#RENTER,@#JSW	;MARK JOB REENTERABLE
	MOV	@#MONLOW,R1	;LOWER LIMIT OF RESIDENT MONITOR
	SUB	#2,R1
	.SETTOP	R1		;EXCISE THE USR
	MOV	@#HIGHAD,STKSAV	;INITIALIZATION FOR STACK
	MOV	PRGLIM+2,R1	;INITIALISE THE STACK LIMIT
	ADD	#STKFDG,R1
	MOV	R1,STKLIM
	.IF DF	FIXSTK
	MOV	#SYMBUE,SYTTOP
	.ENDC
CONT:
	MOV	#IMPUR$,R1	;CLEAR IMPURE AREA
1$:	CLR	(R1)+
	CMP	R1,#IMPURT
	BLO	1$
	CALL	ASSEM		;INITIALIZE SYMBOL ROLLS
	MOV	STKSAV,SP	;INIT THE STACK
	MOV	#CTLTBL,R0
2$:	MOV	(R0)+,R1	;GET ADDR OF NEXT ROUTINE TO EXEC
	MOV	R0,-(SP)	;SAVE POINTER
	CALL	(R1)		;EXEC NEXT ROUTINE
	MOV	(SP)+,R0	;RETRIEVE POINTER
	BR	2$

	ENTSEC	DPURE$
CTLTBL:				;TABLE TO EXEC ASSEMBLER
	.WORD	INIOF,	MACP0
	.WORD	INIP1,	MACP1
	.WORD	FINP1,	ENDP1
	.WORD	INIP2,	MACP2
	.WORD	FINP2,	ENDP2
	.WORD	SETDN		;GO TO RESTART POINT
	XITSEC

ERRB:	JMP	ERR
	.SBTTL	GET COMMAND STRING

	.MCALL	.SERR,.HERR,.TRPSET
	.IF NE,...V3
	.MCALL	.GETLIN
	.ENDC

INIOF:
	DEC	FRECOR		;INITIALIZE FREE CORE COUNT
	MOV	#TTYBUF,R2	;POINT TO INPUT LINE BUFFER
	.TTYOUT	#'*		;PRINT PROMPT
	MOV	MONLOW,R0	;GET ADDR OF RMON
	CMPB	MONVER(R0),#3	;VERSION 3?
	BLO	4$		;NO. MUST BE 2C
	.IF NE,...V3
	.GETLIN	PRGLIM+2,R2	;GET A LINE OF TEXT
2$:	TSTB	(R2)+		;LOOK FOR END
	BNE	2$
	CLRB	-(R2)		;BACK UP
	BR	6$		;CONTINUE
	.ENDC
4$:	.TTYIN			;READ COMMAND STRING
	MOVB	R0,(R2)+	;STORE IN BUFFER
	CMPB	#LF,R0		;END-OF-LINE?
	BNE	4$		;NOPE - CONTINUE
6$:	CLRB	-(R2)		;MAKE ASCIZ FOR CSI
	CLRB	-(R2)
	.GTIM	#IOTWRD		;GET START TIME FOR I/O
	.GTIM	#CPUWRD		;GET START TIME FOR CPU
	.CSISPC	#SPAREA,#DEFEXT,#TTYBUF
	MOVB	EMTERR,R1	;GET ERROR BYTE
	BCC	5$		;ITS OK AS IS
	MOV	CSIERR(R1),R0	;GET ERROR MESSAGE ADDRESS
	JMP	SERROR		;PRINT IT
5$:	MOVB	#CR,(R2)+	;FIX END OF TTYBUF AGAIN
	MOVB	#LF,(R2)+
	CLRB	(R2)+
	MOV	(SP)+,R0	;GET # OF SWITCHES
	.IF NDF	XSWIT
	BEQ	ENDSWT		;NO SWITCHES - JUMP
	MOV	#-1,EXMFLG	;INDICATE SWITCH PROCESSING
SWNEXT:	MOV	(SP)+,R1	;GET NEXT SWITCH
	MOV	#SWTBL,R2	;ADDR OF SWITCH TABLE
10$:	CMPB	(R2)+,R1	;IS THIS THE ONE?
	BEQ	12$		;YUP - GO CALL ROUTINE
	INC	R2		;ELSE POINT TO NEXT TABLE ENTRY
	CMP	#SWTEND,R2	;TABLE EXHAUSTED?
	BNE	10$		;NO - GO BACK
	JMP	SWTERR		;ELSE ERROR - BAD SWITCH
12$:	MOVB	@R2,R2		;GET ROUTINE INDEX
	TST	R1		;WAS VALUE SUPPLIED?
	BMI	13$		;YES - SKIP NEXT
	CLR	-(SP)		;ELSE SUPPLY DEFAULT
13$:	CLR	R3		;CLEAN REGS 3 & 5
	CLR	R5
	JMP	SWTDON+128.(R2)	;BRANCH TO APPROPRIATE ROUTINE
SWTDON:	DEC	R0		;# OF SWITCHES - 1
	BNE	SWNEXT		;GO BACK IF ANY LEFT
	.IFF
	BNE	SWTERR		;NO SWITCHES ARE LEGAL
	.ENDC			;NDF XSWIT
	JMP	ENDSWT		;GO DO I/O STUFF
	.SBTTL	SWITCH HANDLERS
	.GLOBL	SWT.S

SWTERR:	SERROR	BSW,<BAD SWITCH>

	.IF NDF XSWIT

;	LIST/NOLIST SWITCH ROUTINES

SWRN:	COM	R3		;R3 = -1 FOR NLIST
SWRL:	ASL	R3		;R3 = 1  FOR LIST
	INC	R3
	MOV	(SP)+,SYMBOL	;INSTALL SWITCH VALUE IN SYMBOL
	CLR	SYMBOL+2
	MOV	#1,ARGCNT
	MOV	R0,-(SP)	;SAVE # OF SWITCHES LEFT
	CALL	$NLIST		;LET .LIST/.NLIST HANDLER DO THE WORK
	BR	SWTCOM

;	ENABL/DSABL SWITCH ROUTINES

SWRD:	COM	R3		;R3 = -1 FOR DSABL
SWRE:	MOV	(SP)+,SYMBOL	;R3 = 0  FOR ENABL
	CLR	SYMBOL+2
	MOV	R0,-(SP)	;SAVE # OF SWITCHES REMAINING
	CALL	$EDABL		;CALL .ENABL/.DSABL PROCESSOR
SWTCOM:	MOV	(SP)+,R0	;RESTORE # OF SWITCHES
	TST	ERRBTS		;ERROR IN VALUE?
	BNE	SWTERR		;YES
JSWTDN:	JMP	SWTDON		;ELSE WE'RE DONE

	.IF NDF	XCREF
;	CREF SWITCH ROUTINE

SWRC:	MOV	#CRFTAB,R2	;GET ADRS OF VALUE TABLE
1$:	CMP	@SP,(R2)+	;IS THIS THE ONE?
	BEQ	2$		;YES
	TST	(R2)+		;ELSE SKIP FLAG BITS
	TST	@R2		;END OF TABLE?
	BNE	1$		;NOPE
	BR	SWTERR		;ELSE ERROR
2$:	BIS	@R2,CRFFLG	;REMEMBER SECTIONS REQUESTED
PSWV:	TST	(SP)+		;DISCARD SWITCH VALUE
	JMP	SWTDON		;AND LEAVE

SWRS:	MOV	SP,SWT.S	;SUPPRESS DISK SEARCH
	BR	PSWV

	ENTSEC	IMPUR$
CRFFLG:	.WORD	0
CRFTST:	.WORD	0
CRFCNT:	.WORD	0		;# OF REFERENCES MADE IN PASS 1
SWT.S:	.WORD	0
	XITSEC

	.ENDC

	.ENDC

	.SBTTL	/A HANDLER
SWRA:	MOV	#SPAREA,R1	;WORK SPACE
	MOV	SP,SLASHA	;INDICATE /A ENTERED
	TST	(R1)+		;BIN OUTPUT SPECIFIED?
	BNE	1$		;YEP. LEAVE IT ALONE
	MOV	30.(R1),(R1)+	;COPY INPUT FILE NAME TO OBJ SPEC
	MOV	30.(R1),(R1)+
	MOV	DEFEXT+2,(R1)+	;BUT USE DEFAULT EXTENSION
	CLR	(R1)		;USE 1/2 LARGEST SPACE
1$:	MOV	#SPAREA+10.,R1
	TST	(R1)		;LST OUTPUT SPECIFIED?
	BNE	PSWV		;YEP. LEAVE IT ALONE
	MOV	(PC)+,(R1)+	;LST GOES TO DK1
	.RAD50	/DK1/
	MOV	-10.(R1),(R1)+
	MOV	-10.(R1),(R1)+
	MOV	DEFEXT+4,(R1)+	;BUT USE THE DEFAULT EXTENSION
	MOV	#-1,(R1)	;SIZE LARGEST EMPTY SPACE
	BR	PSWV

	ENTSEC IMPUR$
SLASHA:	.WORD 0			;/A ENTERED
	XITSEC

TA:	.BLKW	2
TB:	BIS	R5,2(R3)
	BIS	R5,4(R3)	;SET DX DRIVES OFFLINE
	MOV	SP,R0		;SIGNAL TRAP OCCURED
	RTI
	.PAGE
	.SBTTL	INIT I/O FILES
ENDSWT:	.LOCK			;GET USR
	MOV	#SCHTBL+6,R3	;GET DX NAME ADDRESS
	MOV	PRGLIM+2,R1	;TOP OF PROGRAM
	MOV	#32768.,R5
	BIC	R5,-(R3)	;ENABLE SEARCH OF DX
	BIC	R5,-(R3)
	BIC	R5,-(R3)
	MOV	MONLOW,R0	;GET ADDR OF MONITOR
	BIT	#$1103,CONFIG(R0)	;LSI-11?
	BEQ	1$		;NO. PROCEED
	TST	(R3)+		;YES. TURN OFF SEARCH OF DX
	BIS	R5,(R3)+
	BIS	R5,(R3)
	BR	E.0		;CONITNUE
1$:	.TRPSET	#TA,#TB		;INTERCEPT TRAPS
	CLR	R0
	TST	176000		;CHECK FOR SYKES DRIVE
	TST	R0		;M-TRAP OCCUR?
	BNE	E.0		;YEP. IGNORE DRIVE ON-LINE TEST
	.TRPSET	#TA,#0		;RESET TRAP INTERCEPTS
15$:	.FETCH	R1,R3		;GET DX FOR A SEC
	.SERR			;SOFT LANDINGS FROM HERE ON
	.LOOKUP	0,R3		;DRIVE ON-LINE?
	TSTB	@#EMTERR	;(WE CAN TELL BY HARD ERROR AT THIS POINT)
	BPL	14$		;YEP
	BIS	R5,(R3)		;DRIVE OFF-LINE. SIGNAL SAME
14$:	.SRESET			;START OVER AGAIN
	TST	(R3)+		;NEXT DEVICE
	TST	(R3)		;DONE?
	BPL	15$		;NOPE
	.HERR			;CRASH LANDINGS AGAIN
E.0:	CLR	R5
	MOV	#SPAREA,R3	;GET I/O FILE SPECS
	TST	CRFFLG		;CREF REQUESTED?
	BEQ	5$		;NOPE
	MOV	#SPAREA+20.,R0	;GET CREF FILE ADDRESS
	TST	(R0)		;ALREADY SUPPLIED?
	BNE	5$		;YEP. LEAVE IT ALONE
	MOV	CRFSPC,(R0)+	;MOVE IN CREF FILE DESCRIPTOR
	MOV	CRFSPC+2,(R0)+
	MOV	CRFSPC+4,(R0)+
	MOV	CRFSPC+6,(R0)+
	MOV	#-1,(R0)	;USE THE LARGEST EMPTY SPACE
5$:	TST	(R3)		;CHAN SPECIFIED?
	BEQ	1$		;NOPE
	.FETCH	R1,R3		;GET ITS HANDLER
	BCC	2$		;OK
3$:	MOV	#2,R0		;ILL DEV
12$:	MOV	R0,R1		;SAVE R0
	.UNLOCK			;KICK OUT USR
	MOV	CSIERR(R1),R0	;GET ERROR MESSAGE ADDRESS
	JMP	SERROR
2$:	MOV	R0,R1		;UPDATE HIGH LIMIT
1$:	ADD	FNDX(R5),R3	;NEXT FILE
	CMP	R3,FNDX+2(R5)	;END?
	BLO	5$		;NOPE
	CMP	(R5)+,(R5)+	;R5=R5+4
	TST	FNDX(R5)	;END?
	BNE	5$		;NO
	BIT	SCHTBL+2,SCHTBL+4	;DX ON-LINE?
	BMI	13$		;NO
	.FETCH	R1,#R50DX	;YES. GET DX HAND
	MOV	R0,R1		;UPDATE POINTER
13$:	MOV	#3,R5		;START AT CHAN 3
	MOV	#SPAREA+30.,R3	;NOW WE OPEN INPUTS
11$:	MOV	R3,R0		;NOW WE DO LOOKUPS
	MOV	#EMT+20,-(SP)	;.LOOKUP EMT
	ADD	R5,(SP)		;PUT IN CHAN #
	MOV	(SP)+,(PC)	;XEQ IT
	EMT	20		;*** MODIFIED AT RUN TIME
	BCC	9$		;IT WORKED
	TST	SWT.S		;SUPPRESS CSI FILE SEARCH?
	BNE	10$		;YES.
	.FIND	R5,R3		;TRY AGAIN ON A DIFFERENT DRIVE
	BCC	9$		;IT WORKED
10$:	MOV	#8.,R0		;FNF
	BR	12$
9$:	ADD	#8.,R3		;TO NEXT INPUT
	TST	(R3)		;FILE PRESENT?
	BEQ	4$		;NOPE. WE'RE DONE
	INC	R5		;NEXT CHANNEL
	CMP	R5,#9.		;END?
	BLO	11$		;NOPE
4$:	CLR	R5		;START AT CHAN 0
	MOV	#SPAREA,R3
	TST	(R3)		;ANY BIN?
	BNE	8$		;YEP
	TST	SLASHA		;/A ENTERED?
	BEQ	8$		;NO
	MOV	30.(R3),(R3)	;YES. COPY INPUT DEVICE NAME TO BIN
8$:	TST	(R3)		;FILE PRESENT?
	BEQ	6$		;NOPE
	MOV	8.(R3),-(SP)	;LENGTH => (SP)
	MOV	R3,R0		;DVBLK => R0
	MOV	#EMT+40,-(SP)	;.ENTER EMT
	ADD	R5,(SP)		;PUT IN THE CHAN
	MOV	(SP)+,(PC)	;PUT IT IN EXEC STREAM
	EMT	40		;*** MODIFIED AT RUN TIME
	BCC	6$		;IT WORKED!
7$:	MOV	#6,R0		;DEV FUL
	BR	12$		;ERROR
6$:	ADD	#10.,R3		;NEXT DVCBLK
	INC	R5		;NEXT CHAN
	CMP	R5,#2		;CREF CHAN?
	BNE	14$		;NO. PROCEED
	TST	CRFFLG		;CREF REQUESTED?
	BEQ	6$		;NOPE. SKIP THE OPEN
14$:	CMP	R5,#3		;DONE?
	BLO	8$		;NO.
IIOEND:	.UNLOCK			;DONE WITH THE USR
	.WAIT	0		;CHECK BINARY OUTPUT CHAN
	BCS	1$		;NOT THERE
	BIS	#IO.NNU,IOFTBL+BINCHN
	MOV	R1,PTRTBL+<BINCHN*4>
	MOV	R1,PTRTBL+<RELCHN*4>
	ADD	#512.,R1	;POINT TO END OF BUFFER
	MOV	R1,BLKTBL+<BINCHN*4>	;SAVE BUF ADDR
	MOV	R1,BLKTBL+<RELCHN*4>
1$:	.WAIT	1		;LISTING OUTPUT?
	BCS	3$		;NO
	BIS	#IO.NNU,IOFTBL+LSTCHN
	MOV	R1,PTRTBL+<LSTCHN*4>
	ADD	#512.,R1	;POINT TO END OF BUFFER
	MOV	R1,BLKTBL+<LSTCHN*4>
3$:
	.IF NDF	XCREF
	TST	CRFFLG		;CREF REQUESTED?
	BEQ	2$		;NOPE
	BIS	#IO.NNU,IOFTBL+CRFCHN ;INDICATE CREF FILE PRESENT
	MOV	R1,PTRTBL+<CRFCHN*4>
	ADD	#512.,R1	;ALLOCATE CREF BUFFER
	MOV	R1,BLKTBL+<CRFCHN*4>
	.ENDC
2$:	ADD	#512.,R1	;ALLOCATE SOURCE FILE BUFFER
	MOV	R1,BLKTBL+<SRCCHN*4>
	ADD	#STKFDG,R1	;ALLOW SOME BREATHING ROOM
	MOV	R1,STKLIM	;AND SET STACK LIMIT
	JMP	DATE		;END OF SWITCHES - JUMP AROUND HANDLRS

FIND:	MOV	(SP)+,R0	;GET RETURN ADDRESS
	ADD	#EMT+20,(SP)	;COMPUTE .LOOKUP EMT
	MOV	(SP),1$		;STORE IT IN THE JOB STREAM
	MOV	R1,(SP)		;SAVE THIS REG
	MOV	2(SP),R1	;DVCBLK => R1
	MOV	R0,2(SP)	;SAVE RETURN ADDRESS
	MOV	R2,-(SP)	;SAVE THIS
	CLR	R2		;INDEX STARTS AT 0
	SEC			;IN CASE ALL DRIVES ARE OFFLINE
3$:	MOV	SCHTBL(R2),(R1)	;PUT IN NEW DVC NAME
	BMI	2$		;IGNORE THIS
	BEQ	4$		;FILE NOT FOUND
	MOV	R1,R0
1$:	EMT	20		;.LOOKUP FILE
	BCS	2$		;TRY AGAIN
4$:	MOV	(SP)+,R2
	MOV	(SP)+,R1
	RTS	PC
2$:	INC	R2
	INC	R2
	BR	3$

FNDX:	.WORD	10.,SPAREA+30.
	.WORD	8.,SPAREA+78.
	.WORD	0

SCHTBL:	.RAD50	/DK1/	;SEARCH THESE DRIVES FOR A FILE
	.RAD50	/DX1/
	.RAD50	/DX0/
	.WORD	-1	;TERMINATOR
	.WORD	0	;TERMINATOR
	.PAGE
	.SBTTL	END-OF-PASS ROUTINES
INIP1:				;INITIALIZE PASS 1
	.WAIT	3		;CHECK 1ST INPUT FILE
	BCC	INITI		;OKAY
	SERROR	NIF,<NO INPUT FILE>

INIP2:				;INITIALIZE PASS 2
	.IF NDF XCREF
	MOV	CRFFLG,CRFTST	;ALLOW CREF OUTPUT ON PASS 2
	.ENDC
1$:	CLR	RECNUM+SRCCHN	;INPUT RECORD #
INITI:	MOV	#3,CHAN+SRCCHN	;SET RT11 INPUT CHAN
				;AND INPUT BUFFER POINTER
	MOV	BLKTBL+<SRCCHN*4>,R0
	MOVB	#FF,-(R0)	;START PASS WITH A FORM FEED
	MOV	R0,PTRTBL+<SRCCHN*4>
	MOV	#SSAREA,SSNDX	;RESET INCLUDE, COPY CONTROLS
	CLR	CPYLVL

FINP1:				;FINISH PASS 1
FINP2:	RETURN			;FINISH PASS 2
	.SBTTL	SWITCH AND DATE DATA AREAS

	ENTSEC	DPURE$

	.IF NDF XSWIT

	.MACRO	SWTGEN	SW.NAM
	.ASCII	/SW.NAM/
	.BYTE	SWR'SW.NAM-SWTDON-128.
	.ENDM

	.MACRO	GSWARG	SWARG,SWVAL
	.RAD50	/SWARG/
	.WORD	SWVAL
	.ENDM

	.GLOBL	CRFTAB
	.IF NDF XCREF
CRFS=000002	; SYMBOL CREF DESIRED
CRFR=000004	; REGISTER CREF DESIRED
CRFM=000010	; MACRO  CREF DESIRED
CRFP=000020	; PST    CREF DESIRED
CRFC=000040	; CSECT  CREF DESIRED
CRFE=000100	; ERROR  CREF DESIRED
	.GLOBL	CRFTAB,CRFFLG,CRFTST


CRFTAB:
	GSWARG	< >,CRFS+CRFM+CRFE
	GSWARG	S,CRFS
	GSWARG	R,CRFR
	GSWARG	M,CRFM
	GSWARG	P,CRFP
	GSWARG	C,CRFC
	GSWARG	E,CRFE
	.WORD	0		; END OF TABLE FLAG
CRFPNT:	.WORD	0
	.ENDC


SWTBL:
	SWTGEN	A		;PRODUCE ALL OUTPUT FILES
	.IF NDF XCREF
	SWTGEN	C
	.ENDC
	SWTGEN	D
	SWTGEN	E
	SWTGEN	L
	SWTGEN	N
	SWTGEN	S		;SUPPRESS TTY ERROR OUTPUT ON TTY
SWTEND	= .

	.ENDC

PRGLIM:	.LIMIT
DEFEXT:
	.IF NDF	XMACRO
	.WORD	EXTNSN		;FILE EXTENSION
	.IFF
	.RAD50	/PAL/
	.ENDC
	.RAD50	/OBJ/
	.RAD50	/LST/
	.IF NDF XCREF
	.RAD50	/CRF/
	.IFF
	.WORD	0
	.ENDC

	.IF NDF	XCREF
R50DX:	.RAD50	/DX /

CRFSPC:	.RAD50	/DK /
	.RAD50	/CREF  /
	.RAD50	/TMP/
	.ENDC

	.IF NDF	XTIME
MONTBL:	.ASCIZ	/JAN/		;TABLE OF MONTH NAMES
	.ASCIZ	/FEB/
	.ASCIZ	/MAR/
	.ASCIZ	/APR/
	.ASCIZ	/MAY/
	.ASCIZ	/JUN/
	.ASCIZ	/JUL/
	.ASCIZ	/AUG/
	.ASCIZ	/SEP/
	.ASCIZ	/OCT/
	.ASCIZ	/NOV/
	.ASCIZ	/DEC/
TIMWRD:	.BYTE	0,21		;V2 TIME PARAMETER BLOCK
	.WORD	TIME		;ADRS OF TIME AREA
TIME:	.BLKW	2		;TIME-OF-DAY AREA
	.ENDC
CPUWRD:	.BYTE	0,21
	.WORD	CPUTIM
IOTWRD:	.BYTE	0,21
	.WORD	IOTIME

IOTIME:	.BLKW	2		;THESE 2 AREAS MUST BE TOGETHER
CPUTIM:	.BLKW	2

CSIERR:	.WORD	ILLCMD		;CSI ERROR CODES
	.WORD	ILLDEV
	.WORD	0
	.WORD	DEVFUL
	.WORD	FILNF
ILLCMD:	.ASCIZ	/?ILL CMD?/
ILLDEV:	.ASCIZ	/?ILL DEV?/
DEVFUL:	.ASCIZ	/?DEV FUL?/
FILNF:	.ASCIZ	/?FIL NOT FND?/
	.EVEN

	XITSEC
	.SBTTL	INIT OUTPUT FILES (CONTINUED)
	.ENABL LSB

DATE:	.IF NDF XTIME
	MOV	#TIMWRD,R0	;ADRS OF TIME PARAMETER BLOCK
	.GTIM
	.DATE			;GET CODED DATE INTO R0
	MOV	#DATTIM+1,R2	;CHAR PTR
	MOV	R0,R1		;DATE WORD
	BEQ	5$		;NO DATE, SO SKIP IT
	MOV	R1,-(SP)
	ROL	R1
	ROL	R1
	ROL	R1
	SWAB	R1
	BIC	#177740,R1
	CALL	DNC		;DAY
	MOVB	#'-,(R2)+
	MOV	@SP,R1
	SWAB	R1
	BIC	#177703,R1
	ADD	#MONTBL-4,R1	;POINT TO MONTH
	CALL	MOVBYT
	MOVB	#'-,(R2)+
	MOVB	(SP)+,R1
	BIC	#177740,R1
	ADD	#72.,R1
	CALL	DNC		;YEAR
5$:	MOV	#TIME,R3	;PICK UP TIME OF DAY
	MOV	(R3)+,R0	;HIGH ORDER
	MOV	@R3,R1		;LOW ORDER
	MOV	#IOTIME+2,R4	;COMPUTE DIFFERENCE FROM START
	SUB	(R4),(R3)
	SBC	-(R3)
	SUB	-(R4),(R3)
	MOV	(R3)+,(R4)+	;KEEP DIFFERENCE AT I/O TIME
	MOV	(R3),(R4)
	MOV	#60.,R3		;ASSUME 60 CYCLE CLOCK
	MOV	MONLOW,-(SP)
	ADD	#CONFIG,(SP)
	BIT	#$CLK50,(SP)+	;TRUE?
	BEQ	6$		;YES.
	MOV	#50.,R3		;NO. ITS A 50 CYCLE CLOCK
6$:	CALL	DIV60		;GET RID OF TICKS
UNPTIM:	CALL	DIV60		;GET SECONDS IN R5
	CLR	-(SP)		;STOPPER FOR DIGIT DUMPER
	MOV	R5,-(SP)	;AND SAVE THEM
	CALL	DIV60		;NOW GET MINUTES IN R5
				;AND HOURS IN R1
	MOV	R5,-(SP)	;AND SAVE MINUTES
	MOV	#24.,R3		;ASSURE MIDNIGHT ROLLOVER
	CALL	DIV60		;GET HOURS IN R5
	INC	R2		;LEAVE A BLANK AFTER DATE
8$:	MOVB	R5,(R2)+	;STORE FIRST DIGIT
	SWAB	R5		;GET OTHER ONE
	MOVB	R5,(R2)+	;STORE SECOND ONE
	MOVB	#':,(R2)+	;PUT OUT DELIMITER
	MOV	(SP)+,R5	;GET NEXT SET OF DIGITS
	BNE	8$		;THERE ARE STILL SOME LEFT
	DEC	R2		;SET TO CLOBBER LAST ":"
9$:	CLRB	(R2)+		;MAKE LINE ASCIZ
	RETURN
	.DSABL	LSB

; DIVIDE R0-R1 BY R3, LEAVING REMAINDER IN R5.
; DESTROYS R4,R5.
DIV60:	CLR	R5		;INITIALIZE REMAINDER
	MOV	#32.,R4		;AND COUNT OF BITS
1$:	ASL	R1		;SHIFT LOW ORDER
	ROL	R0		;SHIFT HIGH ORDER
	ROL	R5		;AND REMAINDER
	CMP	R5,R3
	BLO	2$
	SUB	R3,R5
	INC	R1
2$:	DEC	R4
	BNE	1$
3$:	ADD	#366,R5		;APPLY MAGIC NUMBER TRANSFORMATION
	TSTB	R5		;TO GET REMAINDER IN ASCII
	BPL	3$
	ADD	#"00-366,R5
	SWAB	R5
	MOV	#60.,R3		;ASSURE CORRECT DIVISOR
	.ENDC
	RETURN
	.SBTTL	FINISH ASSEMBLY AND RESTART

	.GLOBL	WRNCNT,R50UNP
SETDN:	MOV	#FINMSG,R1
	MOV	#LINBUF,R2
	CALL	MOVBYT		;POSITION MESSAGE
	MOV	ERRCNT,R1
	MOV	MONLOW,R0	;GET RMON @
	MOVB	R1,MONCOM(R0)	;PASS ERROR COUNT TO BATCH
	BIT	#-128.,R1	;OVERFLOW?
	BEQ	2$		;NO
	MOVB	#127.,MONCOM(R0)	;LIMIT BATCH ERROR COUNT TO 127
2$:	CALL	DNC		;DECIMAL NUMBER CONVERTER
	TST	WRNCNT		;ANY WARNINGS?
	BEQ	1$		;NOPE. IGNORE OUTPUT
	MOV	#FINMS3,R1	;YEP. PRINT COUNT
	CALL	MOVBYT
	MOV	WRNCNT,R1
	CALL	DNC
1$:	MOV	#FINMS1,R1
	CALL	MOVBYT
	MOV	FRECOR,R1
	.IF NDF	FIXSTK
	SUB	STKLIM,R1	;CALC FREE CORE
	.IFF
	SUB	#SYMBUF+20.,R1	;CALC FREE CORE
	.ENDC
	ROR	R1		;IN WORDS
	CALL	DNC
	MOV	#FINMS2,R1
	CALL	MOVBYT
	PUTLP	#LINBUF		;PRINT ON LISTING
	PUTLP	#TTYBUF		;ALSO PRINT COMMAND STRING
	CALL	UNP$A		;CONVERT ACTUAL FILE NAMES TO ASCII
	PUTLP	R2		;PRINT THEM
	MOV	R2,-(SP)	;SAVE FREE SPACE POINTER
	MOV	#STATM1,R1	;PRINT STATEMENT COUNT
	CALL	MOVBYT
	CALL	UNPSNM
	MOV	#STATM2,R1
	CALL	MOVBYT
	.GTIM	#TIMWRD		;GET CURRENT TIME
	MOV	#TIME+2,R3	;POINT TO IT
	MOV	#CPUTIM+2,R1	;POINT TO START TIME
	SUB	(R1),(R3)	;COMPUTE CPUTIM=END-START-IOTIME
	SBC	-(R3)
	SUB	-(R1),(R3)+
	SUB	-(R1),(R3)
	SBC	-(R3)
	SUB	-(R1),(R3)
	CALL	TIMOUT		;UNLOAD CPU TIME
	MOV	#TMMSG2,R1
	CALL	MOVBYT		;GET IO TIME MESSAGE
	MOV	#IOTIME,R3	;GET ADDR
	CALL	TIMOUT		;UNLOAD IO TME
	MOVB	#CR,(R2)+	;POLISH OFF LINE
	MOVB	#LF,(R2)+
	CLRB	(R2)+
	PUTLP	(SP)+		;PRINT DATA
FIN:	$FLUSH	LST		;DUMP LAST BUFFERS
	$FLUSH	BIN
	.RCTRLO
	.PRINT	#LINBUF		;PRINT STATISTICS ON TTY
	.IF NDF	XCREF
	$FLUSH	CRF
	TST	CRFFLG		;ANY CREF DESIRED?
	BEQ	FINCL		;NOPE
	MOV	#CHNSPC,R2	;ELSE POINT TO CHAIN INFO
	MOV	(R2)+,R1	;R1 = 500 (.CHAIN AREA)
	MOV	(R2)+,(R1)+	;MOVE IN CREF NAME
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+	;OUTPUT (LST) CHANNEL #
	TST	(R1)+		;OUTPUT DEVICE (SET BY CSISPC)
	BEQ	FINCL		;NO CREF IF NO LISTING DEVICE
	MOV	RECNUM+LSTCHN,(R1)+ ;OUTPUT HIGHEST BLOCK WRITTEN
	MOV	(R2)+,(R1)+	;INPUT (CRF) CHANNEL #
	MOV	(R2)+,(R1)+	;INPUT DEVICE
	MOV	@#<500+<2*10.>>,R0 ;GET DEVICE, IF SPECIFIED
	BEQ	3$		;NOPE - JUST USE DEFAULT
	MOV	R0,-2(R1)	;ELSE PUT IN INTERFACE
3$:	MOV	RECNUM+CRFCHN,(R1)+ ;INPUT HIGHEST BLOCK WRITTEN
	CLR	(R1)+		;LISTING WIDTH FLAG
	BIT	#LC.TTM,LCMASK	;IN .NLIST TTM MODE?
	BEQ	1$		;NOPE
	COM	-2(R1)		;ELSE NOTE
1$:	MOV	(R2)+,(R1)+	;MOVE IN NAME OF RETURN CHAIN
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	MOV	(R2)+,(R1)+
	MOV	@R2,R2		;POINT TO LAST TITLE LINE
2$:	MOVB	(R2)+,(R1)+	;COPY INTO CHAIN AREA
	CMP	R2,TTLBRK	;END OF TITLE?
	BLO	2$		;NOPE - KEEP COPYING
	CLRB	(R1)+		;ASSURE ASCIZ
	$CLOUT	BIN		;ASSURE BINARY CLOSED
	MOV	#10*400,R0	;AND CHAIN TO CREF
	EMT	374
	BR	ERR		;CAN'T HAPPEN (EXCEPT IN DISASTERS)
	.ENDC			;NDF XCREF

FINCL:	.LOCK			;KEEP USR IN CORE
	$CLOUT	BIN		;CLOSE BINARY
	$CLOUT	LST		;AND LISTING
	.UNLOCK			;RELEASE USR
ERR:	.SRESET
	.RCTRLO
	JMP	CONT

SERROR:	.PRINT			;PRINT ERROR MESSAGE
	MOV	MONLOW,R0	;GET RMON @
	MOVB	#128.,MONCOM(R0)	;PASS HARD ERROR FLAG TO BATCH
	BR	ERR

UNP$A:	MOV	SRCDAT+6,R2	;GET SOME WORK AREA
	SUB	#512.,R2	;USE THE SOURCE BUFFER
	MOV	R2,-(SP)	;SAVE THE ADDRESS
	CLR	R5
	MOV	#'(,(R2)	;START WITH OPEN BRACKET
	MOV	#SPAREA,R4	;R50 STUFF LOCATED HERE
3$:	MOV	(R4),SYMBOL	;DVC:
	BEQ	1$		;NO DATA
	CMP	R4,#SPAREA+20.	;CREF FIELD?
	BNE	6$		;NO
	TST	CRFFLG		;CREF REQUESTED?
	BEQ	1$		;NOPE. SKIP LIST
6$:	CLR	SYMBOL+2	;ONLY 3 CHARACTERS
	INC	R2		;SKIP A PLACE
	CALL	R50UNP		;CONVERT DVC NAME TO ASCII
	MOVB	#':,(R2)+	;DVC SEPERATOR
	MOV	2(R4),SYMBOL	;FILE NAME
	MOV	4(R4),SYMBOL+2
	CALL	R50UNP		;CONVERT FILE NAME TO ASCII
	MOV	6(R4),SYMBOL	;EXT
	BEQ	2$		;NO EXT
	CMP	SYMBOL,(PC)+	;DEFAULT?
	.WORD	EXTNSN
	BEQ	2$		;YES. DON'T PRINT IT
	CLR	SYMBOL+2
	MOVB	#'.,(R2)+	;SEPERATOR
	CALL	R50UNP		;CONVERT EXT TO ASCII
2$:	MOVB	#',,(R2)	;SEPERATOR
1$:	ADD	FNDX(R5),R4	;SKIP TO NEXT FILE
	CMP	R4,FNDX+2(R5)	;END?
	BLO	3$		;NO. CONTINUE
	MOVB	#'=,(R2)
	CMP	(R5)+,(R5)+	;R5=R5+4
	TST	FNDX(R5)	;DONE?
	BNE	3$		;NO. CONTINUE
	MOVB	#'),(R2)+	;CLOSE BRACKET
	CLRB	(R2)		;PREPARE TO COMPRESS
	MOV	(SP),R2		;RESET ADDRESS TO BEGINING
	MOV	R2,R1		;KEEP A COPY
5$:	MOVB	(R2)+,(R1)	;SQUEEZE
	BEQ	4$		;DONE
	CMPB	#' ,(R1)	;SPACE?
	BEQ	5$		;YEP. IGNORE IT
	INC	R1		;NO. KEEP IT
	BR	5$		;CONTINUE
4$:	MOVB	#CR,(R2)+
	MOVB	#LF,(R2)+
	CLRB	(R2)
	MOV	(SP)+,R2	;RESET ADDRESS
	RETURN

TIMOUT:	MOV	(R3)+,R0	;HI ORDER
	MOV	(R3),R1		;LO ORDER
	MOV	#6,R3		;DIVIDE IT BY 6
	MOV	MONLOW,-(SP)
	ADD	#CONFIG,(SP)
	BIT	#$CLK50,(SP)+	;60 CYCLE CLOCK?
	BEQ	1$		;YES.
	DEC	R3		;NO. 50 CYCLE CLOCK
1$:	CALL	DIV60
	MOV	#10.,R3		;GET TENTHS OF SECONDS
	CALL	DIV60		;IN R5
	MOV	R5,-(SP)	;SAVE IT
	DEC	R2		;BACK UP OVER NULL CODE
	CALL	UNPTIM		;UNPACK REST OF TIME
	MOVB	#'.,-1(R2)	;CHANGE TERMINATOR TO '.'
	SWAB	(SP)		;GET LS DIGIT
	MOVB	(SP)+,(R2)+	;PUT IT IN
	RETURN

	.GLOBL	SRCCNT

UNPSNM:	MOV	SRCCNT,R0	;PRINT TOTAL STATEMENTS ASSEMBLED
	MOV	SRCCNT+2,R1
	MOV	#10.,R3		;DIVISOR
	CLR	R4		;DIGIT COUNTER
2$:	CALL	DDIV		;DO DOUBLE PRECISION INTEGER DIVIDE
	INC	R4		;COUNT DIGIT
	BIT	#4,R4		;4TH ONE IN A STRING?
	BEQ	1$		;NOPE
	BIS	#100000,R5	;YES. INDICATE TO INSERT A COMMA
	MOV	#1,R4		;RESET R4
1$:	MOV	R5,-(SP)	;SAVE REMAINDER
	MOV	R1,-(SP)
	MOV	R0,(SP)+	;ANY MORE?
	BEQ	3$		;NOPE
	CALL	2$		;YES. RECURSE
3$:	BIS	#'0,(SP)	;ASCIFY DIGIT
	MOVB	(SP),(R2)+	;SEND IT
	TST	(SP)+		;PRUNE STACK
	BPL	4$		;NO COMMA REQUIRED
	MOVB	#54,(R2)+	;INSERT A COMMA
4$:	RETURN

DDIV:	MOV	#31.,-(SP)	;BIT COUNTER
	CLR	R5		;REMAINDER
1$:	ASL	R0		;LSB'S
	ROL	R1		;MSB'S
	ROL	R5		;REMAINDER
	CMP	R5,R3		;ROOM?
	BLO	2$		;NOPE
	SUB	R3,R5		;COMPUTE
	INC	R0		;ACCUMULATE QUOTIENT
2$:	DEC	(SP)		;COUNT
	BPL	1$		;CONTINUE
	TST	(SP)+		;PURGE STACK
	RETURN			;R0,R1 = QUOTIENT; R5 = REMAINDER
	.SBTTL	MEMORY MANAGEMENT
TSTSTK:				;TEST IF STACK OUT OF BOUNDS
	CMP	SP,STKLIM
	BLO	CORERR
	.IF NDF	FIXSTK
	CMP	SP,FRECOR	;NEW RECORD FOR STACK
	BHIS	1$		;NO
	MOV	SP,FRECOR	;YES, RECORD IT
	.IFTF
1$:	RETURN
CORERR:	SERROR	CORE,<INSUFFICIENT CORE>
	.IFF
TSTSYT:				;TEST SYMBOL TABLE
	CMP	ROLBAS,#SYMBUF+20.
	BLO	CORERR
	CMP	ROLBAS,FRECOR	;NEW RECORD FOR TABLE?
	BHIS	1$		;NO
	MOV	ROLBAS,FRECOR	;YES, RECORD IT
1$:	RETURN
	ENTSEC	ROLBAS
ROLBAS:
	.IFTF
	ENTSEC	MIXED$
STKSAV:	.BLKW
STKLIM:	.BLKW
	.IFT
SYTTOP=STKSAV
	.IFF
SYTTOP:	.BLKW
	ENTSEC	SYMBUF
SYMBUF:	.BLKW	4000.		;FIXED SYMBOL TABLE
SYMBUE:
	.ENDC
	ENTSEC	IMPUR$
FRECOR:	.BLKW
	XITSEC
	.SBTTL	GET PHYSICAL SOURCE LINE

	WINST=EMT+240
GETPLI:
	$READW	SRC
	CLR	R0
	BIT	#IO.EOF,IOFTBL+SRCCHN	;END OF FILE?
	BEQ	2$		;NO
	TST	CPYLVL		;'INCLUDE' BEING EXECUTED?
	BEQ	3$		;NO
	CALL	DETACH		;RESET POINTERS
	BR	GETPLI		;RE-TRY WITH NEW POINTERS
3$:	MOV	CHAN+SRCCHN,R0	;GET CURRENT INPUT CHAN
	INC	R0		;MOVE TO NEXT CHAN
	CMP	R0,#8.		;LAST CHAN?
	BHI	1$		;YES, FLAG END OF INPUT
	CLR	RECNUM+SRCCHN	;RESET RECORD (BLK) NUMBER
	MOV	BLKTBL+<SRCCHN*4>,PTRTBL+<SRCCHN*4>
	MOV	R0,CHAN+SRCCHN
	BIS	#WINST,R0	;CREATE A WAIT CALL FOR NEXT CHAN
	MOV	R0,@PC		;AND STORE IN NEXT LOCATION
	.WAIT	0
	BCS	1$		;BRANCH IF NO MORE INPUT
4$:	MOV	#-1,R0		;FLAG END OF FILE
2$:	RETURN
1$:	MOV	#1,R0		;FLAG END OF INPUT
	RETURN
	.SBTTL	SYSTEM MACRO HANDLERS
	.GLOBL	SMDBLK
	.IF NDF	XSML
	.ENABL	LSB
INISML:
	TST	SMLSW		;NEW CALL?
	BNE	FINSML		;NO, EXIT
	INC	SMLSW		;SET SWITCH
	CLR	RECNUM+SMLCHN	;RESET RECORD #
	.WAIT	16		;CHANNEL ALREADY OPEN?
	BCC	1$		;YES
	.LOOKUP	16,#SMDBLK	;LOOK UP SYSTEM MACRO FILE
	BCS	2$		;SOMETHING WRONG
1$:	MOV	#BLKTBL+<SMLCHN*4>,R0
	MOV	@R0,-(R0)	;SET BUF PTR TO EMPTY
	MOV	SP,R0		;SIGNAL GOOD (NON-ZERO) RETURN
	RETURN

2$:	.FIND	#16,#SMDBLK	;TRY AGAIN ON OTHER DRIVES
	BCC	1$	;IT WORKED
FINSML:
	CLR	R0		;SIGNAL DONE
	CLR	SMLSW		;CLEAR SWITCH
	RETURN
	.DSABL	LSB

	ENTSEC	DPURE$
SMDBLK:	.RAD50	/SY /		;DEVBLK FOR SYSTEM MACRO FILE
	.RAD50	/SYSMAC/
	.IF EQ,MACXX
	.RAD50	/SML/
	.IFF
	.WORD	EXTNSN
	.ENDC
	ENTSEC	MIXED$

	.BLKW	256.		;BUFFER FOR SYSTEM MACROS
SMLBLK:
	ENTSEC	IMPUR$
SMLSW:	.BLKW
	XITSEC
	.ENDC
	.SBTTL	WRITE ROUTINES

$WRITW:
$WRITE:	CALL	SAVREG
	BIC	#IO.EOF!IO.ERR,IOFTBL(R0)	;CLEAR FLAGS
	MOV	CNTTBL(R0),R4
	MOV	(R4)+,R1	;ACTUAL BYTE COUNT
	MOV	(R4)+,R2	;LOGICAL BUFFER POINTER
	MOV	(R4)+,R3	;PHYSICAL BUFFER POINTER
; R4 NOW POINTS TO PHYSICAL BUFFER END POINTER
	TSTB	IOLTBL+1(R0)	;BINARY MODE?
	BNE	3$		;YES
1$:	MOVB	(R2)+,(R3)+	;MOVE LINE
	CMP	R3,@R4		;END OF PHYSICAL BUFFER
	BLO	2$		;NO
	CALL	POUT		;YES; PERFORM WRITE
	BCS	WRTERR		;EXIT IF ERRORS
2$:	DEC	R1
	BNE	1$		;LOOP UNTIL LINE FINISHED
	MOV	R3,-(R4)	;UPDATE BUFFER POINTER
	RETURN

; FORMATTED BINARY WRITE
3$:	MOV	#BINCHN,R0
	ADD	#4,R1		;INCLUDE PROTOCOL BYTES IN COUNT
	MOV	R1,-(R2)	;MOVE BYTE COUNT TO BEFORE BUFFER
	TST	-(R2)		;MAKE R2 POINT TO FLAG WORD(1)
	MOV	R5,-(SP)
	CLR	-(SP)
	CLR	R5		;INIT CHECKSUM
4$:	MOVB	(R2)+,@SP
	ADD	@SP,R5		;ADD CHAR TO CKSUM
	MOVB	@SP,(R3)+	;AND MOVE CHAR TO OUTPUT
5$:	CMP	R3,@R4		;OUTPUT BUFFER OVERFLOW?
	BLO	6$		;NO
	CALL	POUT		;YES, DUMP BUFFER
	BCS	WRTERR		;EXIT IF ERRORS
6$:	DEC	R1
	BGT	4$
	BEQ	7$		;GO TO STORE CKSUM
	MOV	R3,PTRTBL+<BINCHN*4>	;UPDATE BUF PTR
	MOV	R3,PTRTBL+<RELCHN*4>	;FOR BOTH BINARY CHNS
	TST	(SP)+
	MOV	(SP)+,R5
	RETURN
7$:	NEG	R5
	MOVB	R5,(R3)+	;STORE CKSUM
	BR	5$
WRTERR:	BIT	#IO.ERR,IOFTBL(R0)	;I/O ERROR?
	BNE	IOERR			;YES - REPORT
	SERROR	ODF,<OUTPUT DEVICE FULL>

IOERR:	MOV	CHAN(R0),R0		;GET CHANNEL OF ERROR
	ADD	#'0,R0			;MAKE ASCII
	MOVB	R0,IOERRN		;AND STORE IN MESSAGE
	JSR	R0,SERROR		;GO PRINT MESSAGE
	.ASCII	"?I/O ERROR ON CHANNEL "
IOERRN:	.ASCIZ	" ?"
	.EVEN
	.SBTTL	COPY,INCLUDE AND DETACH
	.GLOBL INCLU,COPY,FILENM,CPYLVL,LCLVL

COPY:	TST	PASS		;PASS 2?
	BNE	1$		;YES
2$:	CLR	R5		;SO NO 'Q' ERRORS
	RETURN			;IGNORE COPY DURING PASS 1
1$:	TST	LCLVL		;.NLIST IN EFFECT?
	BLT	2$		;YEP. IGNORE COPY
	CALL	SAVREG
	CLR	R3		;NO DEFAULT EXT FOR COPY
	CALL	ATTACH		;ATTACH FILE TO SRC CHAN
	BCS	2$		;ERROR. NO GOOD
	CALL	ENDLIN		;POLISH OFF THE LINE
	MOV	#LSTCHN,R0	;GET LIST INDEX
	MOV	CNTTBL(R0),R4	;GET LISTING CONTROLS ADDRESS
	MOV	#512.,(R4)+	;INIT THE COUNT TO MAX
	MOV	CNTTBL+SRCCHN,R1	;GET SOURCE INPUT CONTROL ADDRESS
	ADD	#6,R1		;SKIP TO INPUT BUFFER ADDRESS
	MOV	(R1),(R4)	;POINT THE OUTPUT TO THE INPUT
	SUB	#512.,(R4)	;BACK UP TO BEGINING OF BUFFER
	MOV	CHAN(R0),R0	;GET LIST CHANNEL #
	ADD	#WINST,R0	;BUILD A .WAIT INSTRUCTION
	MOV	R0,(PC)		;MAKE IT EXECUTABLE
	EMT			;.WAIT LST  (*** MODIFIED AT RUNTIME ***)
	BCS	3$		;NO LIST. JUST EXIT
4$:	MOV	#SRCCHN,R0	;GET SOURCE CHAN INDEX
	MOV	CNTTBL(R0),R4	;SET R4 TO ADDRESS OF STATISTICS
	ADD	#6,R4		;SKIP UP TO BUFFER END POINTER
	CALL	PIN		;READ A BLOCK
	BCS	3$		;EOF OR ERROR
	$WRITW	LST		;PRINT IT
	BR	4$		;CONTINUE
3$:	MOV	#LSTCHN,R0	;RESET THE LISTING CONTROLS
	MOV	CNTTBL(R0),R4
	CLR	(R4)+		;SET COUNT TO 0
	MOV	#LSTBUF,(R4)	;AND LOGICAL POINTER
	CALL	DETACH		;RESTORE SRC STATUS
	BR	2$		;DONE

INCLU:	CALL	SAVREG
	MOV	(PC)+,R3	;SET DEFAULT EXT FOR '.INCLUDE'
	.WORD	EXTNSN
ATTACH:	.GTIM	#TIMWRD		;PREPARE TO TIME THIS
	CALL	TSTARG		;SKIP TO OPERAND
	BNE	1$		;THERE'S ONE PRESENT
3$:	CALL	CPTIOT		;COMPUTE ELAPSED TIME
5$:	ERROR	O
	CLR	R5		;SO NO 'Q' ERRORS
	SEC
	RETURN
1$:	MOV	#WSPC,R1
	CALL	FILENM		;GET R50 FILENAME IN WSPC
	MOV	SSNDX,R2	;SAVSTATUS AREA INDEX => R2
	CMP	R2,#SSEND	;END?
	BHIS	3$		;YEP. NESTING IS TOO DEEP
	.DSTAT	R2,R1		;GET DEVICE STATUS
	BCS	3$		;NO GOOD
	TST	4(R2)		;HANDLER PRESENT?
	BEQ	3$		;NOPE
	MOV	CHAN+SRCCHN,-(SP)	;SRC CHAN # => (SP)
	MOV	R2,R0		;WORK SPACE ADDRESS => R0
	ADD	#EMT+120,(SP)	;COMPUTE A .SAVSTATUS
	MOV	(SP)+,(PC)
	EMT	120		;.SAVSTATUS  (*** MODIFIED AT RUN TIME ***)
	ADD	#10.,R2		;SKIP OVER CHANNEL STATUS
	MOV	RECNUM+SRCCHN,(R2)	;SAVE BLOCK NUMBER
	DEC	(R2)+		;MAKE IT THE CURRENT BLOCK NUMBER
	MOV	SRCDAT+4,(R2)+	;SAVE THE BUFFER POINTER
	MOV	R2,SSNDX	;SAVE POINTER
	INC	CPYLVL		;COUNT LEVEL
	CLR	RECNUM+SRCCHN	;START NEW FILE AT BLOCK 0
	MOV	SRCDAT+6,SRCDAT+4	;WITH BUFFER EMPTY
	MOV	CHAN+SRCCHN,-(SP)
	ADD	#EMT+20,(SP)	;COMPUTE .LOOKUP
	MOV	R1,R0		;FILE SPC => R0
	MOV	(SP)+,(PC)
	EMT	20		;.LOOKUP  (** MODIFIED AT RUNTIME **)
	BCC	4$		;DONE
	.FIND	CHAN+SRCCHN,R1	;TRY AGAIN ON THE OTHER DRIVES
	BCC	4$		;DONE
	CALL	CPTIOT		;COMPUTE I/O TIME
	CALL	DETACH		;ERROR. RESET TO ENTRY
	BR	5$		;AND EXIT WITH ERROR
4$:	CALL	CPTIOT		;COMPUTE I/O TIME
	CLR	R5		;SO NO 'Q' ERRORS
	RETURN			;EXIT W/NO ERROR

DETACH:	CALL	SAVREG		;SAVE ALL THE REGS
	.GTIM	#TIMWRD
	MOV	CHAN+SRCCHN,R0
	ADD	#EMT+160,R0
	MOV	R0,(PC)
	EMT	160		;.CLOSE SRC CHANNEL SOFTLY
	MOV	SSNDX,R2	;GET SAVE AREA ADDRESS
	SUB	#SSZE*2,R2	;BACK UP ONE ENTRY
	MOV	R2,SSNDX	;RESET INDEX
	MOV	CHAN+SRCCHN,-(SP)
	ADD	#EMT+140,(SP)	;COMPUTE .REOPEN
	MOV	R2,R0		;CHAN STATUS ADDRESS => R0
	MOV	(SP)+,(PC)
	EMT	140		;RE-OPEN SRC CHANNEL
	CALL	CPTIOT		;COMPUTE I/O TIME
	MOV	#SRCCHN,R0	;SOURCE CHAN INDEX => R0
	MOV	#SRCDAT+6,R4	;SOURCE BUFFER @ => R4
	ADD	#10.,R2		;SKIP OVER CHAN STATUS
	MOV	(R2)+,RECNUM(R0)	;RESTORE CURRENT BLOCK NUMBER
	CALL	PIN		;GET A FRESH COPY OF BLOCK
	MOV	(R2),SRCDAT+4	;RESTORE POINTER
	DEC	CPYLVL		;BACK OUT 1 LEVEL
	RETURN			;DONE

SSCNT	=5			;LEVELS OF DEPTH ALLOWED
SSNDX:	.WORD	SSAREA		;CURRENT LEVEL INDEX
SSZE	=5+2			;SIZE OF EACH ENTRY IN WORDS
SSAREA:	.BLKW	SSCNT*SSZE	;SAVE STATUS AREA
SSEND:
CPYLVL:	.WORD	0		;DEPTH INDICATOR
WSPC:	.BLKW	4		;SPACE FOR FILE NAME
	.PAGE
	.SBTTL	READ ROUTINE
$READW:
$READ:	CALL	SAVREG
	BIC	#IO.EOF!IO.ERR,IOFTBL(R0)	;CLEAR FLAGS
	CLR	R1		;BYTE COUNT
	MOV	CNTTBL(R0),R4
	TST	(R4)+
	MOV	(R4)+,R2	;LINE BUFFER POINTER
	MOV	(R4)+,R3	;PHYSICAL BUFFER POINTER
; R4 NOW POINTS TO PHYSICAL BUFFER END POINTER
	MOV	R5,-(SP)
1$:	CMP	R3,@R4		;INPUT BUFFER EMPTY?
	BLO	2$		;NO
	CALL	PIN		;YES, FILL IT
	BCC	2$		;BRANCH IF NO ERRORS
	BIT	#IO.EOF,IOFTBL(R0) ;END-OF-FILE?
	BNE	4$		;YES - HANDLE
	JMP	IOERR		;ELSE FATAL - REPORT
2$:	MOVB	(R3)+,R5	;GET NEXT BYTE
	BIC	#177600,R5	;STRIP ASCII TO 7 BITS
	INC	R1		;ASSUME GOOD CHAR
	MOVB	R5,(R2)+	;STUFF IT INTO LINE
	CMPB	R5,#SPACE	;GOOD CHAR?
	BLO	3$		;BRANCH IF SPECIAL CHAR
	CMPB	R5,#173		;IGNORE CHAR?
	BHIS	6$
	CMPB	R1,IOLTBL(R0)	;LINE TOO LONG?
	BLO	1$		;OKAY
	BIS	#IO.ERR,IOFTBL(R0)	;FLAG ERROR
	MOVB	#LF,-(R2)	;INSERT A LINE TERMINATOR
	BR	4$
3$:	CMPB	R5,#LF		;LINE TERMINATOR?
	BNE	5$		;TRY AGAIN
4$:	MOV	R1,@CNTTBL(R0)	;YES, END OF LINE
	MOV	R3,-(R4)	;UPDATE PHYSICAL BUF PTR
	MOV	(SP)+,R5
	RETURN
5$:	CMPB	R5,#CR		;LEAVE <CR> ALONE
	BEQ	1$
	CMPB	R5,#TAB		;LEAVE TABS
	BEQ	1$
	CMPB	R5,#FF		;ALTERNATE LINE TERMINATOR?
	BEQ	4$		;YES
6$:	DEC	R1		;NO, IGNORE ALL OTHER CHARS
	DEC	R2		;REMOVE FROM BUFFER
	BR	1$
	.SBTTL	COMMON I/O ROUTINES

POUT:	MOV	R1,-(SP)
	MOV	#EMT+220,R1	;PLACE WRITE EMT INTO R1
	BR	PIO

PIN:	MOV	R1,-(SP)
	MOV	#EMT+200,R1	;PLACE READ EMT INTO R1
PIO:	MOV	R0,-(SP)
	.GTIM	#TIMWRD		;GET CURRENT TIME
	MOV	(SP),R0		;RESTORE R0
	CLR	-(SP)		;BEGIN SETTING UP MONITOR CALL
	MOV	#256.,-(SP)	;WORD COUNT
	MOV	@R4,R3		;GET BUFFER END POINTER
	SUB	#512.,R3	;NOW POINT TO BEGINNING
	MOV	R3,-(SP)
	ADD	CHAN(R0),R1	;CREATE PROPER EMT
	MOV	RECNUM(R0),R0	;BLOCK NUMBER
	MOV	R1,@PC		;STORE EMT IN NEXT LOCATION
	EMT	220		;MODIFIED AT RUNTIME!!!!!!!!
	ROR	-(SP)		;SAVE CARRY
	CALL	CPTIOT		;COMPUT I/O TIME
	ASL	(SP)+		;RESTORE CARRY
	MOV	(SP)+,R0
	MOV	(SP)+,R1
	INC	RECNUM(R0)
	BCC	$WAIT		;NORMAL RETURN

	TSTB	@#EMTERR	;ZERO IF EOF
	BEQ	2$
	BIS	#IO.ERR,IOFTBL(R0)	;FLAG BAD ERROR
	BR	3$
2$:	BIS	#IO.EOF,IOFTBL(R0)	;FLAG END OF FILE
3$:	SEC
$WAIT:	RETURN

; FLUSH OUTPUT BUFFERS
$FLUSH:	TST	IOFTBL(R0)	;ANYTHING TO DO?
	BEQ	$WAIT
	MOV	CNTTBL(R0),R4
	CMP	(R4)+,(R4)+
	MOV	(R4)+,R3	;BUFFER POINTER
	MOV	@R4,R1		;END OF BUFFER
	MOV	R1,R2
	SUB	#512.,R2	;POINT TO BEGINNING OF BUFF
	CMP	R3,R2		;BUFFER EMPTY?
	BEQ	$WAIT		;YES, JUST CLOSE IT
	BR	2$
1$:	CLRB	(R3)+		;ZERO THE BUFFER FIRST
2$:	CMP	R3,R1
	BLO	1$
	CALL	POUT		;OUTPUT THE LAST BLOCK
	BCC	$WAIT		;REPORT ANY ERRORS
	JMP	WRTERR		; APPROPRIATELY

; CLOSE OUTPUT FILES
$CLOUT:	MOV	#EMT+160,R1	;GET A .CLOSE EMT
	ADD	CHAN(R0),R1	;INSERT THE CHANNEL #
	MOV	R1,@PC		;GHASTLY NON-REENTRANT!!!!
	.CLOSE	0		;*** MODIFIED AT RUNTIME ***
	RETURN

CPTIOT:	MOV	#TIME,R1
	MOV	(R1)+,-(SP)	;SAVE OLD TIME HI
	MOV	(R1),-(SP)	;LO
	.GTIM	#TIMWRD		;GET NEW TIME
	SUB	(SP)+,(R1)	;COMPUTE DIFFERENCE
	SBC	-(R1)
	SUB	(SP)+,(R1)+
	MOV	#IOTIME+2,R0
	ADD	(R1),(R0)	;ACCUMULATE I/O TIME
	ADC	-(R0)
	ADD	-(R1),(R0)
	RETURN
	.SBTTL	MESSAGES

	ENTSEC	MIXED$
	.IF NDF	XTIME
DATTIM:	.ASCII	"          "
TIMTIM:	.ASCIZ	"         "
	.ENDC
FINMSG:	.ASCIZ	/ERRORS DETECTED: /
FINMS1:	.ASCIZ	<CR><LF>/FREE CORE: /
FINMS2:	.ASCIZ	/. WORDS/<CR><LF>
FINMS3:	.ASCIZ	<CR><LF>/WARNINGS DETECTED: /
	.IF EQ,MACXX-68.
HDRTTL:	.ASCII	/ATARI MAC68 VM/
	.ENDC
	.IF EQ,MACXX-65.
HDRTTL:	.ASCII	/ATARI MAC65 VM/
	.ENDC
	.IF EQ,MACXX-69.
HDRTTL:	.ASCII	/ATARI MAC69 VM/
	.ENDC
	.IF EQ,MACXX
HDRTTL:	.ASCII	/RT-11 MACRO VM/
	.ENDC
	GTVNUM			;FOLLOW WITH CURRENT VERSION #
STATM1:	.ASCIZ	<CR><LF>"A TOTAL OF "
STATM2:	.ASCII	" STATEMENTS WERE PROCESSED."<CR><LF>
	.ASCIZ	<CR><LF>"CPU TIME -  "
TMMSG2:	.ASCIZ	"     I/O TIME -  "
	.EVEN
	XITSEC

	.IF NDF	XCREF
	ENTSEC	DPURE$
CHNSPC:	.WORD	500		;CHAIN INFO AREA
	.RAD50	/SY /		;NAME OF CREF
	.RAD50	/CREF  /
	.RAD50	/SAV/
	.WORD	1		;OUTPUT CHANNEL
	.WORD	2		;INPUT CHANNEL
	.RAD50	/DK /		;INPUT DEVICE
	.RAD50	/SY /		;TO CHAIN BACK
	.IF EQ,MACXX-68.
	.RAD50	/MAC68 /
	.ENDC
	.IF EQ,MACXX-65.
	.RAD50	/MAC65/
	.ENDC
	.IF EQ,MACXX-69.
	.RAD50	/MAC69 /
	.ENDC
	.IF EQ,MACXX
	.RAD50	/MACRO/
	.ENDC
	.RAD50	/SAV/
	.WORD	TTLBUF
	XITSEC
	.ENDC
	.SBTTL	I/O TABLES

;IO FLAGS
IO.NNU=	000001		;NON-NULL DEVICE
IO.TTY=	000002		;DEVICE IS TTY
IO.EOF=	000004		;END-OF-FILE
IO.ERR=	000010		;ERROR

	ENTSEC	IMPUR$
IOFTBL:	.BLKW	MAXCHN/2	;I/O FLAG TABLE
RECNUM:	.BLKW	MAXCHN/2	;RECORD NUMBER

	ENTSEC	DPURE$
IOLTBL:
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
	.BYTE	ZBUF'LEN,ZTYPE
	.NLIST
	.ENDM

	GENCHN

CNTTBL:
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
	.WORD	ZCHAN'DAT
	.NLIST
	.ENDM

	GENCHN

BUFTBL:
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
	.WORD	ZBUF'BUF
	.NLIST
	.ENDM

	GENCHN

	ENTSEC	MIXED$
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.IF NZ	ZTYPE
	.LIST
	.WORD	ZTYPE	;PROTOCOL WORDS FOR BINARY OUTPUT
	.WORD	0
	.NLIST
	.ENDC
	.LIST
ZBUF'BUF:	.BLKW	<ZBUF'LEN+1>/2
	.NLIST
	.ENDM

	GENCHN
PTRTBL=	.+4
BLKTBL=	.+6
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
ZCHAN'DAT:	.WORD	0
	.WORD	ZBUF'BUF
	.WORD	0
	.NLIST
	.IF NB	ZBLK
	.LIST
	.WORD	ZBLK'BLK
	.NLIST
	.IFF
	.LIST
	.WORD	0
	.NLIST
	.ENDC
	.LIST

	.NLIST
	.ENDM

	GENCHN
CHAN:
	.MACRO	SETCHN	ZCHAN,ZBUF,ZBLK,ZRTCHN,ZTYPE
	.LIST
	.WORD	ZRTCHN
	.NLIST
	.ENDM

	GENCHN
	.SBTTL	FINIS

	ENTSEC	IMPUR$
IMPURT:

	XITSEC

	.IIF NDF,$$INCL,$$STOP:	.END	START
                                                                                                                                                                                      