	.TITLE MBUCOD
;MICRO CODE FOR 2901 "MATH-BOX"
	.SBTTL ***********************************
	.SBTTL *                                 *
	.SBTTL *PROGRAMMER: MIKE ALBAUGH         *
	.SBTTL *                                 *
	.SBTTL *CHECKED BY:                      *
	.SBTTL *                                 *
	.SBTTL ***********************************
	.RADIX 16
	.NLIST CND,BYT,BEX,BIN
	.LIST MEB,SRC(57.),LOC(9)	;RE-POSITION LOCAION COUNTER
	.ENABL USD		;UN-SIGNED DIVIDES
	.ASECT
	.REPT 0
	
DATE INITIATED: 31-JULY-79
	
PROJECT #: 22903
	
DISK #: 87 & B18
	
HARDWARE REQUIREMENTS:
	MATH-BOX 2901 SYSTEM
	
MEMORY REQUIREMENTS:
	256 X 24 BITS OF MICRO-CODE
	FOR SYSTEM DEVELOPMENT AND
	LISTING PURPOSES, THIS IS MAPPED
	TO 1K BYTES, OF WHICH THE FIRST
	THREE BYTES OF EACH FOUR ARE
	USED. IF THE SYMBOL "ROM" IS
	DEFINED THE CODE WILL ALSO
	BE ASSEMBLED INTO 3 PAGES,
	1 BYTE OF EACH WORD INTO 
	EACH PAGE.
	
INTERRUPT REQUIREMENTS:
	NOT APPLICABLE
	
ASSEMBLY CMD STRING:
	MBUCOD/A
	
LINK CMD STRING:
	PP:/L=MBUCOD,MBULOD
	
PROGRAM DESCRIPTION:
	THIS PROGRAM EMULATES THE MALIBU-
	MATRIX-MULTIPLY AND LONG-DIVIDE
	HARDWARE ON A MICRO-PROGRAMMED
	PROCESSOR BUILT FROM 4 2901'S
	ALL ELSE IS GRAVY.
	.ENDR
	.PAGE
	.SBTTL DEFINITIONS
	.GLOBL PSTART
	.SBTTL	PRIMITIVES
	.MACRO $OUT ...1,...2		;OUTPUT 3 BYTES OF UCODE
	.BYTE ...1&65280./256.,...1&255.,...2
	.IF DF,ROM
.SAVE	=.
.	=.SAVE-3-PSTART/4+RSTART
	.BYTE ...1&65280./256.
.	=.+256.
	.BYTE ...1&255.
.	=.+256.
	.BYTE ...2
.	=.SAVE
	.ENDC
	.BLKB 1				;BUMP TO NEXT /4 LOC.
...RDX	=10		;SAVE RADIX
	.RADIX 10		;DECIMAL
...DAV	=...1/256		;GET BYTE 0
	.PRINT ...1(15,4)	;PRINT BYTE 0,1
	.PRINT ...2(14'[',21']',19,2)
	.PRINT ...DAV/16(23,1)	;A REG
	.PRINT ...DAV&15(25,1)	;B REG
...DAV	=...1&255		;GET BYTE 1
	.PRINT ...DAV/128(28,1)	;I2H
	.PRINT ...DAV/64&1(32,1)	;I2L
	.PRINT ...DAV/16&3(36,1)	;I10
	.PRINT ...DAV/8&1(40,1)	;STALL BIT
	.PRINT ...DAV&7(43,1)	;ALU CODE
	.PRINT ...2/128(47,1)	;LDAB
	.PRINT ...2/16&7(50,1)	;SHIFT
	.PRINT ...2/8&1(54,1)	;SIGN
	.PRINT (/)		;FLUSH LINE QUE
	.RADIX ...RDX		;RESTORE RADIX
	.ENDM $OUT

	.MACRO TTLBLK
	.PRINT (23.'A B I2H I2L SRC ST ALU LD SHFT S')
	.ENDM

	.NLIST
	.MACRO EVAL A,B,C,D,E,F,G,H
	.IF NB,A
	A B C D E F G H
	.IFF				;IF NOTHING LEFT ON LINE
...2	=...2?16.			;DEFAULT DEST=NOP
	$OUT ...1,...2			;OUTPUT CODE
	...1=0				;RESET TEMP DATA
	...2=0
	...M0=0				;RESET TEMP MASK
	...M2=0
	.ENDC
	.ENDM EVAL

	.MACRO TSTCNF M0,M2,D0,D2	;TEST FOR CONFLICT
	.IF NE,M0&...M0!<M2&...M2>	;IF MASKS OVERLAP
	.IF NE,D0-...1!<D2-...2>	;AND DATA IS DIFFERENT
	.ERROR	;CONFLICT IN BYTES
	.WORD ...1,...2
	.WORD ...M0,...M2
	.WORD D0,D2
	.WORD M0,M2
	.=.-16.				;BACKSPACE LOC CTR
	.ENDC				;NE,D0-...1!<D2-...2>
	.ENDC				;NE,M0&...M0!<M2&...M2>
	.ENDM TSTCNF

	.SBTTL	ALU FUNCTIONS

	.MACRO ADD A,B,C,D,E,F,G,H
	EVSRC 0,A B C D E F G H		;FUNC=0
	.ENDM

	.MACRO CADD A,B,C,D,E,F,G,H
...2	=2			;SET "MULT BIT
...M2	=2
	EVSRC 0,A B C D E F G H	;FUNC=0
	.ENDM

	.MACRO SUBR A,B,C,D,E,F,G,H
...2	=1			;SET CARRY
	EVSRC 1,A B C D E F G H
	.ENDM

	.MACRO SUBS A,B,C,D,E,F,G,H
...2	=1			;SET CARRY
	EVSRC 2,A B C D E F G H
	.ENDM

	.MACRO OR A,B,C,D,E,F,G,H
	EVSRC 3,A B C D E F G H
	.ENDM

	.MACRO AND A,B,C,D,E,F,G,H
	EVSRC 4,A B C D E F G H
	.ENDM

	.MACRO BIC A,B,C,D,E,F,G,H
	EVSRC 5,A B C D E F G H
	.ENDM

	.MACRO NOTRS A,B,C,D,E,F,G,H
	EVSRC 5,A B C D E F G H
	.ENDM

	.MACRO EXOR A,B,C,D,E,F,G,H
	EVSRC 6,A B C D E F G H
	.ENDM

	.MACRO EXNOR A,B,C,D,E,F,G,H
	EVSRC 7,A B C D E F G H
	.ENDM

	.MACRO DEC A,B,C,D,E,F,G,H
	EVSRC 1 Z A B C D E F G H	;CLC, SUBR
	.ENDM

	.SBTTL	SOURCE MODES

	.MACRO SOC VAL,MSK
	TSTCNF MSK,0,VAL,0		;TEST FOR BIT CONFLICT
...1	=...1!<'VAL'>
...M0	=...M0!<'MSK'>
	.ENDM

	.MACRO EVSRC OP,.A,.B,.C,.D,.E,.F,.G,.H
...1	=OP!...1
...M0	=7!...M0
	.IF NB,.B
SOMADD	=0
ZDF	=0
	.IF IDN,.B,Q
	.IF IDN,.A,Z
	SOC 32.,240.			;SET ZQ
ZDF	=1
	.ENDC				;IDN,.A,Z
	.IF IDN,.A,D
	SOC 224.,240.			;SET DQ
ZDF	=1
	.ENDC				;IDN,.A,D
	.IF EQ,ZDF			;IF NEITHER D NOR Z
	SOC .A*4096.,61680.		;SET AQ, SET AND PROTECT A ADDR.
	.ENDC				;EQ,ZDF
SOMADD	=1				;SOME ADDRESS MODE USED
	.ENDC				;IDN,.B,Q
	.IF IDN,.A,ZB
	SOC .B*16.+.C*256.+48.,65520.	;SET ZB, SET& PROT A,B
SOMADD	=2
	.ENDC				;IDN,.A,ZB
	.IF IDN,.A,ZA
	SOC .B*16.+.C*256.+192.,65520.	;SET ZA, SET & PROT A,B
SOMADD	=2
	.ENDC				;IDN,.A,ZA
	.IF EQ,SOMADD
	.IF IDN,.A,Z			;IF JUST Z, USE ZB, PROT ONLY B
	SOC .B*256.+48.,4080.
SOMADD	=1
	.ENDC				;IDN,.A,Z
	.IF IDN,.A,D
	.IF IDN,.B,Z
	SOC 240.,240.			;SET DZ
ZDF	=1
SOMADD	=1
	.ENDC				;IDN,.B,Z
	.IF EQ,ZDF			;IF D, NOT Q OR Z
	SOC .B*4096.+208.,61680.		;SET DA,SET & PROT A
SOMADD	=1
	.ENDC				;EQ,ZDF
	.ENDC				;IDN,.A,D
	.ENDC				;EQ, SOMADD
	.IF EQ,SOMADD			;IF NO OTHER MODE
	SOC .A*16.+.B*256.+16.,65520.	;USE AB, SET & PROT A,B
	.ENDC				;EQ,SOMADD
	.IFF				;NB,.B
	.ERROR	;SYNTAX-SOURCE OPERANDS
	.ENDC				;NB,.B
	.IF GT,SOMADD-1
	EVAL .D .E .F .G .H
	.IFF
	EVAL .C .D .E .F .G .H		;PARSE REMAINDER
	.ENDC
	.ENDM EVSRC
	
	.SBTTL	DESTINATION MODES
	.MACRO DOC VAL,MSK
	TSTCNF 0,MSK,0,VAL*16.?16.
...2	=...2!<'VAL'*16.?16.>
...M2	=...M2!<'MSK'>
	.ENDM
	
	.MACRO QREG .D,.E,.F,.G,.H,.I
	DOC 0,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO NOP .D,.E,.F,.G,.H,.I
	DOC 1,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO RAMA .D,.E,.F,.G,.H,.I
	DOC 2,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO RAMF .D,.E,.F,.G,.H,.I
	DOC 3,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO RAMQD .D,.E,.F,.G,.H,.I
	DOC 4,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.MACRO RAMD .D,.E,.F,.G,.H,.I
	DOC 5,112.
	EVAL .D .E .F .G .H
	.ENDM

	.MACRO RAMQU .D,.E,.F,.G,.H,.I
	DOC 6,112.
	EVAL .D .E .F .G .H
	.ENDM

	.MACRO RAMU
	DOC 7,112.
	EVAL .D .E .F .G .H
	.ENDM
	
	.SBTTL	MISC & JMP
	.MACRO LDAB .E,.F,.G,.H,.I
	.IF B,.E			;IF NEXT IS BLANK,
...2	=...2!128.			;JUST SET BIT
...M2	=...M2!128.			;MARK AS USED
	.IFF
	TSTCNF 65280.,128.,.E*256.,128.	;CHECK CONFLICTS
...1	=...1!<.E*256.>			;SET A,B
...M0	=...M0!65280.			;PROTECT A,B
...2	=...2!128.			;SET LDAB BIT
...M2	=...M2!128.			;PROTECT IT
	.ENDC
	EVAL .F .G .H
	.ENDM
	
	.MACRO SIGN .F,.G,.H,.I,.J,.K
	TSTCNF 0,8.,0,8.
...2	=...2!8.
...M2	=...M2!8.
	EVAL .F .G .H
	.ENDM

	.MACRO UNSIGN .F,.G,.H,.I,.J,.K
	TSTCNF 0,8.,0,0
...M2	=...M2!8.
	EVAL .F .G .H
	.ENDM
	
	.MACRO SEC .F,.G,.H,.I,.J,.K
...2	=1!...2
...M2	=1!...M2
	EVAL .F .G .H .I .J .K
	.ENDM

	.MACRO JP .F,.G,.H,.I,.J,.K
...2	=...2!4
...M2	=...M2!4
	.IF NB,.F
	LJT .F,.G,.H			;FORCE LOAD OF TARGET
	.IFF
	EVAL .F .G .H
	.ENDC
	.ENDM
	
	.MACRO JMP .F,.G,.H,.I,.J,.K
	UNSIGN JP,.F .G .H
	.ENDM
	
	.MACRO JPL .F,.G,.H,.I,.J,.K
	SIGN JP,.F .G .H
	.ENDM

	.MACRO LJT .F,.G,.H,.I,.J,.K
	LDAB <'.F-PSTART/4> .G .H
	.ENDM
	
	.MACRO STALL .F,.G,.H,.I,.J,.K
	.IF NE,^C...1&...M0&8
	.ERROR	;-NO STALL ALLOWED
	.IFF
...1	=...1!8.
...M0	=...M0!8.
	.ENDC			;NE,^C...1&...M0&8
	EVAL .F .G .H
	.ENDM

	.MACRO LDH A,B,C,D,E,F,G,H
;LOW- OR Z,B RAMF
;HIGH- OR D,Z RAMF
...1	=A*4352.+179.			;^H1100+^H0B3
...M0	=-1			;^H0FFFF
...2	=32.			;^H20
...M2	=112.			;^H70
	EVAL B C D E F G H
	.ENDM

	.MACRO LDL A,B,C,D,E,F,G,H
;LOW- OR D,Z RAMF
;HIGH- OR Z,B RAMF
...1	=A*4352.+115.			;OR D,0(A=B="A")
...M0	=-1
...2	=32.				;RESULT TO B, WHICH IS "A"
...M2	=112.
	EVAL B C D E F G H
	.ENDM
	.PAGE
	.SBTTL MULTIPLY
;SIGNED MULT MR,Q<-MC*MP
;MC,MP,MR ARE REGS

	.MACRO MULT MC,MP,MR,?A,?B,?C,?D
	LJT A			;PREPARE TO JMP
	OR Z,MP,QREG JPL	;Q:=MP
	SUBS Z,Q,QREG		;Q:=-Q
A:	EXOR MR,MR,RAMQD,UNSIGN	;CLR MR,SHIFTQ
	.REPT 16.
	CADD MC,MR,RAMQD,SIGN
	.ENDR
	LJT B			;PREPARE TO JUMP
	OR Z,MP,JPL		;JMP IF MP +
	EXNOR ZB,MR,MR,RAMA	;COMPLEMENT MR(HI RES)
	EXNOR Z,Q,QREG JPL C	;SKIP IF NEW Q +
	ADD Z,Q,QREG,SEC,JPL D
	JMP B
C:	ADD Z,Q,QREG,SEC,JMP B	;INC Q NO CARRY
D:	ADD ZB,MR,MR,RAMF SEC		;D.P. INC
B:	OR ZB,MR,MR,NOP STALL	;NOP & STALL +,+
	.ENDM
	.LIST
	.PAGE
	.SBTTL MICRO-ROUTINES
PSTART	=8800
RSTART	=8C00
	.=PSTART
MCAND	=0
PROD	=2
DR	=3
DDL	=4
DDH	=5
CONN	=6
CNT	=7
;LOAD ROUTINES FOR REGS 0-15.
RNUM	=0
	TTLBLK
	.REPT 16.
	LDL RNUM
	OR Z,RNUM NOP STALL
	LDH RNUM
	OR Z,RNUM NOP STALL
RNUM	=RNUM+1
	.ENDR
LDQL:	OR D,Q,QREG		;"D" INTO BOTH BYTES OF Q
	...1=64.		;CHANGE BELOW FROM Z,Q TO D,Q ON LOW BYTE
	AND Z,Q,QREG		;CLR HIGH BYTE
DSPQ:	OR Z,Q,NOP STALL	;STALL WITH Q AT OUTPUT
ORQH:	...1=128.		;CHANGE BELOW FROM Z,Q TO D,Q ON HI BYTE
	OR Z,Q,QREG JMP DSPQ	;"OR" IN HIGH BYTE, "DISPLAY"
MULT:	MULT MCAND,MCAND+1,PROD
	.SBTTL DIVIDE
;Assumes DivisoR & DividenD both +, DR>DD
;Does N cycle divide DD(31 bits)/DR(15 bits)
;Stalls with quot in Q and on output

DIVID:	OR ZA,CONN,CNT,RAMF	;SET COUNT
	OR Z,DDL,QREG		;MOV LOW DD TO Q
1$:	LJT 2$
	SUBR DR,DDH JPL		;TRIAL SUB,BPL 2$
	OR Z,DDH,RAMQU		;ELSE JUST SHIFT
	LJT 1$
	DEC CNT RAMF JPL	;SOB CNT,1$
	JMP 3$
2$:	SUBR DR,DDH,RAMQU	;REAL SUB & SHIFT
	ADD Z,Q,QREG,SEC,LJT 1$	;SET QUOT BIT
	DEC CNT RAMF JPL	;SOB CNT 1$
3$:	OR Z,Q,STALL		;STALL WITH OUT=Q
	.END

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             