; 16-JUL-79
; 10:30:00
	.NLIST	TTM,CND,BEX
	.TITLE OPC69 6809 OP CODE PROCESSOR
	.MCALL	.REGDEF
	.REGDEF
	.ENABL	LC
	.REPT	0

The opcode syntax for the 6809 assembler is as follows:

LABEL:	OPCODE	OPERAND		;Comments

The available syntax of the operand(s) is as follows:

null		;Inherent mode (i.e. ABX)
label		;PC relative
@#		;extended mode
#data		;immediate mode
(r)		;Register indirect (0 offset)
@(r)		;Indirect register indirect
(r)+		;Register indirect auto-increment by 1
(r)++		;Register indirect auto-increment by 2
@(r)+		;or
@(r)++		;Indirect register indirect auto-increment by 2
n(r)		;Register indexed. (i.e. EA = n + r where:
		;   n => accumulator A,B or D
		;   n => any other expression)
@n(r)		;Indexed indirect. [i.e. EA = (n + r) where:
		;   n => accumulator A,B or D or
		;   n => any other expression]
-(r)		;Auto-decrement by 1. Register indirect.
--(r)		;Auto-decrement by 2. Register indirect.
@-(r)		;or
@--(r)		;Auto-decrement by 2. Indirect register indirect.

'r' in the above examples may be PC,X,Y,U or S (or the equivalent).

The following is an alternate form of input to specify specific types
of addressing modes:

E,label		;Extended mode
NE,label	;indirect extended
I,data		;Immediate mode
D,label		;Direct page mode
n,label(r)	;and
n,@label(r)	;If n = 5 then forces offset to 5 bit code
		;If n = 8 then forces offset to 8 bit code

	.ENDR
	.PAGE
	.SBTTL MACRO STUFF
	.MCALL	.REGDEF
	.REGDEF

	.MACRO	CALL	OP
	JSR	PC,OP
	.ENDM

	.MACRO	GENCAL	NAME
	.GLOBL	NAME
	.MACRO	NAME
	JSR	PC,NAME
	.ENDM
	.ENDM

	.MACRO	RET
	RTS	PC
	.ENDM

	.MACRO	PUSH	ARG
	.IRP	X,<ARG>
	MOV	X,-(6)
	.ENDR
	.ENDM

	.MACRO	PULL	ARG
	.IRP	X,<ARG>
	MOV	(6.)+,X
	.ENDR
	.ENDM

	.PAGE
	.MACRO	ERROR	CHR
	BIS	#ERR.'CHR,ERRBTS
	.ENDM

...ERR	=1
	.IRPC	X,< ABDEILMNOPQRTUZ>
ERR.'X	=...ERR
...ERR	=...ERR*2
	.ENDR

	GENCAL SETIMM
	GENCAL SETDSP
	GENCAL STCODE
	GENCAL TSTARG
	GENCAL TSTARG
	GENCAL SAVREG
	GENCAL SETXPR
	GENCAL GETSYM
	GENCAL SETSYM
	GENCAL CVTNUM
	GENCAL GLBEXP
	GENCAL STUFPB
	GENCAL GETNB
	GENCAL ABSEXP
	GENCAL SSRCH
	GENCAL GSARG
	GENCAL CRFREF
	GENCAL INSERT
	
	.PAGE
	.GLOBL PCRCNT,BYTMOD,CRFDFL,ROLBAS,CODROL,CRADIX
	.GLOBL	OPCODE,CPOPJ,OPCMAP
	
	.MACRO CHSCAN LABEL
	MOV #LABEL,R0
	CALL CHSCAN
	.ENDM
	
	.GLOBL CHSCAN,VALUE,SYMBOL,MODE,SECTOR,CLCSEC,CLCLOC
	.GLOBL EDBITS,ED.WRN,CLCFGS
	
AM.I	=0001		;IMMEDIATE
AM.D	=0002		;DIRECT
AM.X	=0004		;INDEXED
AM.E	=0010		;EXTENDED
AM.S	=0020		;BRANCH
AM.SPC	=0040		;IMMEDIATE MODE REQUIRES 2 BYTES
AM.SPD	=0100		;DIRECT PAGE HAS UPPER NIBBLE=0
OPC10	=0200		;UPPER BYTE OF OPCODE=10
OPC11	=0400		;UPPER BYTE OF OPCODE=11
AM.SPL	=1000		;LONG BRANCH
	
R.CCR	=1		;CONDITION CODES
R.A	=2		;A
R.B	=4		;B
R.DPR	=10		;DIRECT PAGE
R.X	=20		;X
R.Y	=40		;Y
R.S	=100		;HARDWARE STACK(S)
R.U	=200		;USER STACK(U)
R.PC	=400		;PROGRAM COUNTER
R.D	=1000		;D
	.PAGE
	.SBTTL ENTRY
OPCODE:	MOV	#77776,PCRCNT	;LIST LOCATION OF FIRST WORD ONLY
	BIC	#-256.,R1	;ISOLATE VALUE IN LOW BYTE
	MOV	#OPCMAP,R0	;GET ADDRESS OF AM MAP
	MOV	(R4),(R0)	;GET AM MAP (PASSED TO THIS ROUTINE IN 'VALUE')
	CLR	(R4)		;COVER OUR TRACKS
	ASL	(SP)+		;PRUNE STACK AND TEST SPECIAL BIT
	BPL	6$		;NOTHING TO WORRY ABOUT
	MOV	(R0),R0		;GET INDEX
	CLR	R3		;ZAP THIS FOR ROUTINE'S USE
	JMP	@SPCOPC(R0)	;GO TO ROUTINE
6$:	INC	BYTMOD		;ASSUME BYTE OPCODE
	BIT	#OPC10!OPC11,(R0)	;TRUE?
	BEQ	5$		;YES
	CLR	BYTMOD		;NO. SET WORD MODE
	BIS	#^H1000,R1	;SET IN UPPER BYTE OF OPCODE
	BIT	#OPC11,(R0)	;TRUE?
	BEQ	5$		;YES
	BIS	#400,R1		;NO. SET IN AN '11'
5$:	MOV	R1,(R4)		;PASS NEW OPCODE
	SETIMM			;PREPARE IT FOR OBJECT
	STCODE			;STUFF IT IN OBJECT
	CLR	BYTMOD		;ASSUME OPERAND IS WORD MODE
	CLR	(R4)		;ZAP OLD VALUE
	MOVB	OPCMAP+1,CRFDFL+1	;SEND CREF STUFF TO CREF CONTROL
	TST	OPCMAP		;ANY OPERANDS REQUIRED?
	BEQ	CPOPJ		;NOPE. TAKE ANY EASY EXIT
	SETXPR			;SET REGISTERS
	BIT	#AM.S,OPCMAP	;BRANCH?
	BNE	BRANCH		;YES.
	TSTARG			;SKIP TO OPERAND
	BNE	3$		;THERE'S ONE HERE
	ERROR	A		;N.F.G.
	BIC	#AM.I+AM.SPC+AM.X,OPCMAP	;I OR X ONLY?
	BNE	2$		;NOPE
	MOV	#^H1212,(R4)	;SET NOPS
2$:	SETIMM			;GIVE 'EM 2 BYTES OF ZERO'S
	STCODE
	MOV	#^H30,R0	;OPCODE MODIFIER FOR EXTENDED MODE
	TST	OPCMAP		;I OR X ONLY?
	BNE	4$		;NOPE
	MOV	#^H8012,R0	;YES. INIT R0
	BR	4$
3$:	PUSH	ERRBTS		;SAVE THESE
	CLR	ERRBTS		;AND ZAP THEM FOR OPERAND PROCESSING
	CALL	OPRAND		;DO OPERAND PROCESSING
	BIS	(SP)+,ERRBTS	;MERGE IN OLD ERROR BITS
4$:	MOV	#ROLBAS,R1	;THIS IS BECAUSE THERE IS NO GLOBAL ARITHIMETIC
	ADD	#CODROL,R1
	MOV	(R1),R1		;GET ADDRESS OF OPCODE ENTRY IN CODROL
	TST	R0		;ERROR?
	BMI	7$		;YES
	ADD	6(R1),R0	;COMPUTE NEW OPCODE
7$:	MOVB	R0,6(R1)	;STORE IT BACK
CPOPJ:	RET			;DONE

SPCOPC:	.WORD	EXG
	.WORD	PSHS
	.WORD	PSHU
	.WORD	PULS
	.WORD	PULU
	.WORD	TFR
	.PAGE
	.SBTTL	BRANCH HANDLER
BRANCH:	BIT	#AM.SPL,OPCMAP	;LONG?
	BNE 	1$	;YES.
	INC	BYTMOD	;SHORT
1$:	TSTARG		;SKIP TO OPERAND
	BNE	2$	;THERE'S ONE HERE
4$:	MOV	CLCFGS,(RMODE)	;SET FLAGS AND SECTOR
	MOV	CLCLOC,(R4)	;AND VALUE (THIS CAUSES BR TO SELF)
	ERROR	A	;ERROR
3$:	SETDSP		;DO DISPLACEMENT MODE
	STCODE		;INSERT IN CODROL
	RET		;DONE
2$:	GLBEXP		;GET EXPRESSION
	BIT	#ERR.U,ERRBTS	;ANY UNDEFINED?
	BNE	4$		;YES
	TST	BYTMOD	;16 BIT OFFSET?
	BEQ	3$	;YES. ITS OK AS IS
	BIT	#GLBFLG,(RMODE)	;ANY EXTERNAL?
	BNE	4$	;YES. NO GOOD
	CMPB	CLCSEC,(R2)	;IN CURRENT SECTOR?
	BNE	4$	;NO, NO GOOD
	MOV	(R4),R0	;YES. GET VALUE
	SUB	CLCLOC,R0	;COMPUTE VALUE -.
	SUB	#2,R0	;-2 FOR INSTRUCTION SIZE
	BIC	#127.,R0	;-128 < X < 127 ?
	BEQ	3$	;YES. ITS OK
	ADD	#128.,R0
	BNE	4$	;NO. ERROR
	BR	3$	;YES. DO IT
	.PAGE
	.SBTTL OPERAND PROCESSOR
	.GLOBL	GETNB,ED.AMA,EDMASK,SYMBOL,CHRPNT,ERRBTS

GLBFLG	=100			;GLOBAL
RELFLG	=040			;RELOCATABLE
DEFFLG	=010			;DEFINED
PS1FLG	=200			;UNDEFINED
REGFLG	=001			;REGISTER TYPE

OPRAND:	SAVREG			;SAVE THE REGISTERS
	SETXPR			;INITIALISE THEM (R1) => SYMBOL
				;		 (R2) => SECTOR
				;		 (R3) => MODE
				;		 (R4) => VALUE

RSYM	=R1
RSEC	=R2
RMODE	=R3
RVAL	=R4

	MOV	#^H2000,-(SP)	;ASSUME INDEXED MODE. 0 FLAGS

FG.1M	=001			;BIT 0 - 1 MINUS FOUND
FG.2M	=002			;    1 - 2 MINUS'S FOUND
FG.5	=004			;    2 - 5 BIT OFFSET REQUIRED
FG.8	=010			;    3 - 8 BIT OFFSET REQUIRED
FG.N	=020			;    4 - @ FOUND
FG.O	=040			;    5 - OFFSET PRESENT
				;    15-8 - OPCODE MODIFIER VALUE

	CLR	(RMODE)		;START WITH NOTHING
	CLR	(RVAL)
OPRTN:	CHSCAN	AMOP1		;LOOK FOR SPECIAL STUFF
	BEQ	2$		;DIDN'T FIND ANY
	ASR	R0		;INDEXED?
	BCS	3$		;NOPE
	BIT	#AM.X,OPCMAP	;LEGAL?
	BEQ	ERRA		;NOPE
3$:	ASL	R0		;FIX ADDRESS
	JMP	(R0)		;EXECUTE SPECIALS
2$:	GETSYM			;TRY FOR A SYMBOL
	BEQ	NDX0		;DIDN'T GET ONE. DON'T KNOW WHAT THE HELL IS GOING ON
	CMP	#',,R5		;IS IT REALLY AN ADDRESS MODE SYMBOL?
	BNE	NDXD		;NO. DO INDEXED OPERATION
	MOV	#AMODE,R0	;LOOK FOR AN ADDRESS MODE
1$:	TST	(R0)+		;END OF LIST?
	BEQ	ERRA		;YES. THIS GUY IS A JERK. GIVE 'EM AN ERROR
	CMP	(R1),(R0)+	;MATCH?
	BNE	1$		;NO. CONTINUE LOOKING
	MOV	-4(R0),-(SP)	;SAVE ADDRESS
	TSTARG			;SKIP AM FIELD
	JMP	@(SP)+		;GO TO ROUTINE
ERRA:	ERROR	A		;N.F.G.
ERRR:	MOV	#^H1212,(RVAL)	;GIVE 'EM NOPS
	CLR	(RMODE)
	MOV	#^H8012,(SP)	;SET FLAGS
	BR	IRTN
ERTN:	BIT	#AM.E,OPCMAP	;EXTENDED LEGAL?
	BEQ	IRTN		;NO. LEAVE IT
	BIS	#^H3000,(SP)	;SET OPCODE MODIFIER FOR EXTENDED
IRTN:	SETIMM
DSPRTN:	STCODE
	MOV	(SP)+,R0	;INIT R0 IN CASE OF ERROR
	CMP	R0,#^H8012	;ERROR?
	BEQ	1$		;YES. JUST EXIT
	CLRB	R0		;ZAP LOW BITS
	SWAB	R0		;PUT OPCODE MODIFIER IN LOW BYTE
1$:	RET

AMODE:	.WORD	EXTND
	.RAD50	/E  /
	.WORD	IMM
	.RAD50	/I  /
	.WORD	DIRCT
	.RAD50	/D  /
	.WORD	NEXTD
	.RAD50	/NE /
	.WORD	0		;TERMINATOR

NEXTD:	BIT	#AM.X,OPCMAP	;LEGAL?
	BEQ	ERRA		;NO
	MOV	#^H9F,PBYTE	;SET POST BYTE
	STUFPB			;STUFF IT
	GLBEXP			;EVALUATE EXPRESSION
	BR	IRTN
EXTND:	BIT	#AM.E,OPCMAP	;LEGAL
	BEQ	ERRA
	GLBEXP			;EVALUATE EXPRESSION
	BR	ERTN		;DO QUICK EXIT

IMM:	BIT	#AM.I,OPCMAP	;IMMEDIATE MODE ALLOWED?
	BEQ	ERRA		;NOPE. EXIT
	GLBEXP			;ELSE EVALUATE EXPRESSION
	CLR	(SP)		;ZAP OPCODE MODIFIER AND FLAGS
	BIT	#AM.SPC,OPCMAP	;2 BYTE IMMEDIATE?
	BNE	IRTN		;YES. OK THEN
DRTN:	INC	BYTMOD		;NO. SET BYTE MODE
	BR	IRTN

DIRCT:	BIT	#AM.D,OPCMAP	;DIRECT PAGE ALLOWED?
	BNE	1$		;YES
	ERROR	A		;NOPE
	BR	EXTND		;DO EXTENDED MODE
1$:	GLBEXP			;EVALUATE EXPRESSION
DPGE:	MOV	#^H1000,(SP)	;SIGNAL DIRECT PAGE
	BIT	#AM.SPD,OPCMAP	;SPECIAL DIRECT?
	BEQ	DRTN		;NO
	MOV	#^H0C000,(SP)	;YES. SET SPECIAL CODE
	BR	DRTN

FIVE:	CMP	#',,R5		;IS IT REALLY A 5?
	BNE	NDXD		;NO. DO INDEXED.
	BIS	#FG.5,(SP)	;SIGNAL 5 BIT OFFSET REQUIRED
EIGHT:	CMP	#',,R5		;IS IT REALLY AN 8?
	BNE	NDXD		;NO. DO INDEXED
	TSTARG			;YES. SKIP ADRESS MODE FIELD
	BIS	#FG.8,(SP)	;SIGNAL 8 BIT OFFSET RQD
	BR	NDX0
NDXD:	SETSYM			;RESET POINTERS
NDX0:	MOV	OPCMAP,R0	;GET ADDRESS MODE MAP
	BIC	#AM.I+AM.SPC,R0	;IMMEDIATE MODE THE ONLY ONE?
	BEQ	IMM		;YEP.
	BIT	#AM.X,R0	;IS INDEXED LEGAL HERE?
	BEQ	EXTND		;NO. TRY EXTENDED MODE
	CHSCAN	AMOP2		;LOOK FOR OPERATOR
	BEQ	AMCD		;NONE FOUND
	JMP	(R0)		;GO TO SPECIAL CODE
AM03:	BIS	#FG.N,(SP)	;SIGNAL INDIRECT FOUND
AMCD:	GLBEXP			;TRY FOR AN EXPRESSION
AMPC:	MOV	#^B10001101,PBYTE	;ASSUME PC RELATIVE 16 BIT OFFSET
	CMP	#'(,R5		;IS IT REGISTER INDEXED?
	BEQ	SKPPAR		;YES. SPECIAL STUFF REQUIRED
	BIT	#FG.5,(SP)	;5 BIT OFFSET ASKED FOR?
	BEQ	3$		;NO. ITS OK THEN
6$:	ERROR	A		;GIVE 'EM AN ERROR
	JMP	ERTN		;AND DO EXTENDED
3$:	BIT	#FG.8,(SP)	;8 BIT OFFSET REQUIRED?
	BNE	4$		;YES. FORCE ALLOCATION TO 8 BITS
	BIT	#ERR.A!ERR.U,ERRBTS	;ANY ADDRESS ERRORS?
	BNE	5$		;YES. FORCE IT TO 16 BITS
	BITB	#GLBFLG+PS1FLG,(RMODE)	;ANY EXTERNALS OR FWD RFNCS?
	BNE	5$		;YES. FORCE IT TO 16 BITS
	CMPB	(R2),CLCSEC	;IN CURRENT SECTOR?
	BNE	5$		;NO. DO 16 BIT OFFSET
	MOV	#3,R0		;ASSUME 1 BYTE OPCODE, PBYTE, 1 BYTE OFFSET
	BIT	#OPC10!OPC11,OPCMAP	;TRUE?
	BEQ	7$		;SO FAR, YES
	INC	R0		;16 BIT OPCODE
7$:	ADD	CLCLOC,R0	;COMPUTE UPDATED LOCATION COUNT
	NEG	R0		;COMPUTE DIFFERENCE TARGET-CLCLOC
	ADD	(RVAL),R0
	BIC	#127.,R0	;TRY FOR +127 OR -128
	BEQ	8$		;OK TO DO 8 BIT OFFSET
	ADD	#128.,R0	;-128.?
	BNE	5$		;NOPE. DO 16 BIT OFFSET
8$:	BIT	#PS1FLG,(RMODE)	;ANY FORWARD REFERENCES?
	BEQ	4$		;NO. GO AHEAD AND DO 8 BIT OFFSET
	BIT	#ED.WRN,EDBITS	;OFFSET WARNINIGS ENABLED?
	BNE	5$		;NO. DO 16 BIT OFFSET
	ERROR	<>		;GIVE 'EM A WARNINIG
	BR	5$		;AND DO 16 BIT OFFSET
4$:	INC	BYTMOD		;SET BYTE MODE
	DEC	PBYTE		;ADJUST POST BYTE
5$:	STUFPB			;STUFF IN POST BYTE
	SETDSP			;SET DISPLACEMENT MODE
	JMP	DSPRTN		;PUT IN OBJECT ROL AND EXIT

AMOP1:	.WORD	AM00+1,'#	;IMMEDIATE
	.WORD	AM01,'@		;INDIRECT
	.WORD	AM02,'-		;AUTO-DEC
	.WORD	REXP,'(		;REGISTER-IND
	.WORD	FIVE,'5		;5 BIT OFFSET
	.WORD	EIGHT,'8	;8 BIT OFFSET
	.WORD	0		;TERMINATOR

AMOP2:	.WORD	AM03,'@
	.WORD	AM02,'-
	.WORD	REXP,'(
	.WORD	0

AM00:	BIT	#FG.N,(SP)	;@ FOUND?
	BEQ	1$		;NO. DO IMMEAD
	JMP	EXTND		;YES. DO EXTENDED
1$:	JMP	IMM

AM01:	BIS	#FG.N,(SP)	;SAY @ FOUND
	JMP	OPRTN		;CONTINUE

AM02:	CMPB	#'-,R5		;IS IT AUTO-DEC BY 2?
	BNE	2$		;NO
	ADD	#FG.1M,(SP)	;COUNT IT
	GETNB			;SKIP IT
2$:	CMPB	#'(,R5		;IS IT REALLY AUTO-DEC?
	BEQ	3$		;YEP. ALL IS PEACHY
	BIT	#FG.1M+FG.2M,(SP)	;WHAT THE HELL IS GOING ON?
	BEQ	4$		;DON'T KNOW. CONTINUE LOOKING
	JMP	ERRA		;THIS IS BAD NEWS
4$:	SETSYM			;RESET POINTERS
	BR	AMCD		;DO EXPRESSION
3$:	ADD	#FG.1M,(SP)	;COUNT IT
SKPPAR:	GETNB			;SKIP OVER -

REXP:	MOV	#^B10000100,PBYTE	;INIT TO (R)
	MOV	(RMODE),R0	;ANY OFFSET?
	BIS	(RVAL),R0
	BEQ	1$		;NOPE. DO (R)
	BIS	#FG.O,(SP)	;SIGNAL OFFSET PRESENT
	PULL	R0		;SAVE FLAGS
	PUSH	<(R4),-(R4),-(R4),-(R4),R0>	;SAVE OFFSET AND FLAGS
1$:	ABSEXP			;GET REGISTER TYPE
	CMPB	#'),R5		;HAPPY ENDING?
	BNE	2$		;NO. ERROR
	GETNB			;SKIP )
2$:	BIT	#FG.1M!FG.2M!FG.O,(SP)	;ANY OFFSET OR AUTO-DEC STUFF?
	BNE	3$		;YEP. CAN'T HAVE AUTO-INCREMENT TOO.
	CMPB	#'+,R5		;AUTO-INC?
	BNE	3$		;NO.
	GETNB			;YES. SKIP +
	MOV	#200,PBYTE	;START WITH NEW PBYTE
	CMPB	#'+,R5		;AUTO-INC BY 2?
	BNE	10$		;NOPE
	INC	PBYTE		;YEP
	GETNB			;SKIP SECOND +
10$:	BIT	#FG.N,(SP)	;@ MODE?
	BEQ	3$		;NOPE. OK AS IS
	BISB	#1,PBYTE	;FORCE ++
3$:	MOV	VALUE,R0		;GET REGISTER
	BIT	#FG.O,(SP)	;OFFSET SUPPLIED?
	BEQ	8$		;NO
	MOV	(SP)+,R1	;YES. SAVE OFFSET STUFF AND MOVE FLAGS TO (SP)
	PULL	<(R4)+,(R4)+,(R4)+,(R4)>	;SAVE OFFSET
	MOV	R1,-(SP)	;SET FLAGS
8$:	CLR	R1		;START INDEX AT 0
6$:	ROR	R0		;FIND BIT
	BCS	5$		;FOUND IT
	BEQ	4$		;N.F.G.
	INC	R1
	BR	6$		;CONTINUE
5$:	BNE	4$		;TOO MANY BITS. ERROR.
	MOVB	RX(R1),R1	;GET DECODED REGISTER NUMBER
	BPL	7$		;ITS X,Y,U OR S
	ASLB	R1		;PC?
	BMI	4$		;NO. ERROR INVALID REGISTER
	BIT	#FG.O,(SP)	;ANY OFFSET?
	BEQ	4$		;NO
	JMP	AMPC		;YES. DO PC RELATIVE
4$:	CLR	R1		;SET TYPE TO 0
	ERROR	R
7$:	BISB	R1,PBYTE	;PUT IN REGISTER CODE
	MOV	PBYTE,R0	;GET POST BYTE
	BIC	#15.,R0		;ZAP LOWER BITS
	BIT	#FG.O,(SP)	;ANY OFFSET?
	BNE	OFFSET		;YES. DO OFFSET FUNCTION
	BIT	#FG.1M+FG.2M,(SP)	;AUTO-DECREMENT DETECTED?
	BEQ	9$		;NO. CONTINUE
	BIS	#3,R0		;SELECT AUTO-DEC BY 2
	BIT	#FG.N+FG.2M,(SP)	;INDIRECT OR AUTO-DEC BY 2?
	BNE	11$		;YES. CONTINUE
	DEC	R0		;NO. AUTO-DEC BY 1. ADJUST PBYTE
11$:	MOV	R0,PBYTE
9$:
STICK:	STUFPB			;PUT PBYTE INTO CODROL
	PULL	R0		;GET FLAGS
	CLRB	R0
	SWAB	R0		;PUT THEM IN LOW BYTE
	RET
OFFSET:	BIS	#9.,R0		;SET OFFSET MODE TO 16 BITS
	MOV	R0,PBYTE	;SAVE UPDATED PBYTE
	BITB	#REGFLG,(RMODE)	;OFFSET A REGISTER?
	BEQ	1$		;NOPE
	CLR	R1
	MOV	(RVAL),R0		;GET REGISTER VALUE
	BEQ	3$		;THERE'S NO BIT
4$:	ROR	R0		;LOOK FOR REGISTER BIT
	BCS	2$		;FOUND IT
	INC	R1
	BR	4$
2$:	BNE	3$		;SHOULD ONLY BE 1 BIT
	MOVB	RX(R1),R1	;DECODE REGISTER
	BIC	#-16.,R1	;LEGAL REG(REG)
	BEQ	3$		;NOPE
	BIC	#15.,PBYTE	;CLEAR OUT OLD DATA FROM PBYTE
	BIS	R1,PBYTE	;PUT IN NEW DATA
10$:	BR	STICK
3$:	ERROR	R
	CLR	(RVAL)		;ZAP ANY GIVEN OFFSET
1$:	MOV	(RVAL),R0	;GET GIVEN OFFSET
	BIT	#FG.5,(SP)	;FORCED TO 5 BIT CODE?
	BNE	8$		;YES. GIVE 'EM 5 BITS
	BIT	#FG.8,(SP)	;FORCED TO 8 BIT CODE?
	BNE	9$		;YES. GIVE 'EM 8 BITS
	BITB	#GLBFLG+RELFLG+PS1FLG,(RMODE) ;EXTERNAL OR RELOCATABLE OR UNDEF?
	BNE	5$		;YEP. DO 16 BITS
	TST	R0		;VALUE?
	BNE	6$		;ITS NOT 0(R)
	BIC	#15.,PBYTE	;OUT WITH OLD
	BIS	#4,PBYTE	;IN WITH NEW
	BR	STICK		;(R) MODE
6$:	BIT	#FG.N,(SP)		;INDIRECT?
	BNE	7$		;YES. DON'T TRY FOR 5 BITS
	CMP	R0,#15.		;WILL IT FIT IN 5 BITS?
	BLOS	8$		;YES
	CMP	R0,#-16.	;CHECK THE OTHER SIDE
	BLO	7$		;TRY FOR 8 BITS
8$:	BIC	#-32.,R0	;MASK TO 5 BITS
	BIC	#200+31.,PBYTE	;MAKE ROOM IN PBYTE FOR NEW DATA
	BIS	R0,PBYTE	;SELECT 5 BIT OFFSET
	BR	10$
7$:	CMP	R0,#127.	;WILL IT FIT IN 8 BITS
	BLOS	9$		;YES.
	CMP	R0,#-128.	;CHECK OTHER SIDE
	BLO	5$		;NO. DO 16 BITS
9$:	DEC	PBYTE		;ADJUST PBYTE
	INC	BYTMOD		;SET TO BYTEMOD
5$:	STUFPB
	JMP	IRTN		;DO IMMEDIATE MODE RETURN

RX:	.BYTE	300,306,305,300,0,40,140,100,200,313
	.BYTE	300,300,300,300,300,300		;ROUND OFF TO 16 PLACES

OPCMAP:	.WORD	0		;ADDRESS MODE MAP GOES HERE
PBYTE:	.WORD	0		;POST BYTE IS CONSTRUCTED HERE

	.PAGE
STUFPB:	MOV	2(SP),R0	;GET FLAGS
	BICB	#^C<FG.N>,R0	;ZAP ALL BUT @ BIT
	BIS	PBYTE,R0	;PUT PBYTE INTO R0
	BIT	#OPC10!OPC11,OPCMAP	;16 BIT OPCODE?
	BNE	1$		;YES. PUT PBYTE SEPERATE
	MOV	R1,-(SP)	;SAVE R1
	MOV	#ROLBAS,R1	;GET ADDRESS OF ROLLS
	ADD	#CODROL,R1	;SKIP TO OBJECT ROLL
	MOV	(R1),R1		;GET ADDRESS OF OPCODE ENTRY IN CODROL
	ADD	#6,R1		;SKIP TO OPCODE TEXT
	SWAB	(R1)		;FLIP OPCODE BYTE TO UPPER BYTE
	ADD	R0,(R1)		;FORCE INDEXED AND SET PBYTE
	BIC	#100000,-(R1)	;SET OPCODE TO WORD MODE
	PULL	R1		;RESTORE R1
	CLR	2(SP)		;ZAP ALL FLAGS
	RET			;AND EXIT
1$:	PUSH	(R4)		;SAVE CURRENT VALUE
	MOVB	R0,(R4)+	;PUT PBYTE INTO VALUE
	CLRB	(R4)+		;ZAP UPPER BYTE
	PUSH	-(R4)		;SAVE MODE
	CLR	(R4)		;AND ZAP IT
	PUSH	<-(R4),-(R4),BYTMOD>	;SAVE SYMBOL AND BYTMOD
	INC	BYTMOD		;SET BYTE
	SETIMM			;PREPARE FOR OBJECT ROLL
	STCODE			;STUFF IT
	PULL	<BYTMOD,(R4)+,(R4)+,(R4)+,(R4)>
	RET
	.PAGE
	.SBTTL	EXG,PSHS,PSHU,PLUS,PULU,TFR

EXG:	
TFR:
	CLR	BYTMOD
	MOV	#2,ARGCNT	;OP CODE TO UPPER BYTE
	SWAB	R1
7$:	GSARG			;GET A SYMBOL
	BEQ	1$		;DONE
	SSRCH			;SEARCH SYMOBL TABLES
	INSERT			;UPDATE SYMBOL TABLE
	CRFREF			;CROSS-REF IT
	BITB	#REGFLG,MODE	;REGISTER TYPE?
	BNE	2$		;YES
	CLR	(RVAL)		;NOT ALLOWED
2$:	CLR	R2
	MOV	(RVAL),R0		;GET BIT
5$:	INC	R2	
	ROR	R0		;LOOK FOR BIT
	BCS	3$		;FOUND IT
	BNE	5$		;CONTINUE
6$:	CLR	R2
	CLR	R0		;ZAP ANY EXTRANEOUS BITS
3$:	BNE	6$		;ONLY 1 BIT ALLOWED
	ASLB	R1
	ASLB	R1
	ASLB	R1
	ASLB	R1
	BISB	TFEX(R2),R0
	BMI	9$		;NO, GOOD
	BISB	R0,R1
	MOVB	#200,CRFDFL+1	;DESTRUCTIVE REF
	DEC	ARGCNT		;2 OPERANDS RQD.	
	BNE	7$		;CONTINUE
1$:	TST	ARGCNT		;2 ARG?
	BEQ	8$		;YES
9$:	ERROR	R		;ERROR
8$:	CLR	MODE		;SET ABS
	MOV	R1,(RVAL)	;SET VALUE
	MOV	R1,R0		;GET A COPY
	ASR	R1
	ASR	R1
	ASR	R1
	ASR	R1
	BIC	#^C10,R1	;ZAP ALL BUT 1 BIT
	BIC	#^C10,R0	;ZAP ALL BUT 1 BIT
	SUB	R0,R1		;TYPES MATCH
	BEQ	10$		;YES
	ERROR	R		;NO. SET ERROR
10$:	SETIMM			;SET UP FLAGS
	STCODE			;STUFF IT
	RET			;DONE
	
ARGCNT:	.WORD	0
	
TFEX:	.BYTE -1,12,10,11,13,1,2,4,3,5,0,-1,-1,-1,-1,-1,-1,-1	;18 BYTES
	.PAGE
PULS:	MOV	#16.,R3
PULU:	MOVB	#200,CRFDFL+1	;SIGNAL DEST
	BR	PPLL
PSHS:	MOV	#16.,R3
PSHU:
PPLL:
	SWAB	R1		;PUT VALUE INTO UPPER BYTE
	CLR	BYTMOD		;SET TO WORD MODE
4$:	GSARG			;TRY FOR AN ARGUMENT
	BEQ	1$		;END
	SSRCH			;LOOK FOR IT IN SYMBOL TABLE
	INSERT			;UPDATE SYMROL
	CRFREF			;CROSS REFERENCE IT
	BITB	#REGFLG,MODE	;REGISTER TYPE?
	BEQ	2$		;NO. ERROR
	CLR	R2
	MOV	(RVAL),R0	;GET VALUE
	BEQ	2$		;NONE PRESENT. ERROR
5$:	ROR	R0		;LOOK FOR BIT
	BCS	3$
	BEQ	4$		;DONE. TRY FOR ANOTHER
	INC	R2
	BR	5$
3$:	PUSH	R3		;SAVE POINTER INDEX
	ADD	#PSHTBL,(SP)	;COMPUTE ADDRESS
	ADD	R2,(SP)
	MOVB	@(SP)+,-(SP)	;GET DATA
	BNE	6$
	ERROR	R
	CLR	(SP)
6$:	BISB	(SP)+,R1	;PUT IN DATA
	BR	5$		;CONTINUE
2$:	ERROR	R		;SIGNAL ERROR
	BR	4$
1$:	MOV	R1,(RVAL)	;PASS VALUE
	CLR	MODE		;SET ABS
	SETIMM			;SET FLAGS
	STCODE			;STUFF IT
	RET			;DONE
PSHTBL:	.BYTE 1,2,4,10,20,40,100,0,200,6,0,0,0,0,0,0
	.BYTE 1,2,4,10,20,40,0,100,200,6,0,0,0,0,0,0
	.END
                                                                                                                                                                                                                                                                                                                          